<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyracmon.model API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyracmon.model</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections import OrderedDict
from collections.abc import Iterator, Sequence
from typing import Any, Union, Optional, Callable, Generic, TypeVar, get_origin, get_args, cast, TYPE_CHECKING
from typing_extensions import TypeVarTuple, Unpack, Self, dataclass_transform
from .util import PKS


#----------------------------------------------------------------
# Pseudo types used only for type hinting.
#----------------------------------------------------------------
M = TypeVar(&#39;M&#39;)
MXS = TypeVarTuple(&#39;MXS&#39;)
COLUMN = NotImplemented


class Mixins(Generic[Unpack[MXS]]):
    pass
MXT = TypeVar(&#39;MXT&#39;, bound=Mixins)


if TYPE_CHECKING:
    @dataclass_transform(kw_only_default=True)
    class Meta(type):
        #: Table name.
        name: str
        #: `Table` object.
        table: &#39;Table&#39;
        #: A list of `Column` s.
        columns: list[&#39;Column&#39;]
        #: An object exposing `Column` object via the attribute of its name.
        column: Any

        def __iter__(self) -&gt; Iterator[tuple[&#39;Column&#39;, Any]]: ...
        def __getitem__(self, key: str) -&gt; Any: ...
        def __contains__(self, key) -&gt; bool: ...

        @classmethod
        def shrink(cls, excludes, includes=None) -&gt; Self: ...


    class Model(Mixins[Unpack[MXS]], metaclass=Meta):
        &#34;&#34;&#34;
        Base type of model types.

        This class only works as a marker of model types and gives no functionalities to them.
        &#34;&#34;&#34;
        def __init__(self, **kwargs) -&gt; None: ... # for typing
else:
    class Meta:
        pass
    class Model:
        pass
#----------------------------------------------------------------
Record = Union[Meta, dict[str, Any]]
&#34;&#34;&#34;Model object or dict corresponding to a table row.&#34;&#34;&#34;


class ForeignKey:
    &#34;&#34;&#34;
    This class represents a foreign key constraint.
    &#34;&#34;&#34;
    def __init__(self, table: Union[&#39;Table&#39;, str], column: Union[str, &#39;Column&#39;]) -&gt; None:
        #: Referenced table model, table name is set alternatively when the table is not modelled.
        self.table = table
        #: Referenced column model, column name is set alternatively when the column is not modelled.
        self.column = column


class Relations:
    &#34;&#34;&#34;
    This class represents foreign key constraints on a column.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        #: Foreign key constraints on a column.
        self.constraints: list[ForeignKey] = []

    def add(self, fk: ForeignKey):
        &#34;&#34;&#34;
        Adds a constraint.

        Args:
            fk: Foreign key constraint.
        &#34;&#34;&#34;
        self.constraints.append(fk)


class Column:
    &#34;&#34;&#34;
    This class represents a schema of a column.
    &#34;&#34;&#34;
    def __init__(
        self,
        name: str,
        ptype: type,
        type_info: Optional[Any],
        pk: bool,
        fk: Optional[Relations],
        incremental: Optional[Any],
        nullable: bool,
        comment: str = &#34;&#34;,
    ):
        #: Column name.
        self.name = name
        #: Data type in python.
        self.ptype = ptype
        #: Type informations obtained from DB.
        self.type_info = type_info
        #: Is this column a primary key?
        self.pk = pk
        #: Foreign key constraints.
        self.fk = fk
        #: If this column is auto-incremental, this object contains the information of the feature, otherwise, `None`.
        self.incremental = incremental
        #: Can this column contain null?
        self.nullable = nullable
        #: Comment of the column.
        self.comment = comment


class Table:
    &#34;&#34;&#34;
    This class represents a schema of a table.
    &#34;&#34;&#34;
    def __init__(self, name: str, columns: list[Column], comment: str = &#34;&#34;):
        #: Table name.
        self.name = name
        #: Columns in the table.
        self.columns = columns
        #: Comment of the table.
        self.comment = comment

    def find(self, name: str) -&gt; Optional[Column]:
        &#34;&#34;&#34;
        Find a column by name.

        Args:
            name: Column name.
        Returns:
            The column if exists, otherwise `None`.
        &#34;&#34;&#34;
        return next(filter(lambda c: c.name == name, self.columns), None)


def define_model(table_: Table, mixins: Union[type[MXT], list[type], None] = None, model_type: Optional[type[M]] = Model) -&gt; type[M]:
    &#34;&#34;&#34;
    Create a model type representing a table.

    Model type inherits all types in `mixins` in order.
    When the same attribute is defined in multiple mixin types, the former overrides the latter.

    Every model type has following attributes:

    |name|type|description|
    |:---|:---|:---|
    |name|`str`|Name of the table.|
    |table|`Table`|Table schema.|
    |columns|`List[Column]`|List of column schemas.|
    |column|`Any`|An object whose attribute exposes of column schema of its name.|

    Model instances are created by passing the constructor keyword arguments composed of column names and values like builtin dataclass.
    Unlike dataclass, the constructor does not require all of columns.
    Omitted columns don&#39;t affect predefined operations such as `CRUDMixin.insert` .
    If `not null` constraint exists on the column, insertion will be denied at runtime and exception will be thrown.

    ```python
    &gt;&gt;&gt; # CREATE TABLE t1 (col1 int, col2 text, col3 text);
    &gt;&gt;&gt; table = define_model(&#34;t1&#34;)
    &gt;&gt;&gt; model = table(col1=1, col2=&#34;a&#34;)
    ```

    Attributes are also assignable by normal setter. If attribute name is not a valid column name, `TypeError` raises.

    ```python
    &gt;&gt;&gt; model.col3 = &#34;b&#34;
    ```

    Model instance supports iteration which yields pairs of assigned column schema and its value.

    ```python
    &gt;&gt;&gt; for c, v in model:
    &gt;&gt;&gt;     print(f&#34;{c.name} = {v}&#34;)
    col1 = 1
    col2 = a
    col3 = b
    ```

    Args:
        table__: Table schema.
        mixin: Mixin types providing class methods to the model type.
        model_type: Use this just for type hinting to determine returned model type.
    Returns:
        Model type.
    &#34;&#34;&#34;
    column_names = {c.name for c in table_.columns}

    class Columns:
        def __init__(self):
            for c in table_.columns:
                setattr(self, c.name, c)

    class Meta(type):
        name = table_.name
        table = table_
        columns = table_.columns
        column = Columns()

        @classmethod
        def shrink(cls, excludes: list[str], includes: Optional[list[str]] = None) -&gt; Self:
            &#34;&#34;&#34;
            Creates new model type containing subset of columns.

            Args:
                excludes: Column names to exclude.
                includes: Column names to include.
            Returns:
                model type.
            &#34;&#34;&#34;
            cols = [c for c in cls.columns if (not includes or c.name in includes) and c.name not in excludes]
            return define_model(Table(cls.name, cols, cls.table.comment), mixins) # type: ignore

    class Base(Model, metaclass=Meta):
        pass

    mixin_types: list[type] = []

    if isinstance(mixins, list):
        mixin_types = mixins
    elif get_origin(mixins) is not None:
        mixin_types = cast(list[type], list(get_args(mixins)))
    elif mixins is not None:
        raise ValueError(f&#34;Model mixin types should be specified by Mixins or a list of types.&#34;)

    class _Model(type(&#34;ModelBase&#34;, tuple([Base] + mixin_types), {})):
        def __init__(self, **kwargs):
            for k, v in kwargs.items():
                setattr(self, k, v)

        def __repr__(self):
            cls = cast(type[Base], type(self))
            return f&#34;{cls.name}({&#39;, &#39;.join([f&#39;{c.name}={repr(getattr(self, c.name))}&#39; for c in cls.columns if hasattr(self, c.name)])})&#34;

        def __str__(self):
            cls = cast(type[Base], type(self))
            return f&#34;{cls.name}({&#39;, &#39;.join([f&#39;{c.name}={str(getattr(self, c.name))}&#39; for c in cls.columns if hasattr(self, c.name)])})&#34;

        def __iter__(self) -&gt; Iterator[tuple[Column, Any]]:
            cls = cast(type[Base], type(self))
            return map(lambda c: (c, getattr(self, c.name)), filter(lambda c: hasattr(self, c.name), cls.columns))

        def __setattr__(self, key, value):
            cls = cast(type[Base], type(self))
            if key not in column_names:
                raise TypeError(f&#34;{key} is not a column of {cls.name}&#34;)
            object.__setattr__(self, key, value)

        def __getitem__(self, key):
            return getattr(self, key)

        def __contains__(self, key):
            return hasattr(self, key)

        def __eq__(self, other):
            cls = type(self)
            if cls != type(other):
                return False
            for k in column_names:
                if hasattr(self, k) ^ hasattr(other, k):
                    return False
                if getattr(self, k, None) != getattr(other, k, None):
                    return False
            return True

    return cast(type[M], _Model)


def parse_pks(model: type[Meta], pks: PKS) -&gt; tuple[list[str], list[Any]]:
    &#34;&#34;&#34;
    Generates a pair of PK columns names and their values from polymorphic input.

    Args:
        model: Model class.
        pks: A dictionary of PK column name and their values or an object of single PK column.
    Returns:
        Names of PK columns and their values.
    &#34;&#34;&#34;
    if isinstance(pks, dict):
        ordered = check_columns(model, pks, lambda c: c.pk, True)
        return [v[0] for v in ordered], [v[1] for v in ordered]
    else:
        cols = [c.name for c in model.columns if c.pk]
        if len(cols) != 1:
            raise ValueError(f&#34;The number of primary key columns in {model.name} is not 1.&#34;)
        return ([cols[0]], [pks])


def extract_pks(model: type[Meta], record: Record) -&gt; PKS:
    &#34;&#34;&#34;
    Extract all primary keys from a record.

    Args:
        model: Model class.
        record: A record.
    Returns:
        Primary keys.
    &#34;&#34;&#34;
    pk_columns = [c.name for c in model.columns if c.pk]
    if isinstance(record, dict):
        pks = dict((c, record[c]) for c in pk_columns if c in record)
    else:
        pks = dict((c, getattr(record, c)) for c in pk_columns if hasattr(record, c))
    if len(pks) != len(pk_columns):
        missing = set(pk_columns) - set(pks.keys())
        raise ValueError(f&#34;Some primary keys are not contained in passed values and auto-increment values: {missing}&#34;)
    return pks


def check_columns(
    model: type[Meta],
    col_map: dict[str, Any],
    condition: Callable[[Column], bool] = lambda c: True,
    requires_all: bool = False,
) -&gt; list[tuple[str, Any]]:
    &#34;&#34;&#34;
    Checks keys of given `dict` match columns selected by a condition from a model.

    Args:
        model: Model class.
        col_map: Dictionary whose keys are column names.
        condition: A function which selects columns from the model.
        requires_all: If `True`, `ValueError` raises when the dictionary does not contain keys of all selected columns.
    &#34;&#34;&#34;
    names = [c.name for c in model.columns if condition(c)]
    name_set = set(names)
    targets = set(col_map.keys())
    if not name_set &gt;= targets:
        raise ValueError(f&#34;Columns {targets - name_set} are not specified columns of &#39;{model.name}&#39;.&#34;)
    if requires_all and not name_set == targets:
        raise ValueError(f&#34;Required columns {name_set - targets} in &#39;{model.name}&#39; are not found.&#34;)
    return [(n, col_map[n]) for n in names if n in col_map]


def model_values(model: type[Meta], values: Record, excludes_pk: bool = False) -&gt; dict[str, Any]:
    &#34;&#34;&#34;
    Generates a dictionary whose items are pairs of column name and column value.

    Args:
        model: Model class.
        values: Dictionary from column name to column value or a model instance.
        excludes_pk: If `True`, item of PK column is not contained in returned dictionary.
    Returns:
        A dictionary from column name to column value.
    &#34;&#34;&#34;
    if isinstance(values, (dict, OrderedDict)):
        includes = {c.name for c in model.columns if (not excludes_pk) or (not c.pk)}
        return {k:v for k, v in values.items() if k in includes}
    elif isinstance(values, model):
        return {cv[0].name:cv[1] for cv in values if (not excludes_pk) or (not cv[0].pk)}
    else:
        raise TypeError(f&#34;Required column value is not contained in the dictionary or model.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="pyracmon.model.Record"><code class="name">var <span class="ident">Record</span></code></dt>
<dd>
<div class="desc"><p>Model object or dict corresponding to a table row.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyracmon.model.check_columns"><code class="name flex">
<span>def <span class="ident">check_columns</span></span>(<span>model: type[<a title="pyracmon.model.Meta" href="#pyracmon.model.Meta">Meta</a>], col_map: dict[str, typing.Any], condition: Callable[[<a title="pyracmon.model.Column" href="#pyracmon.model.Column">Column</a>], bool] = &lt;function &lt;lambda&gt;&gt;, requires_all: bool = False) ‑> list[tuple[str, typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks keys of given <code>dict</code> match columns selected by a condition from a model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong></dt>
<dd>Model class.</dd>
<dt><strong><code>col_map</code></strong></dt>
<dd>Dictionary whose keys are column names.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>A function which selects columns from the model.</dd>
<dt><strong><code>requires_all</code></strong></dt>
<dd>If <code>True</code>, <code>ValueError</code> raises when the dictionary does not contain keys of all selected columns.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_columns(
    model: type[Meta],
    col_map: dict[str, Any],
    condition: Callable[[Column], bool] = lambda c: True,
    requires_all: bool = False,
) -&gt; list[tuple[str, Any]]:
    &#34;&#34;&#34;
    Checks keys of given `dict` match columns selected by a condition from a model.

    Args:
        model: Model class.
        col_map: Dictionary whose keys are column names.
        condition: A function which selects columns from the model.
        requires_all: If `True`, `ValueError` raises when the dictionary does not contain keys of all selected columns.
    &#34;&#34;&#34;
    names = [c.name for c in model.columns if condition(c)]
    name_set = set(names)
    targets = set(col_map.keys())
    if not name_set &gt;= targets:
        raise ValueError(f&#34;Columns {targets - name_set} are not specified columns of &#39;{model.name}&#39;.&#34;)
    if requires_all and not name_set == targets:
        raise ValueError(f&#34;Required columns {name_set - targets} in &#39;{model.name}&#39; are not found.&#34;)
    return [(n, col_map[n]) for n in names if n in col_map]</code></pre>
</details>
</dd>
<dt id="pyracmon.model.define_model"><code class="name flex">
<span>def <span class="ident">define_model</span></span>(<span>table_: <a title="pyracmon.model.Table" href="#pyracmon.model.Table">Table</a>, mixins: Union[type[~MXT], list[type], ForwardRef(None)] = None, model_type: Optional[type[~M]] = pyracmon.model.Model) ‑> type[~M]</span>
</code></dt>
<dd>
<div class="desc"><p>Create a model type representing a table.</p>
<p>Model type inherits all types in <code>mixins</code> in order.
When the same attribute is defined in multiple mixin types, the former overrides the latter.</p>
<p>Every model type has following attributes:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">name</th>
<th style="text-align: left;">type</th>
<th style="text-align: left;">description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">name</td>
<td style="text-align: left;"><code>str</code></td>
<td style="text-align: left;">Name of the table.</td>
</tr>
<tr>
<td style="text-align: left;">table</td>
<td style="text-align: left;"><code><a title="pyracmon.model.Table" href="#pyracmon.model.Table">Table</a></code></td>
<td style="text-align: left;">Table schema.</td>
</tr>
<tr>
<td style="text-align: left;">columns</td>
<td style="text-align: left;"><code>List[<a title="pyracmon.model.Column" href="#pyracmon.model.Column">Column</a>]</code></td>
<td style="text-align: left;">List of column schemas.</td>
</tr>
<tr>
<td style="text-align: left;">column</td>
<td style="text-align: left;"><code>Any</code></td>
<td style="text-align: left;">An object whose attribute exposes of column schema of its name.</td>
</tr>
</tbody>
</table>
<p>Model instances are created by passing the constructor keyword arguments composed of column names and values like builtin dataclass.
Unlike dataclass, the constructor does not require all of columns.
Omitted columns don't affect predefined operations such as <code>CRUDMixin.insert</code> .
If <code>not null</code> constraint exists on the column, insertion will be denied at runtime and exception will be thrown.</p>
<pre><code class="language-python">&gt;&gt;&gt; # CREATE TABLE t1 (col1 int, col2 text, col3 text);
&gt;&gt;&gt; table = define_model(&quot;t1&quot;)
&gt;&gt;&gt; model = table(col1=1, col2=&quot;a&quot;)
</code></pre>
<p>Attributes are also assignable by normal setter. If attribute name is not a valid column name, <code>TypeError</code> raises.</p>
<pre><code class="language-python">&gt;&gt;&gt; model.col3 = &quot;b&quot;
</code></pre>
<p>Model instance supports iteration which yields pairs of assigned column schema and its value.</p>
<pre><code class="language-python">&gt;&gt;&gt; for c, v in model:
&gt;&gt;&gt;     print(f&quot;{c.name} = {v}&quot;)
col1 = 1
col2 = a
col3 = b
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>table__</code></strong></dt>
<dd>Table schema.</dd>
<dt><strong><code>mixin</code></strong></dt>
<dd>Mixin types providing class methods to the model type.</dd>
<dt><strong><code>model_type</code></strong></dt>
<dd>Use this just for type hinting to determine returned model type.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_model(table_: Table, mixins: Union[type[MXT], list[type], None] = None, model_type: Optional[type[M]] = Model) -&gt; type[M]:
    &#34;&#34;&#34;
    Create a model type representing a table.

    Model type inherits all types in `mixins` in order.
    When the same attribute is defined in multiple mixin types, the former overrides the latter.

    Every model type has following attributes:

    |name|type|description|
    |:---|:---|:---|
    |name|`str`|Name of the table.|
    |table|`Table`|Table schema.|
    |columns|`List[Column]`|List of column schemas.|
    |column|`Any`|An object whose attribute exposes of column schema of its name.|

    Model instances are created by passing the constructor keyword arguments composed of column names and values like builtin dataclass.
    Unlike dataclass, the constructor does not require all of columns.
    Omitted columns don&#39;t affect predefined operations such as `CRUDMixin.insert` .
    If `not null` constraint exists on the column, insertion will be denied at runtime and exception will be thrown.

    ```python
    &gt;&gt;&gt; # CREATE TABLE t1 (col1 int, col2 text, col3 text);
    &gt;&gt;&gt; table = define_model(&#34;t1&#34;)
    &gt;&gt;&gt; model = table(col1=1, col2=&#34;a&#34;)
    ```

    Attributes are also assignable by normal setter. If attribute name is not a valid column name, `TypeError` raises.

    ```python
    &gt;&gt;&gt; model.col3 = &#34;b&#34;
    ```

    Model instance supports iteration which yields pairs of assigned column schema and its value.

    ```python
    &gt;&gt;&gt; for c, v in model:
    &gt;&gt;&gt;     print(f&#34;{c.name} = {v}&#34;)
    col1 = 1
    col2 = a
    col3 = b
    ```

    Args:
        table__: Table schema.
        mixin: Mixin types providing class methods to the model type.
        model_type: Use this just for type hinting to determine returned model type.
    Returns:
        Model type.
    &#34;&#34;&#34;
    column_names = {c.name for c in table_.columns}

    class Columns:
        def __init__(self):
            for c in table_.columns:
                setattr(self, c.name, c)

    class Meta(type):
        name = table_.name
        table = table_
        columns = table_.columns
        column = Columns()

        @classmethod
        def shrink(cls, excludes: list[str], includes: Optional[list[str]] = None) -&gt; Self:
            &#34;&#34;&#34;
            Creates new model type containing subset of columns.

            Args:
                excludes: Column names to exclude.
                includes: Column names to include.
            Returns:
                model type.
            &#34;&#34;&#34;
            cols = [c for c in cls.columns if (not includes or c.name in includes) and c.name not in excludes]
            return define_model(Table(cls.name, cols, cls.table.comment), mixins) # type: ignore

    class Base(Model, metaclass=Meta):
        pass

    mixin_types: list[type] = []

    if isinstance(mixins, list):
        mixin_types = mixins
    elif get_origin(mixins) is not None:
        mixin_types = cast(list[type], list(get_args(mixins)))
    elif mixins is not None:
        raise ValueError(f&#34;Model mixin types should be specified by Mixins or a list of types.&#34;)

    class _Model(type(&#34;ModelBase&#34;, tuple([Base] + mixin_types), {})):
        def __init__(self, **kwargs):
            for k, v in kwargs.items():
                setattr(self, k, v)

        def __repr__(self):
            cls = cast(type[Base], type(self))
            return f&#34;{cls.name}({&#39;, &#39;.join([f&#39;{c.name}={repr(getattr(self, c.name))}&#39; for c in cls.columns if hasattr(self, c.name)])})&#34;

        def __str__(self):
            cls = cast(type[Base], type(self))
            return f&#34;{cls.name}({&#39;, &#39;.join([f&#39;{c.name}={str(getattr(self, c.name))}&#39; for c in cls.columns if hasattr(self, c.name)])})&#34;

        def __iter__(self) -&gt; Iterator[tuple[Column, Any]]:
            cls = cast(type[Base], type(self))
            return map(lambda c: (c, getattr(self, c.name)), filter(lambda c: hasattr(self, c.name), cls.columns))

        def __setattr__(self, key, value):
            cls = cast(type[Base], type(self))
            if key not in column_names:
                raise TypeError(f&#34;{key} is not a column of {cls.name}&#34;)
            object.__setattr__(self, key, value)

        def __getitem__(self, key):
            return getattr(self, key)

        def __contains__(self, key):
            return hasattr(self, key)

        def __eq__(self, other):
            cls = type(self)
            if cls != type(other):
                return False
            for k in column_names:
                if hasattr(self, k) ^ hasattr(other, k):
                    return False
                if getattr(self, k, None) != getattr(other, k, None):
                    return False
            return True

    return cast(type[M], _Model)</code></pre>
</details>
</dd>
<dt id="pyracmon.model.extract_pks"><code class="name flex">
<span>def <span class="ident">extract_pks</span></span>(<span>model: type[<a title="pyracmon.model.Meta" href="#pyracmon.model.Meta">Meta</a>], record: Union[<a title="pyracmon.model.Meta" href="#pyracmon.model.Meta">Meta</a>, dict[str, Any]]) ‑> Union[Any, dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Extract all primary keys from a record.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong></dt>
<dd>Model class.</dd>
<dt><strong><code>record</code></strong></dt>
<dd>A record.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Primary keys.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_pks(model: type[Meta], record: Record) -&gt; PKS:
    &#34;&#34;&#34;
    Extract all primary keys from a record.

    Args:
        model: Model class.
        record: A record.
    Returns:
        Primary keys.
    &#34;&#34;&#34;
    pk_columns = [c.name for c in model.columns if c.pk]
    if isinstance(record, dict):
        pks = dict((c, record[c]) for c in pk_columns if c in record)
    else:
        pks = dict((c, getattr(record, c)) for c in pk_columns if hasattr(record, c))
    if len(pks) != len(pk_columns):
        missing = set(pk_columns) - set(pks.keys())
        raise ValueError(f&#34;Some primary keys are not contained in passed values and auto-increment values: {missing}&#34;)
    return pks</code></pre>
</details>
</dd>
<dt id="pyracmon.model.model_values"><code class="name flex">
<span>def <span class="ident">model_values</span></span>(<span>model: type[<a title="pyracmon.model.Meta" href="#pyracmon.model.Meta">Meta</a>], values: Union[<a title="pyracmon.model.Meta" href="#pyracmon.model.Meta">Meta</a>, dict[str, Any]], excludes_pk: bool = False) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a dictionary whose items are pairs of column name and column value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong></dt>
<dd>Model class.</dd>
<dt><strong><code>values</code></strong></dt>
<dd>Dictionary from column name to column value or a model instance.</dd>
<dt><strong><code>excludes_pk</code></strong></dt>
<dd>If <code>True</code>, item of PK column is not contained in returned dictionary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary from column name to column value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def model_values(model: type[Meta], values: Record, excludes_pk: bool = False) -&gt; dict[str, Any]:
    &#34;&#34;&#34;
    Generates a dictionary whose items are pairs of column name and column value.

    Args:
        model: Model class.
        values: Dictionary from column name to column value or a model instance.
        excludes_pk: If `True`, item of PK column is not contained in returned dictionary.
    Returns:
        A dictionary from column name to column value.
    &#34;&#34;&#34;
    if isinstance(values, (dict, OrderedDict)):
        includes = {c.name for c in model.columns if (not excludes_pk) or (not c.pk)}
        return {k:v for k, v in values.items() if k in includes}
    elif isinstance(values, model):
        return {cv[0].name:cv[1] for cv in values if (not excludes_pk) or (not cv[0].pk)}
    else:
        raise TypeError(f&#34;Required column value is not contained in the dictionary or model.&#34;)</code></pre>
</details>
</dd>
<dt id="pyracmon.model.parse_pks"><code class="name flex">
<span>def <span class="ident">parse_pks</span></span>(<span>model: type[<a title="pyracmon.model.Meta" href="#pyracmon.model.Meta">Meta</a>], pks: Union[Any, dict[str, Any]]) ‑> tuple[list[str], list[typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a pair of PK columns names and their values from polymorphic input.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>model</code></strong></dt>
<dd>Model class.</dd>
<dt><strong><code>pks</code></strong></dt>
<dd>A dictionary of PK column name and their values or an object of single PK column.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Names of PK columns and their values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_pks(model: type[Meta], pks: PKS) -&gt; tuple[list[str], list[Any]]:
    &#34;&#34;&#34;
    Generates a pair of PK columns names and their values from polymorphic input.

    Args:
        model: Model class.
        pks: A dictionary of PK column name and their values or an object of single PK column.
    Returns:
        Names of PK columns and their values.
    &#34;&#34;&#34;
    if isinstance(pks, dict):
        ordered = check_columns(model, pks, lambda c: c.pk, True)
        return [v[0] for v in ordered], [v[1] for v in ordered]
    else:
        cols = [c.name for c in model.columns if c.pk]
        if len(cols) != 1:
            raise ValueError(f&#34;The number of primary key columns in {model.name} is not 1.&#34;)
        return ([cols[0]], [pks])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyracmon.model.Column"><code class="flex name class">
<span>class <span class="ident">Column</span></span>
<span>(</span><span>name: str, ptype: type, type_info: Optional[Any], pk: bool, fk: Optional[<a title="pyracmon.model.Relations" href="#pyracmon.model.Relations">Relations</a>], incremental: Optional[Any], nullable: bool, comment: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a schema of a column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Column:
    &#34;&#34;&#34;
    This class represents a schema of a column.
    &#34;&#34;&#34;
    def __init__(
        self,
        name: str,
        ptype: type,
        type_info: Optional[Any],
        pk: bool,
        fk: Optional[Relations],
        incremental: Optional[Any],
        nullable: bool,
        comment: str = &#34;&#34;,
    ):
        #: Column name.
        self.name = name
        #: Data type in python.
        self.ptype = ptype
        #: Type informations obtained from DB.
        self.type_info = type_info
        #: Is this column a primary key?
        self.pk = pk
        #: Foreign key constraints.
        self.fk = fk
        #: If this column is auto-incremental, this object contains the information of the feature, otherwise, `None`.
        self.incremental = incremental
        #: Can this column contain null?
        self.nullable = nullable
        #: Comment of the column.
        self.comment = comment</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.model.Column.comment"><code class="name">var <span class="ident">comment</span></code></dt>
<dd>
<div class="desc"><p>Comment of the column.</p></div>
</dd>
<dt id="pyracmon.model.Column.fk"><code class="name">var <span class="ident">fk</span></code></dt>
<dd>
<div class="desc"><p>Foreign key constraints.</p></div>
</dd>
<dt id="pyracmon.model.Column.incremental"><code class="name">var <span class="ident">incremental</span></code></dt>
<dd>
<div class="desc"><p>If this column is auto-incremental, this object contains the information of the feature, otherwise, <code>None</code>.</p></div>
</dd>
<dt id="pyracmon.model.Column.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Column name.</p></div>
</dd>
<dt id="pyracmon.model.Column.nullable"><code class="name">var <span class="ident">nullable</span></code></dt>
<dd>
<div class="desc"><p>Can this column contain null?</p></div>
</dd>
<dt id="pyracmon.model.Column.pk"><code class="name">var <span class="ident">pk</span></code></dt>
<dd>
<div class="desc"><p>Is this column a primary key?</p></div>
</dd>
<dt id="pyracmon.model.Column.ptype"><code class="name">var <span class="ident">ptype</span></code></dt>
<dd>
<div class="desc"><p>Data type in python.</p></div>
</dd>
<dt id="pyracmon.model.Column.type_info"><code class="name">var <span class="ident">type_info</span></code></dt>
<dd>
<div class="desc"><p>Type informations obtained from DB.</p></div>
</dd>
</dl>
</dd>
<dt id="pyracmon.model.ForeignKey"><code class="flex name class">
<span>class <span class="ident">ForeignKey</span></span>
<span>(</span><span>table: Union[ForwardRef('<a title="pyracmon.model.Table" href="#pyracmon.model.Table">Table</a>'), str], column: Union[str, ForwardRef('<a title="pyracmon.model.Column" href="#pyracmon.model.Column">Column</a>')])</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a foreign key constraint.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForeignKey:
    &#34;&#34;&#34;
    This class represents a foreign key constraint.
    &#34;&#34;&#34;
    def __init__(self, table: Union[&#39;Table&#39;, str], column: Union[str, &#39;Column&#39;]) -&gt; None:
        #: Referenced table model, table name is set alternatively when the table is not modelled.
        self.table = table
        #: Referenced column model, column name is set alternatively when the column is not modelled.
        self.column = column</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.model.ForeignKey.column"><code class="name">var <span class="ident">column</span></code></dt>
<dd>
<div class="desc"><p>Referenced column model, column name is set alternatively when the column is not modelled.</p></div>
</dd>
<dt id="pyracmon.model.ForeignKey.table"><code class="name">var <span class="ident">table</span></code></dt>
<dd>
<div class="desc"><p>Referenced table model, table name is set alternatively when the table is not modelled.</p></div>
</dd>
</dl>
</dd>
<dt id="pyracmon.model.Meta"><code class="flex name class">
<span>class <span class="ident">Meta</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass_transform(kw_only_default=True)
class Meta(type):
    #: Table name.
    name: str
    #: `Table` object.
    table: &#39;Table&#39;
    #: A list of `Column` s.
    columns: list[&#39;Column&#39;]
    #: An object exposing `Column` object via the attribute of its name.
    column: Any

    def __iter__(self) -&gt; Iterator[tuple[&#39;Column&#39;, Any]]: ...
    def __getitem__(self, key: str) -&gt; Any: ...
    def __contains__(self, key) -&gt; bool: ...

    @classmethod
    def shrink(cls, excludes, includes=None) -&gt; Self: ...</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.model_graph.GraphEntityMixin" href="model_graph.html#pyracmon.model_graph.GraphEntityMixin">GraphEntityMixin</a></li>
</ul>
</dd>
<dt id="pyracmon.model.Mixins"><code class="flex name class">
<span>class <span class="ident">Mixins</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract base class for generic types.</p>
<p>A generic type is typically declared by inheriting from
this class parameterized with one or more type variables.
For example, a generic mapping type might be defined as::</p>
<p>class Mapping(Generic[KT, VT]):
def <strong>getitem</strong>(self, key: KT) -&gt; VT:
&hellip;
# Etc.</p>
<p>This class can then be used as follows::</p>
<p>def lookup_name(mapping: Mapping[KT, VT], key: KT, default: VT) -&gt; VT:
try:
return mapping[key]
except KeyError:
return default</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mixins(Generic[Unpack[MXS]]):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
</dd>
<dt id="pyracmon.model.Model"><code class="flex name class">
<span>class <span class="ident">Model</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Model(Mixins[Unpack[MXS]], metaclass=Meta):
    &#34;&#34;&#34;
    Base type of model types.

    This class only works as a marker of model types and gives no functionalities to them.
    &#34;&#34;&#34;
    def __init__(self, **kwargs) -&gt; None: ... # for typing</code></pre>
</details>
</dd>
<dt id="pyracmon.model.Relations"><code class="flex name class">
<span>class <span class="ident">Relations</span></span>
</code></dt>
<dd>
<div class="desc"><p>This class represents foreign key constraints on a column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Relations:
    &#34;&#34;&#34;
    This class represents foreign key constraints on a column.
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        #: Foreign key constraints on a column.
        self.constraints: list[ForeignKey] = []

    def add(self, fk: ForeignKey):
        &#34;&#34;&#34;
        Adds a constraint.

        Args:
            fk: Foreign key constraint.
        &#34;&#34;&#34;
        self.constraints.append(fk)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.model.Relations.constraints"><code class="name">var <span class="ident">constraints</span></code></dt>
<dd>
<div class="desc"><p>Foreign key constraints on a column.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.model.Relations.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, fk: <a title="pyracmon.model.ForeignKey" href="#pyracmon.model.ForeignKey">ForeignKey</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a constraint.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fk</code></strong></dt>
<dd>Foreign key constraint.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, fk: ForeignKey):
    &#34;&#34;&#34;
    Adds a constraint.

    Args:
        fk: Foreign key constraint.
    &#34;&#34;&#34;
    self.constraints.append(fk)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.model.Table"><code class="flex name class">
<span>class <span class="ident">Table</span></span>
<span>(</span><span>name: str, columns: list[<a title="pyracmon.model.Column" href="#pyracmon.model.Column">Column</a>], comment: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a schema of a table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Table:
    &#34;&#34;&#34;
    This class represents a schema of a table.
    &#34;&#34;&#34;
    def __init__(self, name: str, columns: list[Column], comment: str = &#34;&#34;):
        #: Table name.
        self.name = name
        #: Columns in the table.
        self.columns = columns
        #: Comment of the table.
        self.comment = comment

    def find(self, name: str) -&gt; Optional[Column]:
        &#34;&#34;&#34;
        Find a column by name.

        Args:
            name: Column name.
        Returns:
            The column if exists, otherwise `None`.
        &#34;&#34;&#34;
        return next(filter(lambda c: c.name == name, self.columns), None)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.model.Table.columns"><code class="name">var <span class="ident">columns</span></code></dt>
<dd>
<div class="desc"><p>Columns in the table.</p></div>
</dd>
<dt id="pyracmon.model.Table.comment"><code class="name">var <span class="ident">comment</span></code></dt>
<dd>
<div class="desc"><p>Comment of the table.</p></div>
</dd>
<dt id="pyracmon.model.Table.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Table name.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.model.Table.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, name: str) ‑> Optional[<a title="pyracmon.model.Column" href="#pyracmon.model.Column">Column</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Find a column by name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Column name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The column if exists, otherwise <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, name: str) -&gt; Optional[Column]:
    &#34;&#34;&#34;
    Find a column by name.

    Args:
        name: Column name.
    Returns:
        The column if exists, otherwise `None`.
    &#34;&#34;&#34;
    return next(filter(lambda c: c.name == name, self.columns), None)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyracmon" href="index.html">pyracmon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="pyracmon.model.Record" href="#pyracmon.model.Record">Record</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyracmon.model.check_columns" href="#pyracmon.model.check_columns">check_columns</a></code></li>
<li><code><a title="pyracmon.model.define_model" href="#pyracmon.model.define_model">define_model</a></code></li>
<li><code><a title="pyracmon.model.extract_pks" href="#pyracmon.model.extract_pks">extract_pks</a></code></li>
<li><code><a title="pyracmon.model.model_values" href="#pyracmon.model.model_values">model_values</a></code></li>
<li><code><a title="pyracmon.model.parse_pks" href="#pyracmon.model.parse_pks">parse_pks</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyracmon.model.Column" href="#pyracmon.model.Column">Column</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.model.Column.comment" href="#pyracmon.model.Column.comment">comment</a></code></li>
<li><code><a title="pyracmon.model.Column.fk" href="#pyracmon.model.Column.fk">fk</a></code></li>
<li><code><a title="pyracmon.model.Column.incremental" href="#pyracmon.model.Column.incremental">incremental</a></code></li>
<li><code><a title="pyracmon.model.Column.name" href="#pyracmon.model.Column.name">name</a></code></li>
<li><code><a title="pyracmon.model.Column.nullable" href="#pyracmon.model.Column.nullable">nullable</a></code></li>
<li><code><a title="pyracmon.model.Column.pk" href="#pyracmon.model.Column.pk">pk</a></code></li>
<li><code><a title="pyracmon.model.Column.ptype" href="#pyracmon.model.Column.ptype">ptype</a></code></li>
<li><code><a title="pyracmon.model.Column.type_info" href="#pyracmon.model.Column.type_info">type_info</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.model.ForeignKey" href="#pyracmon.model.ForeignKey">ForeignKey</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.model.ForeignKey.column" href="#pyracmon.model.ForeignKey.column">column</a></code></li>
<li><code><a title="pyracmon.model.ForeignKey.table" href="#pyracmon.model.ForeignKey.table">table</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.model.Meta" href="#pyracmon.model.Meta">Meta</a></code></h4>
</li>
<li>
<h4><code><a title="pyracmon.model.Mixins" href="#pyracmon.model.Mixins">Mixins</a></code></h4>
</li>
<li>
<h4><code><a title="pyracmon.model.Model" href="#pyracmon.model.Model">Model</a></code></h4>
</li>
<li>
<h4><code><a title="pyracmon.model.Relations" href="#pyracmon.model.Relations">Relations</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.model.Relations.add" href="#pyracmon.model.Relations.add">add</a></code></li>
<li><code><a title="pyracmon.model.Relations.constraints" href="#pyracmon.model.Relations.constraints">constraints</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.model.Table" href="#pyracmon.model.Table">Table</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.model.Table.columns" href="#pyracmon.model.Table.columns">columns</a></code></li>
<li><code><a title="pyracmon.model.Table.comment" href="#pyracmon.model.Table.comment">comment</a></code></li>
<li><code><a title="pyracmon.model.Table.find" href="#pyracmon.model.Table.find">find</a></code></li>
<li><code><a title="pyracmon.model.Table.name" href="#pyracmon.model.Table.name">name</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>