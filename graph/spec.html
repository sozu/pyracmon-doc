<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyracmon.graph.spec API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyracmon.graph.spec</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import *
from .identify import IdentifyPolicy, HierarchicalPolicy, neverPolicy
from .template import GraphTemplate
from .serialize import S, SerializationContext, NodeSerializer
from .schema import GraphSchema
from .util import Serializer, TemplateProperty
from .typing import issubtype


class GraphSpec:
    &#34;&#34;&#34;
    This class contains the specifications of graph which control various behaviors in the lifecycles of graphs.

    Each instance contains 3 kind of functions; *identifier*, *entity filter* and *serializer*.

    *Identifier* is a function to get a value used for the identification of graph entity. See `Graph` to know how this works.

    *Entity fliter* is a function to determine whether the entity should be appended to a graph or not.
    If `False` is returned for an entity, it is just ignored.

    *Serializer* is a function which converts an entity value into a serializable object,
    whose signature is one of signatures described in `S.each`.
    In serialization phase, registered *serializer* s are first applied and *serializer* in `NodeSerializer` follows.

    Any kind of function is bound to a type when added, which will work as a key to determine whether it should be applied to a node.
    &#34;&#34;&#34;
    def __init__(
        self,
        identifiers: List[Tuple[type, Callable[[Any], Any]]] = None,
        entity_filters: List[Tuple[type, Callable[[Any], bool]]] = None,
        serializers: List[Tuple[type, Serializer]] = None,
    ):
        #: A list of pairs of type and *identifier*.
        self.identifiers = identifiers or []
        #: A list of pairs of type and *entity_filter*.
        self.entity_filters = entity_filters or []
        #: A list of pairs of type and *serializer*.
        self.serializers = serializers or []

    def _get_inherited(self, holder, t):
        if not isinstance(t, type):
            return None
        return next(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), holder)), None)

    def get_identifier(self, t: type) -&gt; Optional[Callable[[Any], Any]]:
        &#34;&#34;&#34;
        Returns the most appropriate identifier for a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Identifier if exists.
        &#34;&#34;&#34;
        return self._get_inherited(self.identifiers, t)

    def get_entity_filter(self, t: type) -&gt; Optional[Callable[[Any], bool]]:
        &#34;&#34;&#34;
        Returns the most appropriate entity filter for a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Entity filter if exists.
        &#34;&#34;&#34;
        return self._get_inherited(self.entity_filters, t)

    def find_serializers(self, t: type) -&gt; List[Serializer]:
        &#34;&#34;&#34;
        Returns a list of serializers applicable to a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Serializers found.
        &#34;&#34;&#34;
        if not isinstance(t, type):
            return []
        return list(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), self.serializers[::-1])))

    def add_identifier(self, c: type, f: Callable[[Any], Any]) -&gt; &#39;GraphSpec&#39;:
        &#34;&#34;&#34;
        Register an identifier with a type.

        Args:
            c: A type bound to the identifier.
            f: An identifier function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self.identifiers[0:0] = [(c, f)]
        return self

    def add_entity_filter(self, c: type, f: Callable[[Any], bool]) -&gt; &#39;GraphSpec&#39;:
        &#34;&#34;&#34;
        Register an entity filter with a type.

        Args:
            c: A type bound to the identifier.
            f: An entity filter function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self.entity_filters[0:0] = [(c, f)]
        return self

    def add_serializer(self, c: type, f: Serializer) -&gt; &#39;GraphSpec&#39;:
        &#34;&#34;&#34;
        Register a serializer with a type.

        Args:
            c: A type bound to the identifier.
            f: A serializer function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        if isinstance(f, NodeSerializer):
            f = f.serializer
        self.serializers[0:0] = [(c, f)]
        return self

    def _make_policy(self, t, f):
        f = f or self.get_identifier(t)

        if isinstance(f, IdentifyPolicy):
            return f
        elif callable(f):
            return HierarchicalPolicy(f)
        else:
            return neverPolicy()

    def _get_property_definition(self, d):
        if d is None or isinstance(d, tuple):
            d = iter(d or ())
            kind = next(d, None)
            ident = self._make_policy(kind, next(d, None))
            ef = next(d, self.get_entity_filter(kind))
            return kind, ident, ef
        elif isinstance(d, type):
            return d, self._make_policy(d, None), self.get_entity_filter(d)
        elif isinstance(d, GraphTemplate):
            return d, neverPolicy(), None
        else:
            raise ValueError(f&#34;Invalid value was found in keyword arguments of new_template().&#34;)

    def new_template(self, *bases: GraphTemplate, **properties: TemplateProperty) -&gt; GraphTemplate:
        &#34;&#34;&#34;
        Creates a graph template with given definitions for template properties.

        Each keyword argument corresponds to a template property where the key is proprety name and value is property definition.

        Property definition can be a `type` object or a tuple of at most 3 values.
        The former is the equivalent to a tuple which contains the `type` object alone.
        Values in the tuple are interpreted into following attributes in order.

        - The kind of property which indicates a type of entity.
        - *Identifier* of the property.
        - *Entity filter* of the property. 

        Omitted values are complented with registered items in this object.

        &gt;&gt;&gt; template = GraphSpac().new_template(
        &gt;&gt;&gt;     a = int,
        &gt;&gt;&gt;     b = (str, lambda x:x),
        &gt;&gt;&gt;     c = (str, lambda x:x, lambda x:len(x)&gt;5),
        &gt;&gt;&gt; )

        Args:
            bases: Base templates whose properties and relations are merged into new template.
            properties: Definitions of template properties.
        Returns:
            Created graph template.
        &#34;&#34;&#34;
        base = sum(bases, GraphTemplate([]))

        return base + GraphTemplate([(n, *self._get_property_definition(d)) for n, d in properties.items()])

    def to_dict(self, graph: &#39;GraphView&#39;, _params_: Dict[str, Dict[str, Any]] = {}, **settings: NodeSerializer) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;
        Generates a dictionary representing structured entity values of a graph.

        Only nodes whose names appear in keys of `settings` are serialized into the result.
        Each `NodeSerializer` object can be built by factory methods on `S`.

        &gt;&gt;&gt; GraphSpec().to_dict(
        &gt;&gt;&gt;     graph,
        &gt;&gt;&gt;     a = S.of(),
        &gt;&gt;&gt;     b = S.name(&#34;B&#34;),
        &gt;&gt;&gt; )

        Args:
            graph: A view of the graph.
            _params_: Parameters passed to `SerializationContext` and used by *serializer*s.
            settings: `NodeSerializer` for each property.
        Returns:
            Serialization result.
        &#34;&#34;&#34;
        return SerializationContext(settings, self.find_serializers, _params_).execute(graph)

    def to_schema(self, template: GraphTemplate, **settings: NodeSerializer) -&gt; GraphSchema:
        &#34;&#34;&#34;
        Creates `GraphSchema` representing the structure of serialization result under given settings.

        Args:
            template: Template of a graph.
            settings: `NodeSerializer` for each property.
        Returns:
            Schema of serialization result.
        &#34;&#34;&#34;
        return GraphSchema(self, template, **settings)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyracmon.graph.spec.GraphSpec"><code class="flex name class">
<span>class <span class="ident">GraphSpec</span></span>
<span>(</span><span>identifiers: List[Tuple[type, Callable[[Any], Any]]] = None, entity_filters: List[Tuple[type, Callable[[Any], bool]]] = None, serializers: List[Tuple[type, Callable[[ForwardRef('NodeContext')], Any]]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class contains the specifications of graph which control various behaviors in the lifecycles of graphs.</p>
<p>Each instance contains 3 kind of functions; <em>identifier</em>, <em>entity filter</em> and <em>serializer</em>.</p>
<p><em>Identifier</em> is a function to get a value used for the identification of graph entity. See <code>Graph</code> to know how this works.</p>
<p><em>Entity fliter</em> is a function to determine whether the entity should be appended to a graph or not.
If <code>False</code> is returned for an entity, it is just ignored.</p>
<p><em>Serializer</em> is a function which converts an entity value into a serializable object,
whose signature is one of signatures described in <code>S.each</code>.
In serialization phase, registered <em>serializer</em> s are first applied and <em>serializer</em> in <code>NodeSerializer</code> follows.</p>
<p>Any kind of function is bound to a type when added, which will work as a key to determine whether it should be applied to a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphSpec:
    &#34;&#34;&#34;
    This class contains the specifications of graph which control various behaviors in the lifecycles of graphs.

    Each instance contains 3 kind of functions; *identifier*, *entity filter* and *serializer*.

    *Identifier* is a function to get a value used for the identification of graph entity. See `Graph` to know how this works.

    *Entity fliter* is a function to determine whether the entity should be appended to a graph or not.
    If `False` is returned for an entity, it is just ignored.

    *Serializer* is a function which converts an entity value into a serializable object,
    whose signature is one of signatures described in `S.each`.
    In serialization phase, registered *serializer* s are first applied and *serializer* in `NodeSerializer` follows.

    Any kind of function is bound to a type when added, which will work as a key to determine whether it should be applied to a node.
    &#34;&#34;&#34;
    def __init__(
        self,
        identifiers: List[Tuple[type, Callable[[Any], Any]]] = None,
        entity_filters: List[Tuple[type, Callable[[Any], bool]]] = None,
        serializers: List[Tuple[type, Serializer]] = None,
    ):
        #: A list of pairs of type and *identifier*.
        self.identifiers = identifiers or []
        #: A list of pairs of type and *entity_filter*.
        self.entity_filters = entity_filters or []
        #: A list of pairs of type and *serializer*.
        self.serializers = serializers or []

    def _get_inherited(self, holder, t):
        if not isinstance(t, type):
            return None
        return next(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), holder)), None)

    def get_identifier(self, t: type) -&gt; Optional[Callable[[Any], Any]]:
        &#34;&#34;&#34;
        Returns the most appropriate identifier for a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Identifier if exists.
        &#34;&#34;&#34;
        return self._get_inherited(self.identifiers, t)

    def get_entity_filter(self, t: type) -&gt; Optional[Callable[[Any], bool]]:
        &#34;&#34;&#34;
        Returns the most appropriate entity filter for a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Entity filter if exists.
        &#34;&#34;&#34;
        return self._get_inherited(self.entity_filters, t)

    def find_serializers(self, t: type) -&gt; List[Serializer]:
        &#34;&#34;&#34;
        Returns a list of serializers applicable to a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Serializers found.
        &#34;&#34;&#34;
        if not isinstance(t, type):
            return []
        return list(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), self.serializers[::-1])))

    def add_identifier(self, c: type, f: Callable[[Any], Any]) -&gt; &#39;GraphSpec&#39;:
        &#34;&#34;&#34;
        Register an identifier with a type.

        Args:
            c: A type bound to the identifier.
            f: An identifier function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self.identifiers[0:0] = [(c, f)]
        return self

    def add_entity_filter(self, c: type, f: Callable[[Any], bool]) -&gt; &#39;GraphSpec&#39;:
        &#34;&#34;&#34;
        Register an entity filter with a type.

        Args:
            c: A type bound to the identifier.
            f: An entity filter function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self.entity_filters[0:0] = [(c, f)]
        return self

    def add_serializer(self, c: type, f: Serializer) -&gt; &#39;GraphSpec&#39;:
        &#34;&#34;&#34;
        Register a serializer with a type.

        Args:
            c: A type bound to the identifier.
            f: A serializer function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        if isinstance(f, NodeSerializer):
            f = f.serializer
        self.serializers[0:0] = [(c, f)]
        return self

    def _make_policy(self, t, f):
        f = f or self.get_identifier(t)

        if isinstance(f, IdentifyPolicy):
            return f
        elif callable(f):
            return HierarchicalPolicy(f)
        else:
            return neverPolicy()

    def _get_property_definition(self, d):
        if d is None or isinstance(d, tuple):
            d = iter(d or ())
            kind = next(d, None)
            ident = self._make_policy(kind, next(d, None))
            ef = next(d, self.get_entity_filter(kind))
            return kind, ident, ef
        elif isinstance(d, type):
            return d, self._make_policy(d, None), self.get_entity_filter(d)
        elif isinstance(d, GraphTemplate):
            return d, neverPolicy(), None
        else:
            raise ValueError(f&#34;Invalid value was found in keyword arguments of new_template().&#34;)

    def new_template(self, *bases: GraphTemplate, **properties: TemplateProperty) -&gt; GraphTemplate:
        &#34;&#34;&#34;
        Creates a graph template with given definitions for template properties.

        Each keyword argument corresponds to a template property where the key is proprety name and value is property definition.

        Property definition can be a `type` object or a tuple of at most 3 values.
        The former is the equivalent to a tuple which contains the `type` object alone.
        Values in the tuple are interpreted into following attributes in order.

        - The kind of property which indicates a type of entity.
        - *Identifier* of the property.
        - *Entity filter* of the property. 

        Omitted values are complented with registered items in this object.

        &gt;&gt;&gt; template = GraphSpac().new_template(
        &gt;&gt;&gt;     a = int,
        &gt;&gt;&gt;     b = (str, lambda x:x),
        &gt;&gt;&gt;     c = (str, lambda x:x, lambda x:len(x)&gt;5),
        &gt;&gt;&gt; )

        Args:
            bases: Base templates whose properties and relations are merged into new template.
            properties: Definitions of template properties.
        Returns:
            Created graph template.
        &#34;&#34;&#34;
        base = sum(bases, GraphTemplate([]))

        return base + GraphTemplate([(n, *self._get_property_definition(d)) for n, d in properties.items()])

    def to_dict(self, graph: &#39;GraphView&#39;, _params_: Dict[str, Dict[str, Any]] = {}, **settings: NodeSerializer) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;
        Generates a dictionary representing structured entity values of a graph.

        Only nodes whose names appear in keys of `settings` are serialized into the result.
        Each `NodeSerializer` object can be built by factory methods on `S`.

        &gt;&gt;&gt; GraphSpec().to_dict(
        &gt;&gt;&gt;     graph,
        &gt;&gt;&gt;     a = S.of(),
        &gt;&gt;&gt;     b = S.name(&#34;B&#34;),
        &gt;&gt;&gt; )

        Args:
            graph: A view of the graph.
            _params_: Parameters passed to `SerializationContext` and used by *serializer*s.
            settings: `NodeSerializer` for each property.
        Returns:
            Serialization result.
        &#34;&#34;&#34;
        return SerializationContext(settings, self.find_serializers, _params_).execute(graph)

    def to_schema(self, template: GraphTemplate, **settings: NodeSerializer) -&gt; GraphSchema:
        &#34;&#34;&#34;
        Creates `GraphSchema` representing the structure of serialization result under given settings.

        Args:
            template: Template of a graph.
            settings: `NodeSerializer` for each property.
        Returns:
            Schema of serialization result.
        &#34;&#34;&#34;
        return GraphSchema(self, template, **settings)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.model_graph.ConfigurableSpec" href="../model_graph.html#pyracmon.model_graph.ConfigurableSpec">ConfigurableSpec</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.graph.spec.GraphSpec.entity_filters"><code class="name">var <span class="ident">entity_filters</span></code></dt>
<dd>
<div class="desc"><p>A list of pairs of type and <em>entity_filter</em>.</p></div>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.identifiers"><code class="name">var <span class="ident">identifiers</span></code></dt>
<dd>
<div class="desc"><p>A list of pairs of type and <em>identifier</em>.</p></div>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.serializers"><code class="name">var <span class="ident">serializers</span></code></dt>
<dd>
<div class="desc"><p>A list of pairs of type and <em>serializer</em>.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.spec.GraphSpec.add_entity_filter"><code class="name flex">
<span>def <span class="ident">add_entity_filter</span></span>(<span>self, c: type, f: Callable[[Any], bool]) ‑> <a title="pyracmon.graph.spec.GraphSpec" href="#pyracmon.graph.spec.GraphSpec">GraphSpec</a></span>
</code></dt>
<dd>
<div class="desc"><p>Register an entity filter with a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd>A type bound to the identifier.</dd>
<dt><strong><code>f</code></strong></dt>
<dd>An entity filter function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_entity_filter(self, c: type, f: Callable[[Any], bool]) -&gt; &#39;GraphSpec&#39;:
    &#34;&#34;&#34;
    Register an entity filter with a type.

    Args:
        c: A type bound to the identifier.
        f: An entity filter function.
    Returns:
        This instance.
    &#34;&#34;&#34;
    self.entity_filters[0:0] = [(c, f)]
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.add_identifier"><code class="name flex">
<span>def <span class="ident">add_identifier</span></span>(<span>self, c: type, f: Callable[[Any], Any]) ‑> <a title="pyracmon.graph.spec.GraphSpec" href="#pyracmon.graph.spec.GraphSpec">GraphSpec</a></span>
</code></dt>
<dd>
<div class="desc"><p>Register an identifier with a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd>A type bound to the identifier.</dd>
<dt><strong><code>f</code></strong></dt>
<dd>An identifier function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_identifier(self, c: type, f: Callable[[Any], Any]) -&gt; &#39;GraphSpec&#39;:
    &#34;&#34;&#34;
    Register an identifier with a type.

    Args:
        c: A type bound to the identifier.
        f: An identifier function.
    Returns:
        This instance.
    &#34;&#34;&#34;
    self.identifiers[0:0] = [(c, f)]
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.add_serializer"><code class="name flex">
<span>def <span class="ident">add_serializer</span></span>(<span>self, c: type, f: Callable[[ForwardRef('NodeContext')], Any]) ‑> <a title="pyracmon.graph.spec.GraphSpec" href="#pyracmon.graph.spec.GraphSpec">GraphSpec</a></span>
</code></dt>
<dd>
<div class="desc"><p>Register a serializer with a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd>A type bound to the identifier.</dd>
<dt><strong><code>f</code></strong></dt>
<dd>A serializer function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_serializer(self, c: type, f: Serializer) -&gt; &#39;GraphSpec&#39;:
    &#34;&#34;&#34;
    Register a serializer with a type.

    Args:
        c: A type bound to the identifier.
        f: A serializer function.
    Returns:
        This instance.
    &#34;&#34;&#34;
    if isinstance(f, NodeSerializer):
        f = f.serializer
    self.serializers[0:0] = [(c, f)]
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.find_serializers"><code class="name flex">
<span>def <span class="ident">find_serializers</span></span>(<span>self, t: type) ‑> List[Callable[[<a title="pyracmon.graph.serialize.NodeContext" href="serialize.html#pyracmon.graph.serialize.NodeContext">NodeContext</a>], Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of serializers applicable to a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Type of an entity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Serializers found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_serializers(self, t: type) -&gt; List[Serializer]:
    &#34;&#34;&#34;
    Returns a list of serializers applicable to a type.
    
    Args:
        t: Type of an entity.
    Returns:
        Serializers found.
    &#34;&#34;&#34;
    if not isinstance(t, type):
        return []
    return list(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), self.serializers[::-1])))</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.get_entity_filter"><code class="name flex">
<span>def <span class="ident">get_entity_filter</span></span>(<span>self, t: type) ‑> Optional[Callable[[Any], bool]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the most appropriate entity filter for a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Type of an entity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Entity filter if exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_entity_filter(self, t: type) -&gt; Optional[Callable[[Any], bool]]:
    &#34;&#34;&#34;
    Returns the most appropriate entity filter for a type.
    
    Args:
        t: Type of an entity.
    Returns:
        Entity filter if exists.
    &#34;&#34;&#34;
    return self._get_inherited(self.entity_filters, t)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.get_identifier"><code class="name flex">
<span>def <span class="ident">get_identifier</span></span>(<span>self, t: type) ‑> Optional[Callable[[Any], Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the most appropriate identifier for a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Type of an entity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Identifier if exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_identifier(self, t: type) -&gt; Optional[Callable[[Any], Any]]:
    &#34;&#34;&#34;
    Returns the most appropriate identifier for a type.
    
    Args:
        t: Type of an entity.
    Returns:
        Identifier if exists.
    &#34;&#34;&#34;
    return self._get_inherited(self.identifiers, t)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.new_template"><code class="name flex">
<span>def <span class="ident">new_template</span></span>(<span>self, *bases: <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, **properties: Union[type, Tuple[type, Callable[[Any], Any]], Tuple[type, Callable[[Any], Any], Callable[[Any], bool]]]) ‑> <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a graph template with given definitions for template properties.</p>
<p>Each keyword argument corresponds to a template property where the key is proprety name and value is property definition.</p>
<p>Property definition can be a <code>type</code> object or a tuple of at most 3 values.
The former is the equivalent to a tuple which contains the <code>type</code> object alone.
Values in the tuple are interpreted into following attributes in order.</p>
<ul>
<li>The kind of property which indicates a type of entity.</li>
<li><em>Identifier</em> of the property.</li>
<li><em>Entity filter</em> of the property. </li>
</ul>
<p>Omitted values are complented with registered items in this object.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; template = GraphSpac().new_template(
&gt;&gt;&gt;     a = int,
&gt;&gt;&gt;     b = (str, lambda x:x),
&gt;&gt;&gt;     c = (str, lambda x:x, lambda x:len(x)&gt;5),
&gt;&gt;&gt; )
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bases</code></strong></dt>
<dd>Base templates whose properties and relations are merged into new template.</dd>
<dt><strong><code>properties</code></strong></dt>
<dd>Definitions of template properties.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Created graph template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_template(self, *bases: GraphTemplate, **properties: TemplateProperty) -&gt; GraphTemplate:
    &#34;&#34;&#34;
    Creates a graph template with given definitions for template properties.

    Each keyword argument corresponds to a template property where the key is proprety name and value is property definition.

    Property definition can be a `type` object or a tuple of at most 3 values.
    The former is the equivalent to a tuple which contains the `type` object alone.
    Values in the tuple are interpreted into following attributes in order.

    - The kind of property which indicates a type of entity.
    - *Identifier* of the property.
    - *Entity filter* of the property. 

    Omitted values are complented with registered items in this object.

    &gt;&gt;&gt; template = GraphSpac().new_template(
    &gt;&gt;&gt;     a = int,
    &gt;&gt;&gt;     b = (str, lambda x:x),
    &gt;&gt;&gt;     c = (str, lambda x:x, lambda x:len(x)&gt;5),
    &gt;&gt;&gt; )

    Args:
        bases: Base templates whose properties and relations are merged into new template.
        properties: Definitions of template properties.
    Returns:
        Created graph template.
    &#34;&#34;&#34;
    base = sum(bases, GraphTemplate([]))

    return base + GraphTemplate([(n, *self._get_property_definition(d)) for n, d in properties.items()])</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, graph: GraphView, **settings: <a title="pyracmon.graph.serialize.NodeSerializer" href="serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a dictionary representing structured entity values of a graph.</p>
<p>Only nodes whose names appear in keys of <code>settings</code> are serialized into the result.
Each <code>NodeSerializer</code> object can be built by factory methods on <code>S</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; GraphSpec().to_dict(
&gt;&gt;&gt;     graph,
&gt;&gt;&gt;     a = S.of(),
&gt;&gt;&gt;     b = S.name(&quot;B&quot;),
&gt;&gt;&gt; )
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>A view of the graph.</dd>
<dt><strong><code>_params_</code></strong></dt>
<dd>Parameters passed to <code>SerializationContext</code> and used by <em>serializer</em>s.</dd>
<dt><strong><code>settings</code></strong></dt>
<dd><code>NodeSerializer</code> for each property.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Serialization result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, graph: &#39;GraphView&#39;, _params_: Dict[str, Dict[str, Any]] = {}, **settings: NodeSerializer) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Generates a dictionary representing structured entity values of a graph.

    Only nodes whose names appear in keys of `settings` are serialized into the result.
    Each `NodeSerializer` object can be built by factory methods on `S`.

    &gt;&gt;&gt; GraphSpec().to_dict(
    &gt;&gt;&gt;     graph,
    &gt;&gt;&gt;     a = S.of(),
    &gt;&gt;&gt;     b = S.name(&#34;B&#34;),
    &gt;&gt;&gt; )

    Args:
        graph: A view of the graph.
        _params_: Parameters passed to `SerializationContext` and used by *serializer*s.
        settings: `NodeSerializer` for each property.
    Returns:
        Serialization result.
    &#34;&#34;&#34;
    return SerializationContext(settings, self.find_serializers, _params_).execute(graph)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.to_schema"><code class="name flex">
<span>def <span class="ident">to_schema</span></span>(<span>self, template: <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, **settings: <a title="pyracmon.graph.serialize.NodeSerializer" href="serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>) ‑> <a title="pyracmon.graph.schema.GraphSchema" href="schema.html#pyracmon.graph.schema.GraphSchema">GraphSchema</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates <code>GraphSchema</code> representing the structure of serialization result under given settings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template</code></strong></dt>
<dd>Template of a graph.</dd>
<dt><strong><code>settings</code></strong></dt>
<dd><code>NodeSerializer</code> for each property.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Schema of serialization result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_schema(self, template: GraphTemplate, **settings: NodeSerializer) -&gt; GraphSchema:
    &#34;&#34;&#34;
    Creates `GraphSchema` representing the structure of serialization result under given settings.

    Args:
        template: Template of a graph.
        settings: `NodeSerializer` for each property.
    Returns:
        Schema of serialization result.
    &#34;&#34;&#34;
    return GraphSchema(self, template, **settings)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyracmon.graph" href="index.html">pyracmon.graph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyracmon.graph.spec.GraphSpec" href="#pyracmon.graph.spec.GraphSpec">GraphSpec</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.graph.spec.GraphSpec.add_entity_filter" href="#pyracmon.graph.spec.GraphSpec.add_entity_filter">add_entity_filter</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.add_identifier" href="#pyracmon.graph.spec.GraphSpec.add_identifier">add_identifier</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.add_serializer" href="#pyracmon.graph.spec.GraphSpec.add_serializer">add_serializer</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.entity_filters" href="#pyracmon.graph.spec.GraphSpec.entity_filters">entity_filters</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.find_serializers" href="#pyracmon.graph.spec.GraphSpec.find_serializers">find_serializers</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.get_entity_filter" href="#pyracmon.graph.spec.GraphSpec.get_entity_filter">get_entity_filter</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.get_identifier" href="#pyracmon.graph.spec.GraphSpec.get_identifier">get_identifier</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.identifiers" href="#pyracmon.graph.spec.GraphSpec.identifiers">identifiers</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.new_template" href="#pyracmon.graph.spec.GraphSpec.new_template">new_template</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.serializers" href="#pyracmon.graph.spec.GraphSpec.serializers">serializers</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.to_dict" href="#pyracmon.graph.spec.GraphSpec.to_dict">to_dict</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.to_schema" href="#pyracmon.graph.spec.GraphSpec.to_schema">to_schema</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>