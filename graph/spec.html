<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyracmon.graph.spec API documentation</title>
<meta name="description" content="This module provides a type which contains objects to control how graphs work." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyracmon.graph.spec</code></h1>
</header>
<section id="section-intro">
<p>This module provides a type which contains objects to control how graphs work.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides a type which contains objects to control how graphs work.
&#34;&#34;&#34;
from typing import Callable, Any, Optional, TypeVar, Union
from typing_extensions import Self
from .identify import IdentifyPolicy, HierarchicalPolicy, neverPolicy
from .template import GraphTemplate
from .serialize import Serializer, SerializationContext, NodeSerializer
from .schema import GraphSchema
from .typing import issubtype
from .graph import GraphView


T = TypeVar(&#39;T&#39;)


TypeDef = Union[type, GraphTemplate, GraphTemplate.Property]
Identifier = Callable[[Any], Any]
EntityFilter = Callable[[Any], bool]
TemplateProperty = Union[
    type,
    tuple[()],
    tuple[type],
    tuple[type, Optional[Identifier]],
    tuple[type, Optional[Identifier], Optional[EntityFilter]],
]


class GraphSpec:
    &#34;&#34;&#34;
    This class contains the specifications of graph which control various behaviors in the lifecycles of graphs.

    3 kinds of functions are the core of graph behaviors: *identifier*, *entity filter* and *serializer* .

    *Identifier* and *entity filter* are used when appending values into graph.
    *Identifier* is a function to get a value used for the identification of graph entity. See `Graph` to know how this works.
    *Entity fliter* is a function to determine whether the entity should be appended to a graph or not.
    If `False` is returned for an entity, it is just ignored.

    See `pyracmon.graph.serialize` to know the detail of *serializer*.

    Each of them is bound to a `type` on registration to this and it affects nodes whose property type conforms to the `type` .
    &#34;&#34;&#34;
    def __init__(
        self,
        identifiers: Optional[list[tuple[type, Identifier]]] = None,
        entity_filters: Optional[list[tuple[type, EntityFilter]]] = None,
        serializers: Optional[list[tuple[type, Serializer]]] = None,
    ):
        #: A list of pairs of type and *identifier*.
        self.identifiers: list[tuple[type, Identifier]] = identifiers or []
        #: A list of pairs of type and *entity_filter*.
        self.entity_filters: list[tuple[type, EntityFilter]] = entity_filters or []
        #: A list of pairs of type and *serializer*.
        self.serializers: list[tuple[type, Serializer]] = serializers or []

    def _get_inherited(self, holder: list[tuple[type, T]], t: type) -&gt; Optional[T]:
        if not isinstance(t, type):
            return None
        return next(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), holder)), None)

    def get_identifier(self, t: type) -&gt; Optional[Callable[[Any], Any]]:
        &#34;&#34;&#34;
        Returns the most appropriate identifier for a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Identifier if exists.
        &#34;&#34;&#34;
        return self._get_inherited(self.identifiers, t)

    def get_entity_filter(self, t: type) -&gt; Optional[Callable[[Any], bool]]:
        &#34;&#34;&#34;
        Returns the most appropriate entity filter for a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Entity filter if exists.
        &#34;&#34;&#34;
        return self._get_inherited(self.entity_filters, t)

    def find_serializers(self, t: type) -&gt; list[Serializer]:
        &#34;&#34;&#34;
        Returns a list of serializers applicable to a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Serializers found.
        &#34;&#34;&#34;
        if not isinstance(t, type):
            return []
        return list(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), self.serializers[::-1])))

    def add_identifier(self, c: type, f: Callable[[Any], Any]) -&gt; Self:
        &#34;&#34;&#34;
        Register an identifier with a type.

        Args:
            c: A type bound to the identifier.
            f: An identifier function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self.identifiers[0:0] = [(c, f)]
        return self

    def add_entity_filter(self, c: type, f: Callable[[Any], bool]) -&gt; Self:
        &#34;&#34;&#34;
        Register an entity filter with a type.

        Args:
            c: A type bound to the identifier.
            f: An entity filter function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self.entity_filters[0:0] = [(c, f)]
        return self

    def add_serializer(self, c: type, f: Union[Serializer, NodeSerializer]) -&gt; Self:
        &#34;&#34;&#34;
        Register a serializer with a type.

        Args:
            c: A type bound to the identifier.
            f: A serializer function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        if isinstance(f, NodeSerializer):
            f = f.serializer
        self.serializers[0:0] = [(c, f)]
        return self

    def _make_policy(self, t: type, f: Union[IdentifyPolicy, Callable[[Any], Any], None]) -&gt; IdentifyPolicy:
        f = f or self.get_identifier(t)

        if isinstance(f, IdentifyPolicy):
            return f
        elif callable(f):
            return HierarchicalPolicy(f)
        else:
            return neverPolicy()

    def _get_property_definition(self, definition: Union[
        TemplateProperty,
        type,
        GraphTemplate,
    ]) -&gt; tuple[TypeDef, IdentifyPolicy, Optional[EntityFilter]]:
        if isinstance(definition, GraphTemplate):
            return definition, neverPolicy(), None
        elif isinstance(definition, type):
            return definition, self._make_policy(definition, None), self.get_entity_filter(definition)
        elif isinstance(definition, tuple):
            # python &lt; 3.10
            if len(definition) == 3:
                kind, identifier, entity_filter = definition
            elif len(definition) == 2:
                kind, identifier, entity_filter = definition + (None,)
            elif len(definition) == 1:
                kind, identifier, entity_filter = definition + (None, None)
            elif len(definition) == 0:
                kind, identifier, entity_filter = (object, None, None)
            else:
                raise ValueError(f&#34;Invalid value was found in keyword arguments of new_template().&#34;)
            # python &gt;= 3.10
            #match definition:
            #    case (k, ident, ef):
            #        kind = k; identifier = ident; entity_filter = ef
            #    case (k, ident):
            #        kind = k; identifier = ident; entity_filter = None
            #    case (k,):
            #        kind = k; identifier = None; entity_filter = None
            #    case ():
            #        kind = object; identifier = None; entity_filter = None
            #    case _:
            #        raise ValueError(f&#34;Invalid value was found in keyword arguments of new_template().&#34;)
            return kind, self._make_policy(kind, identifier), entity_filter or self.get_entity_filter(kind)
        else:
            raise ValueError(f&#34;Invalid value was found in keyword arguments of new_template().&#34;)

    def new_template(self, *bases: GraphTemplate, **properties: Union[TemplateProperty, type, GraphTemplate]) -&gt; GraphTemplate:
        &#34;&#34;&#34;
        Creates a graph template with definitions of template properties.

        Each keyword argument corresponds to a template property where the key is proprety name and value is property definition.

        Property definition can be a `type` object or a tuple of at most 3 values.
        The former is the equivalent to a tuple which contains the `type` object alone.
        Values in the tuple are interpreted into following attributes in order.

        - The kind of property which indicates a type of entity.
        - *Identifier* of the property.
        - *Entity filter* of the property. 

        Omitted values are completed with registered items in this object.

        ```python
        template = GraphSpac().new_template(
            a = int,
            b = (str, lambda x:x),
            c = (str, lambda x:x, lambda x:len(x)&gt;5),
        )
        ```

        Args:
            bases: Base templates whose properties and relations are merged into new template.
            properties: Definitions of template properties.
        Returns:
            Created graph template.
        &#34;&#34;&#34;
        base = sum(bases, GraphTemplate([]))

        return base + GraphTemplate([(n, *self._get_property_definition(d)) for n, d in properties.items()])

    def to_dict(self, graph: GraphView, _params_: dict[str, dict[str, Any]] = {}, **settings: NodeSerializer) -&gt; dict[str, Any]:
        &#34;&#34;&#34;
        Serialize a graph into a `dict` .

        Only nodes whose names appear in keys of `settings` are serialized into the result.
        Each `NodeSerializer` object can be built by factory methods on `pyracmon.graph.serialize.S`.

        ```python
        GraphSpec().to_dict(
            graph,
            a = S.of(),
            b = S.name(&#34;B&#34;),
        )
        ```

        Args:
            graph: A view of the graph.
            _params_: Parameters passed to `SerializationContext` and used by *serializer*s.
            settings: `NodeSerializer` for each property.
        Returns:
            Serialization result.
        &#34;&#34;&#34;
        return SerializationContext(settings, self.find_serializers, _params_).execute(graph)

    def to_schema(self, template: GraphTemplate, **settings: NodeSerializer) -&gt; GraphSchema:
        &#34;&#34;&#34;
        Creates `GraphSchema` representing the structure of serialization result under given settings.

        Args:
            template: Template of a graph.
            settings: `NodeSerializer` for each property.
        Returns:
            Schema of serialization result.
        &#34;&#34;&#34;
        return GraphSchema(self, template, **settings)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyracmon.graph.spec.GraphSpec"><code class="flex name class">
<span>class <span class="ident">GraphSpec</span></span>
<span>(</span><span>identifiers: Optional[list[tuple[type, typing.Callable[[typing.Any], typing.Any]]]] = None, entity_filters: Optional[list[tuple[type, typing.Callable[[typing.Any], bool]]]] = None, serializers: Optional[list[tuple[type, typing.Callable[[ForwardRef('NodeContext')], typing.Any]]]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class contains the specifications of graph which control various behaviors in the lifecycles of graphs.</p>
<p>3 kinds of functions are the core of graph behaviors: <em>identifier</em>, <em>entity filter</em> and <em>serializer</em> .</p>
<p><em>Identifier</em> and <em>entity filter</em> are used when appending values into graph.
<em>Identifier</em> is a function to get a value used for the identification of graph entity. See <code>Graph</code> to know how this works.
<em>Entity fliter</em> is a function to determine whether the entity should be appended to a graph or not.
If <code>False</code> is returned for an entity, it is just ignored.</p>
<p>See <code><a title="pyracmon.graph.serialize" href="serialize.html">pyracmon.graph.serialize</a></code> to know the detail of <em>serializer</em>.</p>
<p>Each of them is bound to a <code>type</code> on registration to this and it affects nodes whose property type conforms to the <code>type</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphSpec:
    &#34;&#34;&#34;
    This class contains the specifications of graph which control various behaviors in the lifecycles of graphs.

    3 kinds of functions are the core of graph behaviors: *identifier*, *entity filter* and *serializer* .

    *Identifier* and *entity filter* are used when appending values into graph.
    *Identifier* is a function to get a value used for the identification of graph entity. See `Graph` to know how this works.
    *Entity fliter* is a function to determine whether the entity should be appended to a graph or not.
    If `False` is returned for an entity, it is just ignored.

    See `pyracmon.graph.serialize` to know the detail of *serializer*.

    Each of them is bound to a `type` on registration to this and it affects nodes whose property type conforms to the `type` .
    &#34;&#34;&#34;
    def __init__(
        self,
        identifiers: Optional[list[tuple[type, Identifier]]] = None,
        entity_filters: Optional[list[tuple[type, EntityFilter]]] = None,
        serializers: Optional[list[tuple[type, Serializer]]] = None,
    ):
        #: A list of pairs of type and *identifier*.
        self.identifiers: list[tuple[type, Identifier]] = identifiers or []
        #: A list of pairs of type and *entity_filter*.
        self.entity_filters: list[tuple[type, EntityFilter]] = entity_filters or []
        #: A list of pairs of type and *serializer*.
        self.serializers: list[tuple[type, Serializer]] = serializers or []

    def _get_inherited(self, holder: list[tuple[type, T]], t: type) -&gt; Optional[T]:
        if not isinstance(t, type):
            return None
        return next(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), holder)), None)

    def get_identifier(self, t: type) -&gt; Optional[Callable[[Any], Any]]:
        &#34;&#34;&#34;
        Returns the most appropriate identifier for a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Identifier if exists.
        &#34;&#34;&#34;
        return self._get_inherited(self.identifiers, t)

    def get_entity_filter(self, t: type) -&gt; Optional[Callable[[Any], bool]]:
        &#34;&#34;&#34;
        Returns the most appropriate entity filter for a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Entity filter if exists.
        &#34;&#34;&#34;
        return self._get_inherited(self.entity_filters, t)

    def find_serializers(self, t: type) -&gt; list[Serializer]:
        &#34;&#34;&#34;
        Returns a list of serializers applicable to a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Serializers found.
        &#34;&#34;&#34;
        if not isinstance(t, type):
            return []
        return list(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), self.serializers[::-1])))

    def add_identifier(self, c: type, f: Callable[[Any], Any]) -&gt; Self:
        &#34;&#34;&#34;
        Register an identifier with a type.

        Args:
            c: A type bound to the identifier.
            f: An identifier function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self.identifiers[0:0] = [(c, f)]
        return self

    def add_entity_filter(self, c: type, f: Callable[[Any], bool]) -&gt; Self:
        &#34;&#34;&#34;
        Register an entity filter with a type.

        Args:
            c: A type bound to the identifier.
            f: An entity filter function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self.entity_filters[0:0] = [(c, f)]
        return self

    def add_serializer(self, c: type, f: Union[Serializer, NodeSerializer]) -&gt; Self:
        &#34;&#34;&#34;
        Register a serializer with a type.

        Args:
            c: A type bound to the identifier.
            f: A serializer function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        if isinstance(f, NodeSerializer):
            f = f.serializer
        self.serializers[0:0] = [(c, f)]
        return self

    def _make_policy(self, t: type, f: Union[IdentifyPolicy, Callable[[Any], Any], None]) -&gt; IdentifyPolicy:
        f = f or self.get_identifier(t)

        if isinstance(f, IdentifyPolicy):
            return f
        elif callable(f):
            return HierarchicalPolicy(f)
        else:
            return neverPolicy()

    def _get_property_definition(self, definition: Union[
        TemplateProperty,
        type,
        GraphTemplate,
    ]) -&gt; tuple[TypeDef, IdentifyPolicy, Optional[EntityFilter]]:
        if isinstance(definition, GraphTemplate):
            return definition, neverPolicy(), None
        elif isinstance(definition, type):
            return definition, self._make_policy(definition, None), self.get_entity_filter(definition)
        elif isinstance(definition, tuple):
            # python &lt; 3.10
            if len(definition) == 3:
                kind, identifier, entity_filter = definition
            elif len(definition) == 2:
                kind, identifier, entity_filter = definition + (None,)
            elif len(definition) == 1:
                kind, identifier, entity_filter = definition + (None, None)
            elif len(definition) == 0:
                kind, identifier, entity_filter = (object, None, None)
            else:
                raise ValueError(f&#34;Invalid value was found in keyword arguments of new_template().&#34;)
            # python &gt;= 3.10
            #match definition:
            #    case (k, ident, ef):
            #        kind = k; identifier = ident; entity_filter = ef
            #    case (k, ident):
            #        kind = k; identifier = ident; entity_filter = None
            #    case (k,):
            #        kind = k; identifier = None; entity_filter = None
            #    case ():
            #        kind = object; identifier = None; entity_filter = None
            #    case _:
            #        raise ValueError(f&#34;Invalid value was found in keyword arguments of new_template().&#34;)
            return kind, self._make_policy(kind, identifier), entity_filter or self.get_entity_filter(kind)
        else:
            raise ValueError(f&#34;Invalid value was found in keyword arguments of new_template().&#34;)

    def new_template(self, *bases: GraphTemplate, **properties: Union[TemplateProperty, type, GraphTemplate]) -&gt; GraphTemplate:
        &#34;&#34;&#34;
        Creates a graph template with definitions of template properties.

        Each keyword argument corresponds to a template property where the key is proprety name and value is property definition.

        Property definition can be a `type` object or a tuple of at most 3 values.
        The former is the equivalent to a tuple which contains the `type` object alone.
        Values in the tuple are interpreted into following attributes in order.

        - The kind of property which indicates a type of entity.
        - *Identifier* of the property.
        - *Entity filter* of the property. 

        Omitted values are completed with registered items in this object.

        ```python
        template = GraphSpac().new_template(
            a = int,
            b = (str, lambda x:x),
            c = (str, lambda x:x, lambda x:len(x)&gt;5),
        )
        ```

        Args:
            bases: Base templates whose properties and relations are merged into new template.
            properties: Definitions of template properties.
        Returns:
            Created graph template.
        &#34;&#34;&#34;
        base = sum(bases, GraphTemplate([]))

        return base + GraphTemplate([(n, *self._get_property_definition(d)) for n, d in properties.items()])

    def to_dict(self, graph: GraphView, _params_: dict[str, dict[str, Any]] = {}, **settings: NodeSerializer) -&gt; dict[str, Any]:
        &#34;&#34;&#34;
        Serialize a graph into a `dict` .

        Only nodes whose names appear in keys of `settings` are serialized into the result.
        Each `NodeSerializer` object can be built by factory methods on `pyracmon.graph.serialize.S`.

        ```python
        GraphSpec().to_dict(
            graph,
            a = S.of(),
            b = S.name(&#34;B&#34;),
        )
        ```

        Args:
            graph: A view of the graph.
            _params_: Parameters passed to `SerializationContext` and used by *serializer*s.
            settings: `NodeSerializer` for each property.
        Returns:
            Serialization result.
        &#34;&#34;&#34;
        return SerializationContext(settings, self.find_serializers, _params_).execute(graph)

    def to_schema(self, template: GraphTemplate, **settings: NodeSerializer) -&gt; GraphSchema:
        &#34;&#34;&#34;
        Creates `GraphSchema` representing the structure of serialization result under given settings.

        Args:
            template: Template of a graph.
            settings: `NodeSerializer` for each property.
        Returns:
            Schema of serialization result.
        &#34;&#34;&#34;
        return GraphSchema(self, template, **settings)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.model_graph.ConfigurableSpec" href="../model_graph.html#pyracmon.model_graph.ConfigurableSpec">ConfigurableSpec</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.graph.spec.GraphSpec.entity_filters"><code class="name">var <span class="ident">entity_filters</span></code></dt>
<dd>
<div class="desc"><p>A list of pairs of type and <em>entity_filter</em>.</p></div>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.identifiers"><code class="name">var <span class="ident">identifiers</span></code></dt>
<dd>
<div class="desc"><p>A list of pairs of type and <em>identifier</em>.</p></div>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.serializers"><code class="name">var <span class="ident">serializers</span></code></dt>
<dd>
<div class="desc"><p>A list of pairs of type and <em>serializer</em>.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.spec.GraphSpec.add_entity_filter"><code class="name flex">
<span>def <span class="ident">add_entity_filter</span></span>(<span>self, c: type, f: Callable[[Any], bool]) ‑> typing_extensions.Self</span>
</code></dt>
<dd>
<div class="desc"><p>Register an entity filter with a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd>A type bound to the identifier.</dd>
<dt><strong><code>f</code></strong></dt>
<dd>An entity filter function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_entity_filter(self, c: type, f: Callable[[Any], bool]) -&gt; Self:
    &#34;&#34;&#34;
    Register an entity filter with a type.

    Args:
        c: A type bound to the identifier.
        f: An entity filter function.
    Returns:
        This instance.
    &#34;&#34;&#34;
    self.entity_filters[0:0] = [(c, f)]
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.add_identifier"><code class="name flex">
<span>def <span class="ident">add_identifier</span></span>(<span>self, c: type, f: Callable[[Any], Any]) ‑> typing_extensions.Self</span>
</code></dt>
<dd>
<div class="desc"><p>Register an identifier with a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd>A type bound to the identifier.</dd>
<dt><strong><code>f</code></strong></dt>
<dd>An identifier function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_identifier(self, c: type, f: Callable[[Any], Any]) -&gt; Self:
    &#34;&#34;&#34;
    Register an identifier with a type.

    Args:
        c: A type bound to the identifier.
        f: An identifier function.
    Returns:
        This instance.
    &#34;&#34;&#34;
    self.identifiers[0:0] = [(c, f)]
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.add_serializer"><code class="name flex">
<span>def <span class="ident">add_serializer</span></span>(<span>self, c: type, f: Union[Callable[[ForwardRef('NodeContext')], Any], <a title="pyracmon.graph.serialize.NodeSerializer" href="serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>]) ‑> typing_extensions.Self</span>
</code></dt>
<dd>
<div class="desc"><p>Register a serializer with a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd>A type bound to the identifier.</dd>
<dt><strong><code>f</code></strong></dt>
<dd>A serializer function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_serializer(self, c: type, f: Union[Serializer, NodeSerializer]) -&gt; Self:
    &#34;&#34;&#34;
    Register a serializer with a type.

    Args:
        c: A type bound to the identifier.
        f: A serializer function.
    Returns:
        This instance.
    &#34;&#34;&#34;
    if isinstance(f, NodeSerializer):
        f = f.serializer
    self.serializers[0:0] = [(c, f)]
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.find_serializers"><code class="name flex">
<span>def <span class="ident">find_serializers</span></span>(<span>self, t: type) ‑> list[typing.Callable[[<a title="pyracmon.graph.serialize.NodeContext" href="serialize.html#pyracmon.graph.serialize.NodeContext">NodeContext</a>], typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of serializers applicable to a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Type of an entity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Serializers found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_serializers(self, t: type) -&gt; list[Serializer]:
    &#34;&#34;&#34;
    Returns a list of serializers applicable to a type.
    
    Args:
        t: Type of an entity.
    Returns:
        Serializers found.
    &#34;&#34;&#34;
    if not isinstance(t, type):
        return []
    return list(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), self.serializers[::-1])))</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.get_entity_filter"><code class="name flex">
<span>def <span class="ident">get_entity_filter</span></span>(<span>self, t: type) ‑> Optional[Callable[[Any], bool]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the most appropriate entity filter for a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Type of an entity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Entity filter if exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_entity_filter(self, t: type) -&gt; Optional[Callable[[Any], bool]]:
    &#34;&#34;&#34;
    Returns the most appropriate entity filter for a type.
    
    Args:
        t: Type of an entity.
    Returns:
        Entity filter if exists.
    &#34;&#34;&#34;
    return self._get_inherited(self.entity_filters, t)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.get_identifier"><code class="name flex">
<span>def <span class="ident">get_identifier</span></span>(<span>self, t: type) ‑> Optional[Callable[[Any], Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the most appropriate identifier for a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Type of an entity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Identifier if exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_identifier(self, t: type) -&gt; Optional[Callable[[Any], Any]]:
    &#34;&#34;&#34;
    Returns the most appropriate identifier for a type.
    
    Args:
        t: Type of an entity.
    Returns:
        Identifier if exists.
    &#34;&#34;&#34;
    return self._get_inherited(self.identifiers, t)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.new_template"><code class="name flex">
<span>def <span class="ident">new_template</span></span>(<span>self, *bases: <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, **properties: Union[type, tuple[()], tuple[type], tuple[type, Optional[Callable[[Any], Any]]], tuple[type, Optional[Callable[[Any], Any]], Optional[Callable[[Any], bool]]], <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>]) ‑> <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a graph template with definitions of template properties.</p>
<p>Each keyword argument corresponds to a template property where the key is proprety name and value is property definition.</p>
<p>Property definition can be a <code>type</code> object or a tuple of at most 3 values.
The former is the equivalent to a tuple which contains the <code>type</code> object alone.
Values in the tuple are interpreted into following attributes in order.</p>
<ul>
<li>The kind of property which indicates a type of entity.</li>
<li><em>Identifier</em> of the property.</li>
<li><em>Entity filter</em> of the property. </li>
</ul>
<p>Omitted values are completed with registered items in this object.</p>
<pre><code class="language-python">template = GraphSpac().new_template(
    a = int,
    b = (str, lambda x:x),
    c = (str, lambda x:x, lambda x:len(x)&gt;5),
)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bases</code></strong></dt>
<dd>Base templates whose properties and relations are merged into new template.</dd>
<dt><strong><code>properties</code></strong></dt>
<dd>Definitions of template properties.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Created graph template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_template(self, *bases: GraphTemplate, **properties: Union[TemplateProperty, type, GraphTemplate]) -&gt; GraphTemplate:
    &#34;&#34;&#34;
    Creates a graph template with definitions of template properties.

    Each keyword argument corresponds to a template property where the key is proprety name and value is property definition.

    Property definition can be a `type` object or a tuple of at most 3 values.
    The former is the equivalent to a tuple which contains the `type` object alone.
    Values in the tuple are interpreted into following attributes in order.

    - The kind of property which indicates a type of entity.
    - *Identifier* of the property.
    - *Entity filter* of the property. 

    Omitted values are completed with registered items in this object.

    ```python
    template = GraphSpac().new_template(
        a = int,
        b = (str, lambda x:x),
        c = (str, lambda x:x, lambda x:len(x)&gt;5),
    )
    ```

    Args:
        bases: Base templates whose properties and relations are merged into new template.
        properties: Definitions of template properties.
    Returns:
        Created graph template.
    &#34;&#34;&#34;
    base = sum(bases, GraphTemplate([]))

    return base + GraphTemplate([(n, *self._get_property_definition(d)) for n, d in properties.items()])</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, graph: <a title="pyracmon.graph.graph.GraphView" href="graph.html#pyracmon.graph.graph.GraphView">GraphView</a>, **settings: <a title="pyracmon.graph.serialize.NodeSerializer" href="serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize a graph into a <code>dict</code> .</p>
<p>Only nodes whose names appear in keys of <code>settings</code> are serialized into the result.
Each <code>NodeSerializer</code> object can be built by factory methods on <code><a title="pyracmon.graph.serialize.S" href="serialize.html#pyracmon.graph.serialize.S">S</a></code>.</p>
<pre><code class="language-python">GraphSpec().to_dict(
    graph,
    a = S.of(),
    b = S.name(&quot;B&quot;),
)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>A view of the graph.</dd>
<dt><strong><code>_params_</code></strong></dt>
<dd>Parameters passed to <code>SerializationContext</code> and used by <em>serializer</em>s.</dd>
<dt><strong><code>settings</code></strong></dt>
<dd><code>NodeSerializer</code> for each property.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Serialization result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, graph: GraphView, _params_: dict[str, dict[str, Any]] = {}, **settings: NodeSerializer) -&gt; dict[str, Any]:
    &#34;&#34;&#34;
    Serialize a graph into a `dict` .

    Only nodes whose names appear in keys of `settings` are serialized into the result.
    Each `NodeSerializer` object can be built by factory methods on `pyracmon.graph.serialize.S`.

    ```python
    GraphSpec().to_dict(
        graph,
        a = S.of(),
        b = S.name(&#34;B&#34;),
    )
    ```

    Args:
        graph: A view of the graph.
        _params_: Parameters passed to `SerializationContext` and used by *serializer*s.
        settings: `NodeSerializer` for each property.
    Returns:
        Serialization result.
    &#34;&#34;&#34;
    return SerializationContext(settings, self.find_serializers, _params_).execute(graph)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.spec.GraphSpec.to_schema"><code class="name flex">
<span>def <span class="ident">to_schema</span></span>(<span>self, template: <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, **settings: <a title="pyracmon.graph.serialize.NodeSerializer" href="serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>) ‑> <a title="pyracmon.graph.schema.GraphSchema" href="schema.html#pyracmon.graph.schema.GraphSchema">GraphSchema</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates <code>GraphSchema</code> representing the structure of serialization result under given settings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template</code></strong></dt>
<dd>Template of a graph.</dd>
<dt><strong><code>settings</code></strong></dt>
<dd><code>NodeSerializer</code> for each property.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Schema of serialization result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_schema(self, template: GraphTemplate, **settings: NodeSerializer) -&gt; GraphSchema:
    &#34;&#34;&#34;
    Creates `GraphSchema` representing the structure of serialization result under given settings.

    Args:
        template: Template of a graph.
        settings: `NodeSerializer` for each property.
    Returns:
        Schema of serialization result.
    &#34;&#34;&#34;
    return GraphSchema(self, template, **settings)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyracmon.graph" href="index.html">pyracmon.graph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyracmon.graph.spec.GraphSpec" href="#pyracmon.graph.spec.GraphSpec">GraphSpec</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.graph.spec.GraphSpec.add_entity_filter" href="#pyracmon.graph.spec.GraphSpec.add_entity_filter">add_entity_filter</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.add_identifier" href="#pyracmon.graph.spec.GraphSpec.add_identifier">add_identifier</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.add_serializer" href="#pyracmon.graph.spec.GraphSpec.add_serializer">add_serializer</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.entity_filters" href="#pyracmon.graph.spec.GraphSpec.entity_filters">entity_filters</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.find_serializers" href="#pyracmon.graph.spec.GraphSpec.find_serializers">find_serializers</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.get_entity_filter" href="#pyracmon.graph.spec.GraphSpec.get_entity_filter">get_entity_filter</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.get_identifier" href="#pyracmon.graph.spec.GraphSpec.get_identifier">get_identifier</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.identifiers" href="#pyracmon.graph.spec.GraphSpec.identifiers">identifiers</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.new_template" href="#pyracmon.graph.spec.GraphSpec.new_template">new_template</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.serializers" href="#pyracmon.graph.spec.GraphSpec.serializers">serializers</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.to_dict" href="#pyracmon.graph.spec.GraphSpec.to_dict">to_dict</a></code></li>
<li><code><a title="pyracmon.graph.spec.GraphSpec.to_schema" href="#pyracmon.graph.spec.GraphSpec.to_schema">to_schema</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>