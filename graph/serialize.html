<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyracmon.graph.serialize API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyracmon.graph.serialize</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections.abc import Iterator, Iterable
from inspect import signature, Signature, getmembers, isfunction
from typing import Any, Mapping, Optional, Union, Callable, Protocol, TypeVar, cast
try:
    from typing import ParamSpec, TypeAlias
except:
    from typing_extensions import ParamSpec, TypeAlias
from .template import GraphTemplate
from .graph import Node, NodeContainer, GraphView
from .typing import Shrink, Extend, Typeable, issubgeneric, to_rawdict


T = TypeVar(&#39;T&#39;)
P = ParamSpec(&#39;P&#39;)


# type aliases.
Serializer: TypeAlias = Callable[[&#39;NodeContext&#39;], Any]


class NodeSerializing(Protocol):
    def doc(self, document: str, **options: Any) -&gt; &#39;NodeSerializer&#39;: ...
    def name(self, name: str) -&gt; &#39;NodeSerializer&#39;: ...
    def merge(self, namer: Optional[Callable[[str], str]] = None) -&gt; &#39;NodeSerializer&#39;: ...
    def at(self, index: int, alt: Any = None) -&gt; &#39;NodeSerializer&#39;: ...
    def head(self, alt: Any = None) -&gt; &#39;NodeSerializer&#39;: ...
    def last(self, alt: Any = None) -&gt; &#39;NodeSerializer&#39;: ...
    def fold(self, aggregator: Callable[[list[Node]], Any]) -&gt; &#39;NodeSerializer&#39;: ...
    def select(self, aggregator: Callable[[list[Node]], list[Node]]) -&gt; &#39;NodeSerializer&#39;: ...
    def each(self, func: Serializer) -&gt; &#39;NodeSerializer&#39;: ...
    def sub(self, **settings) -&gt; &#39;NodeSerializer&#39;: ...
    def alter(
        self,
        generator: Optional[Serializer] = None,
        excludes: Optional[Iterable[str]] = None,
        includes: Optional[Iterable[str]] = None,
    ) -&gt; &#39;NodeSerializer&#39;: ...


class NodeSerializer(NodeSerializing):
    &#34;&#34;&#34;
    This class provides ways to configure serialization result for a node container.

    Graph is serialized into `dict` from root node containers to their descendants.
    `NodeSerializer` should be set to each container (= template property) to control how to serialize nodes in it.

    At first, nodes to be serialized are selected by a node container using *aggregator*
    which is a function or sequence of functions extracting a node or nodes from a node container.
    `fold` and `select` are the general methods to set *aggregator* to `NodeSerializer` .

    ```python
    &gt;&gt;&gt; # NodeSerializer to select first node in the container.
    &gt;&gt;&gt; S.fold(lambda ns: ns[0])
    &gt;&gt;&gt; # NodeSerializer to select every other node.
    &gt;&gt;&gt; S.fold(lambda ns: ns[0::2])
    ```

    Each selected node is serialized in the way determined by the type of corresponding template property.
    Serialization function (= *serializer* ) is obtained usually from `pyracmon.graph.spec.GraphSpec`
    where *serializer* are stored with being related with applicable types respectively.
    Additionally, *serializer*s can be set to `NodeSerializer` directly by `each` or some other methods.
    For each node, all valid *serializer*s are collected and merged into a function which finally is applied to its entity.

    ```python
    &gt;&gt;&gt; spec = GraphSpec()
    &gt;&gt;&gt; # Register a serializer for int type which converts an int into a dict.
    &gt;&gt;&gt; spec.add_serializer(int, lambda v: dict(v=v))
    &gt;&gt;&gt; # Set serializer which multiplies values in dict.
    &gt;&gt;&gt; ns = S.each(lambda cxt: {k:v*2 for k,v in cxt.serialize()})
    &gt;&gt;&gt; # Do serialization
    &gt;&gt;&gt; graph.append(a=1).append(a=2)
    &gt;&gt;&gt; spec.to_dict(
    &gt;&gt;&gt;     graph.view,
    &gt;&gt;&gt;     a = ns,
    &gt;&gt;&gt; )
    {&#34;a&#34;: [{&#34;v&#34;: 2}, {&#34;v&#34;: 4}]}
    ```

    Only when a node is serialized into `dict` ,
    its child nodes are serialized succeedingly and the result is put into the `dict` with the same keys as their property names.
    The key can be changed by set *namer* to the `NodeSerializer` by `name` .

    Here, `merge` is a special configuration of `NodeSerializer` ,
    which can be used for the case that a child node is also serialized into `dict` and it is wanted to be merged into parent `dict` .
    It can take a callable which converts key in original child `dict` into another key used in parent `dict` .

    Whether the child should be put or merge into parent `dict` is determined whether *namer* is `str` (or `None`) or `Callable` .

    ```python
    &gt;&gt;&gt; graph.append(a=dict(a1=1, a2=2), b=dict(b1=3, b2=4))
    &gt;&gt;&gt; GraphSpec().to_dict(
    &gt;&gt;&gt;     graph.view,
    &gt;&gt;&gt;     a = S.of(),
    &gt;&gt;&gt;     b = S.merge(lambda n: f&#34;__{n}__&#34;),
    &gt;&gt;&gt; )
    {&#34;a&#34;: [{&#34;a1&#34;:1, &#34;a2&#34;:2, &#34;__b1__&#34;:3, &#34;__b2__&#34;:4}]}
    ```

    Args:
        namer: A string or a function determining the key in parent `dict` .
        aggregator: A function to select node(s) from the node container.
        serializers: List of *serializer* s.
    &#34;&#34;&#34;
    def __init__(
        self,
        namer: Optional[Union[str, Callable[[str], str]]] = None,
        aggregator: Optional[Union[Callable[[list[Node]], Node], Callable[[list[Node]], list[Node]]]] = None,
        *serializers: Serializer,
    ):
        self._namer = namer
        self._aggregator = aggregator
        self._serializers = list(serializers)
        self._be_merged = False
        self._doc = &#34;&#34;
        self._doc_options = {}

    @property
    def namer(self) -&gt; Callable[[str], str]:
        &#34;&#34;&#34;
        Returns *namer* in the form of function even when not to merge.
        &#34;&#34;&#34;
        def f(v: str) -&gt; str:
            if self._namer is None:
                return v
            elif isinstance(self._namer, str):
                return self._namer
            else:
                return self._namer(v)
        return f

    @property
    def aggregator(self) -&gt; Callable[[list[Node]], Union[list[Node], Node, Any]]:
        &#34;&#34;&#34;
        Returns *aggregator* supplied with correct return annotation.
        &#34;&#34;&#34;
        if self._aggregator is None:
            def agg1(values: list[T]) -&gt; list[T]:
                return values
            return agg1
        elif signature(self._aggregator).return_annotation == Signature.empty:
            # TODO: No return annotation implies list to list aggregation.
            def agg2(values: list[T]) -&gt; list[T]:
                return self._aggregator(values) # type: ignore
            return agg2
        else:
            return self._aggregator

    @property
    def serializer(self) -&gt; Serializer:
        &#34;&#34;&#34;
        Returns merged *serializer* which has correctly annotated signature.
        &#34;&#34;&#34;
        return chain_serializers(self._serializers)

    @property
    def be_merged(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns whether the converted value will be merged into parent.
        &#34;&#34;&#34;
        return self._be_merged

    @property
    def be_singular(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns whether the converted value will be a singular object, not a list.

        This is estimated by annotation of aggregation function. If its returning type is not annotated, this property always returns `False` .
        Builder methods adds appropriate annotation to given function when it does not have the annotation.
        &#34;&#34;&#34;
        rt = signature(self.aggregator).return_annotation
        return not issubgeneric(rt, list)

    def _set_aggregator(self, aggregator, folds):
        try:
            rt = signature(aggregator).return_annotation
        except:
            rt = Signature.empty

        if rt == Signature.empty:
            def agg(vs: list[T]) -&gt; (T if folds else list[T]):
                return aggregator(vs)
            self._aggregator = agg
        elif issubgeneric(rt, list) ^ (not folds):
            raise ValueError(f&#34;Return annotation of function is not valid.&#34;)
        else:
            self._aggregator = aggregator

        return self

    #----------------------------------------------------------------
    # Documentation
    #----------------------------------------------------------------
    def doc(self, document: str, **options: Any) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set the documentation for this node.

        `document` is used in graph schema as a parameter of `Annotated` .

        Args:
            document: A documentation string.
            options: Documentation options.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self._doc = document
        self._doc_options = options
        return self

    #----------------------------------------------------------------
    # Naming
    #----------------------------------------------------------------
    def name(self, name: str) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set a key in parent dictionary.

        Args:
            name: A key string.
        Returns:
            This instance.
        &#34;&#34;&#34;
        if not isinstance(name, str):
            raise ValueError(f&#34;The name of node must be a string but {type(name)} is given.&#34;)
        self._namer = name
        self._be_merged = False
        return self

    def merge(self, namer: Optional[Callable[[str], str]] = None) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set a naming function for merging into parent.

        Because merging needs folding, this method overrides the aggregation function by invoking `head()` internally
        if this instance is not configured to fold nodes into a single node.

        Args:
            namer: The naming function. If `None`, the property is used as it is.
        Returns:
            This instance.
        &#34;&#34;&#34;
        if namer and not callable(namer):
            raise ValueError(f&#34;The method merging a node into its parent node must be callable or None.&#34;)
        self._namer = namer or (lambda x:x)
        self._be_merged = True
        if not self.be_singular:
            self.head()
        return self

    #----------------------------------------------------------------
    # Aggregation
    #----------------------------------------------------------------
    def at(self, index: int, alt: Any = None) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set an *aggregator* which picks up the node at the index.

        Args:
            index: An index of the element.
            alt: A value used when no node is found at the index.
        Returns:
            This instance.
        &#34;&#34;&#34;
        def agg(vs: list[T]) -&gt; (Optional[T] if alt is None else T):
            return vs[index] if len(vs) &gt; index else alt
        #return self.fold(lambda vs: vs[index] if len(vs) &gt; index else alt)
        return self.fold(agg)

    def head(self, alt: Any = None) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set an *aggregator* which picks up the first node.

        Args:
            alt: A value used when there exists no nodes.
        Returns:
            This instance.
        &#34;&#34;&#34;
        return self.at(0, alt)

    def last(self, alt: Any = None) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set an *aggregator* which picks up the last node.

        Args:
            alt: A value used when there exists no nodes.
        Returns:
            This instance.
        &#34;&#34;&#34;
        def agg(vs: list[T]) -&gt; (Optional[T] if alt is None else T):
            return vs[-1] if len(vs) &gt; 0 else alt
        #return self.fold(lambda vs: vs[-1] if len(vs) &gt; 0 else alt)
        return self.fold(agg)

    def fold(self, aggregator: Callable[[list[Node]], Any]) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set an aggregation function converting a list of nodes into a single node or any value.

        Args:
            aggregator: An aggregation function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        return self._set_aggregator(aggregator, True)

    def select(self, aggregator: Callable[[list[Node]], list[Node]]) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set an aggregation function selecting a list of nodes from all nodes from the container.

        Args:
            aggregator: An aggregation function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        return self._set_aggregator(aggregator, False)

    #----------------------------------------------------------------
    # Serizlization
    #----------------------------------------------------------------
    def each(self, func: Serializer) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set a *serializer* .

        *serializer* is a function which will be invoked with a single argument of `NodeContext` ,
        from which internal code of *serializer* can get information of the node.

        For the sake of static typing, the *serializer* should have correct returns annotation.

        Args:
            func: A function converting a node entity into a value.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self._serializers.append(func)
        return self

    def sub(self, **settings) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set serialization settings for sub graph.

        This method is used for the property whose kind is `GraphTemplate` .
        The form of `settings` is same as keyword arguments used to serialize the graph.

        Args:
            settings: Serialization settings used to serialize sub graph.
        Returns:
            This instance.
        &#34;&#34;&#34;
        from pyracmon.graph.schema import GraphSchema
        class SubGraph(Typeable[T]):
            serializers = settings.copy()

            @staticmethod
            def resolve(sub_graph, bound, arg, spec):
                return GraphSchema(spec, arg.template, **sub_graph.serializers).schema

        def to_dict(cxt: NodeContext) -&gt; SubGraph[T]:
            vv = cxt.serialize()
            return SerializationContext(
                settings,
                cxt.context.finder if cxt.context else lambda t: [],
            ).execute(vv.view) # type: ignore

        self._serializers.append(to_dict)
        return self.head()

    def alter(
        self,
        generator: Optional[Serializer] = None,
        excludes: Optional[Iterable[str]] = None,
        includes: Optional[Iterable[str]] = None,
    ) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Extends and shrinks the dictionary obtained as a result of *serializer*s applied beforehand.

        `generator` is a kind of *serializer* returning `dict` which will be merged into serialization result.
        This can be used to add extra key value pairs into the result.
        For the sake of static typing, `generator` should have correct return annotation of `TypedDict` .

        `excludes` and `includes` are used to select keys from the result.

        Args:
            generator: A function generating dictionary to be merged.
            excludes: Keys to exclude.
            includes: Keys to keep.
        Returns:
            This instance.
        &#34;&#34;&#34;
        excludes = excludes or []

        class EachExtend(Extend[T]):
            @classmethod
            def schema(cls, bound, arg):
                return signature(generator).return_annotation if generator else Signature.empty

        class EachShrink(Shrink[T]):
            @classmethod
            def select(cls, td, bound):
                return excludes, includes

        def convert(cxt) -&gt; EachShrink[EachExtend[T]]:
            ext = generator(cxt) if generator else {}
            vv = cxt.serialize()
            vv.update(**to_rawdict(ext, True))
            return {k:v for k, v in vv.items() if (not includes or k in includes) and k not in excludes} # type: ignore

        self._serializers.append(convert)
        return self


class NodeParams:
    def __init__(self, params) -&gt; None:
        self._params: dict[str, Any] = params

    def __getattr__(self, key) -&gt; Optional[Any]:
        &#34;&#34;&#34;
        Returns a value by key from values passed from invoking scope being bound for the node.
        &#34;&#34;&#34;
        return self._params.get(key, None)


class NodeContext:
    &#34;&#34;&#34;
    A class containing informations for serialization of a single node.

    The instance of this class is passed to the serialization function.
    Properties listed below are available to control serialization.

    - context: `SerializationContext` for the serialization of the graph.
    - node: `Node` to serialize.
    - value: Entity value of the `Node` .
    - params: Arbitrary values which is passed from invoking scope with being bound to the key of node name.

    Every serializer has to call `serialize()` to get the result of preceeding serializers,
    or make a result direcly from the node.
    &#34;&#34;&#34;
    def __init__(self, context: &#39;SerializationContext&#39;, params: NodeParams) -&gt; None:
        #: `SerializationContext` for the serializaion of the graph.`
        self.context = context
        #: Arbitrary values passed by outside for the node.
        self.params = params
        # Set on demand.
        self._node: Optional[Node] = None
        self._iterator: Optional[Iterator[Any]] = None

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self._node = None
        self._iterator = None

    @property
    def node(self) -&gt; Node:
        # Node must be set when passed to serialization function.
        return cast(Node, self._node)

    @property
    def value(self) -&gt; Any:
        return cast(Node, self._node).entity

    def serialize(self) -&gt; Any:
        &#34;&#34;&#34;
        Obtain a value serialized by preceeding serializers.
        &#34;&#34;&#34;
        try:
            return next(cast(Iterator[Any], self._iterator))(self)
        except StopIteration:
            return self.node.entity


class NodeContextFactory:
    &#34;&#34;&#34;
    This class generates a `NodeContext` for nodes bound to a template property.

    Args:
        context: `SerializationContext` for the serialization of a graph.
        serializers: Globally registered serializers for the type of node entity.
        params: Parameters given at the serialization by caller.
    &#34;&#34;&#34;
    def __init__(
        self,
        context: &#39;SerializationContext&#39;,
        serializers: list[Serializer],
        params: dict[str, Any],
    ) -&gt; None:
        self.serializers = serializers
        # Generate and keep an instance of NodeContext to save memory for big graph.
        self.node_context = NodeContext(context, NodeParams(params))

    def begin(self, node, serializers) -&gt; NodeContext:
        self.node_context._node = node
        self.node_context._iterator = iter((self.serializers + serializers)[::-1])
        return self.node_context


class SerializationContext:
    &#34;&#34;&#34;
    This class implements actual serialization flow applied to a graph.

    `node_params` is a `dict` whose values will be passed to *serializer* via `params` attribute of `NodeContext` .
    The property name of the node is used to get values (also a `dict` ) from the `dict`
    and the `params` exposes them as its attributes of the same names as their keys.

    Arbitrary values can be passed in `node_params` which is a `dict` 

    Following code shows the example passing a parameter to a *serializer* .

    ```python
    cxt = SerializationContext(
        dict(
            a = S.each(lambda cxt: cxt.value*c.params.value),
        ),
        finder,
        dict(a={&#34;value&#34;: 10})
    )
    ```

    Args:
        settings: Mapping of node name to `NodeSerializer` .
        finder: A function to find base *serializer* s by a `type` .
        node_params: Arbitrary parameters passed to *serializer*s.
    &#34;&#34;&#34;
    def __init__(
        self,
        settings: dict[str, NodeSerializer],
        finder: Callable[[type], list[Serializer]],
        node_params: Optional[dict[str, dict[str, Any]]] = None,
    ):
        self.settings: dict[str, NodeSerializer] = settings
        self.finder: Callable[[type], list[Serializer]] = finder
        self._node_params: dict[str, dict[str, Any]] = node_params or {}
        self._context_factories: dict[str, NodeContextFactory] = {}

    def __getitem__(self, node: Union[Node, str]) -&gt; Any:
        &#34;&#34;&#34;
        Returns an accessor to parameters for given node.

        Args:
            node: Node or node name.
        Returns:
            An object exposing parameters for the node as attributes.
        &#34;&#34;&#34;
        name = node.name if isinstance(node, Node) else node
        params = self._node_params.get(name, {})

        class Accessor:
            def __getattr__(self, key):
                return params.get(key, None)

        return Accessor()

    def execute(self, graph: GraphView) -&gt; dict[str, Any]:
        &#34;&#34;&#34;
        Serializes a graph.

        Args:
            graph: The view of graph to serialize.
        Returns:
            Serialization result.
        &#34;&#34;&#34;
        result = {}
        for c in graph().roots:
            self.serialize_to(c.name, c, result)
        return result

    def serialize_to(self, name: str, container: Union[NodeContainer, Node.Children], parent: dict[str, Any]) -&gt; None:
        &#34;&#34;&#34;
        Serialize nodes and appends them into the dictionary.

        Args:
            name: Name of the template property associated with the nodes.
            container: Container of nodes. 
            parent: A parent dictionary to which serialized values will be appended.
        &#34;&#34;&#34;
        ns = self.settings.get(name, None)

        if not ns:
            # Nodes whose names are not supplied to settings are not serialized.
            return

        # First, aggregate nodes into its subset or a single node.
        nodes: Union[list[Node], Node, Any] = ns.aggregator(container.nodes)

        if ns.be_singular:
            if isinstance(nodes, list):
                raise ValueError(f&#34;Aggregation function is marked to create a single value but returns node list.&#34;)

            # Alternative value given to aggregation function may be returned instead of node.
            value = self._serialize_node(nodes, ns) if isinstance(nodes, Node) else nodes

            if ns.be_merged:
                if value is None:
                    # When empty, no key-value pair is added to parent.
                    return
                elif not isinstance(value, dict):
                    raise ValueError(f&#34;Serialized value must be dict but {type(value)}.&#34;)

                parent.update({ns.namer(k):v for k, v in value.items()})
            else:
                parent[ns.namer(name)] = value
        else:
            if not isinstance(nodes, list):
                raise ValueError(f&#34;Aggregation function is marked to return node list but returns a single value.&#34;)
            if ns.be_merged:
                raise ValueError(f&#34;Merging to parent dict requires folding.&#34;)

            parent[ns.namer(name)] = [self._serialize_node(n, ns) for n in nodes]

    def _find_serializer(self, prop: GraphTemplate.Property) -&gt; list[Serializer]:
        return self.finder(prop.kind) if isinstance(prop.kind, type) else []

    def _serialize_node(self, node: Node, node_serializer: NodeSerializer):
        if not node.prop.name in self._context_factories:
            self._context_factories[node.prop.name] = NodeContextFactory(
                self,
                self._find_serializer(node.prop),
                self._node_params.get(node.prop.name, {}),
            )

        factory = self._context_factories[node.prop.name]

        with factory.begin(node, node_serializer._serializers) as cxt:
            value = cxt.serialize()

            # Child nodes are serialized only when the parent node is serialized into a dict.
            if isinstance(value, dict):
                for n, ch in node.children.items():
                    self.serialize_to(n, ch, value)

            return value


class SerializerMeta(NodeSerializing, type): # type: ignore
    @classmethod
    def __prepare__(cls, __name: str, __bases: tuple[type, ...], **kwds: Any) -&gt; Mapping[str, object]:
        def wrap(n, f):
            def g(*args, **kwargs):
                ns = NodeSerializer()
                nf = getattr(ns, n)
                return nf(*args, **kwargs)
            return g
        return {n: wrap(n, f) for n, f in getmembers(NodeSerializing, isfunction) if not n.startswith(&#34;__&#34;)}


class S(metaclass=SerializerMeta):
    &#34;&#34;&#34;
    An utility class to build `NodeSerializer` .

    This class provides factory class methods to create `NodeSerializer`
    each of which works in the same way as the method of the same name declared on `NodeSerializer` .

    Use them to supply `NodeSerializer`s to functions to serialize a graph or to create a graph schema
    such as `graph_dict` or `graph_schema` .

    ```python
    graph_dict(
        graph,
        a = S.of(),
        b = S.head(),
    )
    ```
    &#34;&#34;&#34;
    @classmethod
    def of(
        cls,
        namer: Optional[Union[str, Callable[[str], str]]] = None,
        aggregator: Optional[Union[Callable[[list[Node]], Node], Callable[[list[Node]], list[Node]]]] = None,
        *serializers: Serializer,
    ) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Create an instance of `NodeSerializer`.

        Args:
            namer: A string or naming function.
            aggregator: An aggregation function or an index of node to select in node container.
            serializer: A list of *serializer* s.
        Returns:
            Created `NodeSerializer` .
        &#34;&#34;&#34;
        return NodeSerializer(namer, aggregator, *serializers)


def chain_serializers(serializers: list[Serializer]) -&gt; Serializer:
    &#34;&#34;&#34;
    Creates a serializer which chains given serializers.

    Args:
        serializers: A list of serializers.
    Returns:
        Chained serializer.
    &#34;&#34;&#34;
    def merge(fs) -&gt; type:
        rt = Signature.empty
        for f in fs[::-1]:
            t = signature(f).return_annotation
            if t != Signature.empty:
                try:
                    t[T]
                    rt = t if rt == Signature.empty else rt[t] # type: ignore
                except TypeError:
                    try:
                        return rt[t] # type: ignore
                    except TypeError:
                        return t
        return rt

    rt = merge(serializers)
    def composed(cxt) -&gt; rt: # type: ignore
        cxt._iterator = iter(serializers[::-1] + list(cxt._iterator))
        return cxt.serialize()

    return composed</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyracmon.graph.serialize.chain_serializers"><code class="name flex">
<span>def <span class="ident">chain_serializers</span></span>(<span>serializers: list[typing.Callable[[ForwardRef('<a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a>')], typing.Any]]) ‑> Callable[[<a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a>], Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a serializer which chains given serializers.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>serializers</code></strong></dt>
<dd>A list of serializers.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Chained serializer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chain_serializers(serializers: list[Serializer]) -&gt; Serializer:
    &#34;&#34;&#34;
    Creates a serializer which chains given serializers.

    Args:
        serializers: A list of serializers.
    Returns:
        Chained serializer.
    &#34;&#34;&#34;
    def merge(fs) -&gt; type:
        rt = Signature.empty
        for f in fs[::-1]:
            t = signature(f).return_annotation
            if t != Signature.empty:
                try:
                    t[T]
                    rt = t if rt == Signature.empty else rt[t] # type: ignore
                except TypeError:
                    try:
                        return rt[t] # type: ignore
                    except TypeError:
                        return t
        return rt

    rt = merge(serializers)
    def composed(cxt) -&gt; rt: # type: ignore
        cxt._iterator = iter(serializers[::-1] + list(cxt._iterator))
        return cxt.serialize()

    return composed</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyracmon.graph.serialize.NodeContext"><code class="flex name class">
<span>class <span class="ident">NodeContext</span></span>
<span>(</span><span>context: <a title="pyracmon.graph.serialize.SerializationContext" href="#pyracmon.graph.serialize.SerializationContext">SerializationContext</a>, params: <a title="pyracmon.graph.serialize.NodeParams" href="#pyracmon.graph.serialize.NodeParams">NodeParams</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A class containing informations for serialization of a single node.</p>
<p>The instance of this class is passed to the serialization function.
Properties listed below are available to control serialization.</p>
<ul>
<li>context: <code><a title="pyracmon.graph.serialize.SerializationContext" href="#pyracmon.graph.serialize.SerializationContext">SerializationContext</a></code> for the serialization of the graph.</li>
<li>node: <code>Node</code> to serialize.</li>
<li>value: Entity value of the <code>Node</code> .</li>
<li>params: Arbitrary values which is passed from invoking scope with being bound to the key of node name.</li>
</ul>
<p>Every serializer has to call <code>serialize()</code> to get the result of preceeding serializers,
or make a result direcly from the node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeContext:
    &#34;&#34;&#34;
    A class containing informations for serialization of a single node.

    The instance of this class is passed to the serialization function.
    Properties listed below are available to control serialization.

    - context: `SerializationContext` for the serialization of the graph.
    - node: `Node` to serialize.
    - value: Entity value of the `Node` .
    - params: Arbitrary values which is passed from invoking scope with being bound to the key of node name.

    Every serializer has to call `serialize()` to get the result of preceeding serializers,
    or make a result direcly from the node.
    &#34;&#34;&#34;
    def __init__(self, context: &#39;SerializationContext&#39;, params: NodeParams) -&gt; None:
        #: `SerializationContext` for the serializaion of the graph.`
        self.context = context
        #: Arbitrary values passed by outside for the node.
        self.params = params
        # Set on demand.
        self._node: Optional[Node] = None
        self._iterator: Optional[Iterator[Any]] = None

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self._node = None
        self._iterator = None

    @property
    def node(self) -&gt; Node:
        # Node must be set when passed to serialization function.
        return cast(Node, self._node)

    @property
    def value(self) -&gt; Any:
        return cast(Node, self._node).entity

    def serialize(self) -&gt; Any:
        &#34;&#34;&#34;
        Obtain a value serialized by preceeding serializers.
        &#34;&#34;&#34;
        try:
            return next(cast(Iterator[Any], self._iterator))(self)
        except StopIteration:
            return self.node.entity</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.graph.serialize.NodeContext.context"><code class="name">var <span class="ident">context</span></code></dt>
<dd>
<div class="desc"><p><code><a title="pyracmon.graph.serialize.SerializationContext" href="#pyracmon.graph.serialize.SerializationContext">SerializationContext</a></code> for the serializaion of the graph.`</p></div>
</dd>
<dt id="pyracmon.graph.serialize.NodeContext.node"><code class="name">var <span class="ident">node</span> : <a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def node(self) -&gt; Node:
    # Node must be set when passed to serialization function.
    return cast(Node, self._node)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeContext.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"><p>Arbitrary values passed by outside for the node.</p></div>
</dd>
<dt id="pyracmon.graph.serialize.NodeContext.value"><code class="name">var <span class="ident">value</span> : Any</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self) -&gt; Any:
    return cast(Node, self._node).entity</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.serialize.NodeContext.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Obtain a value serialized by preceeding serializers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self) -&gt; Any:
    &#34;&#34;&#34;
    Obtain a value serialized by preceeding serializers.
    &#34;&#34;&#34;
    try:
        return next(cast(Iterator[Any], self._iterator))(self)
    except StopIteration:
        return self.node.entity</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.graph.serialize.NodeContextFactory"><code class="flex name class">
<span>class <span class="ident">NodeContextFactory</span></span>
<span>(</span><span>context: <a title="pyracmon.graph.serialize.SerializationContext" href="#pyracmon.graph.serialize.SerializationContext">SerializationContext</a>, serializers: list[typing.Callable[[ForwardRef('<a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a>')], typing.Any]], params: dict[str, typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>This class generates a <code><a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a></code> for nodes bound to a template property.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong></dt>
<dd><code><a title="pyracmon.graph.serialize.SerializationContext" href="#pyracmon.graph.serialize.SerializationContext">SerializationContext</a></code> for the serialization of a graph.</dd>
<dt><strong><code>serializers</code></strong></dt>
<dd>Globally registered serializers for the type of node entity.</dd>
<dt><strong><code>params</code></strong></dt>
<dd>Parameters given at the serialization by caller.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeContextFactory:
    &#34;&#34;&#34;
    This class generates a `NodeContext` for nodes bound to a template property.

    Args:
        context: `SerializationContext` for the serialization of a graph.
        serializers: Globally registered serializers for the type of node entity.
        params: Parameters given at the serialization by caller.
    &#34;&#34;&#34;
    def __init__(
        self,
        context: &#39;SerializationContext&#39;,
        serializers: list[Serializer],
        params: dict[str, Any],
    ) -&gt; None:
        self.serializers = serializers
        # Generate and keep an instance of NodeContext to save memory for big graph.
        self.node_context = NodeContext(context, NodeParams(params))

    def begin(self, node, serializers) -&gt; NodeContext:
        self.node_context._node = node
        self.node_context._iterator = iter((self.serializers + serializers)[::-1])
        return self.node_context</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.serialize.NodeContextFactory.begin"><code class="name flex">
<span>def <span class="ident">begin</span></span>(<span>self, node, serializers) ‑> <a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def begin(self, node, serializers) -&gt; NodeContext:
    self.node_context._node = node
    self.node_context._iterator = iter((self.serializers + serializers)[::-1])
    return self.node_context</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.graph.serialize.NodeParams"><code class="flex name class">
<span>class <span class="ident">NodeParams</span></span>
<span>(</span><span>params)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeParams:
    def __init__(self, params) -&gt; None:
        self._params: dict[str, Any] = params

    def __getattr__(self, key) -&gt; Optional[Any]:
        &#34;&#34;&#34;
        Returns a value by key from values passed from invoking scope being bound for the node.
        &#34;&#34;&#34;
        return self._params.get(key, None)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializer"><code class="flex name class">
<span>class <span class="ident">NodeSerializer</span></span>
<span>(</span><span>namer: Union[str, Callable[[str], str], ForwardRef(None)] = None, aggregator: Union[Callable[[list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]], <a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>], Callable[[list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]], list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]], ForwardRef(None)] = None, *serializers: Callable[[ForwardRef('<a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a>')], Any])</span>
</code></dt>
<dd>
<div class="desc"><p>This class provides ways to configure serialization result for a node container.</p>
<p>Graph is serialized into <code>dict</code> from root node containers to their descendants.
<code><a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></code> should be set to each container (= template property) to control how to serialize nodes in it.</p>
<p>At first, nodes to be serialized are selected by a node container using <em>aggregator</em>
which is a function or sequence of functions extracting a node or nodes from a node container.
<code>fold</code> and <code>select</code> are the general methods to set <em>aggregator</em> to <code><a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></code> .</p>
<pre><code class="language-python">&gt;&gt;&gt; # NodeSerializer to select first node in the container.
&gt;&gt;&gt; S.fold(lambda ns: ns[0])
&gt;&gt;&gt; # NodeSerializer to select every other node.
&gt;&gt;&gt; S.fold(lambda ns: ns[0::2])
</code></pre>
<p>Each selected node is serialized in the way determined by the type of corresponding template property.
Serialization function (= <em>serializer</em> ) is obtained usually from <code><a title="pyracmon.graph.spec.GraphSpec" href="spec.html#pyracmon.graph.spec.GraphSpec">GraphSpec</a></code>
where <em>serializer</em> are stored with being related with applicable types respectively.
Additionally, <em>serializer</em>s can be set to <code><a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></code> directly by <code>each</code> or some other methods.
For each node, all valid <em>serializer</em>s are collected and merged into a function which finally is applied to its entity.</p>
<pre><code class="language-python">&gt;&gt;&gt; spec = GraphSpec()
&gt;&gt;&gt; # Register a serializer for int type which converts an int into a dict.
&gt;&gt;&gt; spec.add_serializer(int, lambda v: dict(v=v))
&gt;&gt;&gt; # Set serializer which multiplies values in dict.
&gt;&gt;&gt; ns = S.each(lambda cxt: {k:v*2 for k,v in cxt.serialize()})
&gt;&gt;&gt; # Do serialization
&gt;&gt;&gt; graph.append(a=1).append(a=2)
&gt;&gt;&gt; spec.to_dict(
&gt;&gt;&gt;     graph.view,
&gt;&gt;&gt;     a = ns,
&gt;&gt;&gt; )
{&quot;a&quot;: [{&quot;v&quot;: 2}, {&quot;v&quot;: 4}]}
</code></pre>
<p>Only when a node is serialized into <code>dict</code> ,
its child nodes are serialized succeedingly and the result is put into the <code>dict</code> with the same keys as their property names.
The key can be changed by set <em>namer</em> to the <code><a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></code> by <code>name</code> .</p>
<p>Here, <code>merge</code> is a special configuration of <code><a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></code> ,
which can be used for the case that a child node is also serialized into <code>dict</code> and it is wanted to be merged into parent <code>dict</code> .
It can take a callable which converts key in original child <code>dict</code> into another key used in parent <code>dict</code> .</p>
<p>Whether the child should be put or merge into parent <code>dict</code> is determined whether <em>namer</em> is <code>str</code> (or <code>None</code>) or <code>Callable</code> .</p>
<pre><code class="language-python">&gt;&gt;&gt; graph.append(a=dict(a1=1, a2=2), b=dict(b1=3, b2=4))
&gt;&gt;&gt; GraphSpec().to_dict(
&gt;&gt;&gt;     graph.view,
&gt;&gt;&gt;     a = S.of(),
&gt;&gt;&gt;     b = S.merge(lambda n: f&quot;__{n}__&quot;),
&gt;&gt;&gt; )
{&quot;a&quot;: [{&quot;a1&quot;:1, &quot;a2&quot;:2, &quot;__b1__&quot;:3, &quot;__b2__&quot;:4}]}
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>namer</code></strong></dt>
<dd>A string or a function determining the key in parent <code>dict</code> .</dd>
<dt><strong><code>aggregator</code></strong></dt>
<dd>A function to select node(s) from the node container.</dd>
<dt><strong><code>serializers</code></strong></dt>
<dd>List of <em>serializer</em> s.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeSerializer(NodeSerializing):
    &#34;&#34;&#34;
    This class provides ways to configure serialization result for a node container.

    Graph is serialized into `dict` from root node containers to their descendants.
    `NodeSerializer` should be set to each container (= template property) to control how to serialize nodes in it.

    At first, nodes to be serialized are selected by a node container using *aggregator*
    which is a function or sequence of functions extracting a node or nodes from a node container.
    `fold` and `select` are the general methods to set *aggregator* to `NodeSerializer` .

    ```python
    &gt;&gt;&gt; # NodeSerializer to select first node in the container.
    &gt;&gt;&gt; S.fold(lambda ns: ns[0])
    &gt;&gt;&gt; # NodeSerializer to select every other node.
    &gt;&gt;&gt; S.fold(lambda ns: ns[0::2])
    ```

    Each selected node is serialized in the way determined by the type of corresponding template property.
    Serialization function (= *serializer* ) is obtained usually from `pyracmon.graph.spec.GraphSpec`
    where *serializer* are stored with being related with applicable types respectively.
    Additionally, *serializer*s can be set to `NodeSerializer` directly by `each` or some other methods.
    For each node, all valid *serializer*s are collected and merged into a function which finally is applied to its entity.

    ```python
    &gt;&gt;&gt; spec = GraphSpec()
    &gt;&gt;&gt; # Register a serializer for int type which converts an int into a dict.
    &gt;&gt;&gt; spec.add_serializer(int, lambda v: dict(v=v))
    &gt;&gt;&gt; # Set serializer which multiplies values in dict.
    &gt;&gt;&gt; ns = S.each(lambda cxt: {k:v*2 for k,v in cxt.serialize()})
    &gt;&gt;&gt; # Do serialization
    &gt;&gt;&gt; graph.append(a=1).append(a=2)
    &gt;&gt;&gt; spec.to_dict(
    &gt;&gt;&gt;     graph.view,
    &gt;&gt;&gt;     a = ns,
    &gt;&gt;&gt; )
    {&#34;a&#34;: [{&#34;v&#34;: 2}, {&#34;v&#34;: 4}]}
    ```

    Only when a node is serialized into `dict` ,
    its child nodes are serialized succeedingly and the result is put into the `dict` with the same keys as their property names.
    The key can be changed by set *namer* to the `NodeSerializer` by `name` .

    Here, `merge` is a special configuration of `NodeSerializer` ,
    which can be used for the case that a child node is also serialized into `dict` and it is wanted to be merged into parent `dict` .
    It can take a callable which converts key in original child `dict` into another key used in parent `dict` .

    Whether the child should be put or merge into parent `dict` is determined whether *namer* is `str` (or `None`) or `Callable` .

    ```python
    &gt;&gt;&gt; graph.append(a=dict(a1=1, a2=2), b=dict(b1=3, b2=4))
    &gt;&gt;&gt; GraphSpec().to_dict(
    &gt;&gt;&gt;     graph.view,
    &gt;&gt;&gt;     a = S.of(),
    &gt;&gt;&gt;     b = S.merge(lambda n: f&#34;__{n}__&#34;),
    &gt;&gt;&gt; )
    {&#34;a&#34;: [{&#34;a1&#34;:1, &#34;a2&#34;:2, &#34;__b1__&#34;:3, &#34;__b2__&#34;:4}]}
    ```

    Args:
        namer: A string or a function determining the key in parent `dict` .
        aggregator: A function to select node(s) from the node container.
        serializers: List of *serializer* s.
    &#34;&#34;&#34;
    def __init__(
        self,
        namer: Optional[Union[str, Callable[[str], str]]] = None,
        aggregator: Optional[Union[Callable[[list[Node]], Node], Callable[[list[Node]], list[Node]]]] = None,
        *serializers: Serializer,
    ):
        self._namer = namer
        self._aggregator = aggregator
        self._serializers = list(serializers)
        self._be_merged = False
        self._doc = &#34;&#34;
        self._doc_options = {}

    @property
    def namer(self) -&gt; Callable[[str], str]:
        &#34;&#34;&#34;
        Returns *namer* in the form of function even when not to merge.
        &#34;&#34;&#34;
        def f(v: str) -&gt; str:
            if self._namer is None:
                return v
            elif isinstance(self._namer, str):
                return self._namer
            else:
                return self._namer(v)
        return f

    @property
    def aggregator(self) -&gt; Callable[[list[Node]], Union[list[Node], Node, Any]]:
        &#34;&#34;&#34;
        Returns *aggregator* supplied with correct return annotation.
        &#34;&#34;&#34;
        if self._aggregator is None:
            def agg1(values: list[T]) -&gt; list[T]:
                return values
            return agg1
        elif signature(self._aggregator).return_annotation == Signature.empty:
            # TODO: No return annotation implies list to list aggregation.
            def agg2(values: list[T]) -&gt; list[T]:
                return self._aggregator(values) # type: ignore
            return agg2
        else:
            return self._aggregator

    @property
    def serializer(self) -&gt; Serializer:
        &#34;&#34;&#34;
        Returns merged *serializer* which has correctly annotated signature.
        &#34;&#34;&#34;
        return chain_serializers(self._serializers)

    @property
    def be_merged(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns whether the converted value will be merged into parent.
        &#34;&#34;&#34;
        return self._be_merged

    @property
    def be_singular(self) -&gt; bool:
        &#34;&#34;&#34;
        Returns whether the converted value will be a singular object, not a list.

        This is estimated by annotation of aggregation function. If its returning type is not annotated, this property always returns `False` .
        Builder methods adds appropriate annotation to given function when it does not have the annotation.
        &#34;&#34;&#34;
        rt = signature(self.aggregator).return_annotation
        return not issubgeneric(rt, list)

    def _set_aggregator(self, aggregator, folds):
        try:
            rt = signature(aggregator).return_annotation
        except:
            rt = Signature.empty

        if rt == Signature.empty:
            def agg(vs: list[T]) -&gt; (T if folds else list[T]):
                return aggregator(vs)
            self._aggregator = agg
        elif issubgeneric(rt, list) ^ (not folds):
            raise ValueError(f&#34;Return annotation of function is not valid.&#34;)
        else:
            self._aggregator = aggregator

        return self

    #----------------------------------------------------------------
    # Documentation
    #----------------------------------------------------------------
    def doc(self, document: str, **options: Any) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set the documentation for this node.

        `document` is used in graph schema as a parameter of `Annotated` .

        Args:
            document: A documentation string.
            options: Documentation options.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self._doc = document
        self._doc_options = options
        return self

    #----------------------------------------------------------------
    # Naming
    #----------------------------------------------------------------
    def name(self, name: str) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set a key in parent dictionary.

        Args:
            name: A key string.
        Returns:
            This instance.
        &#34;&#34;&#34;
        if not isinstance(name, str):
            raise ValueError(f&#34;The name of node must be a string but {type(name)} is given.&#34;)
        self._namer = name
        self._be_merged = False
        return self

    def merge(self, namer: Optional[Callable[[str], str]] = None) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set a naming function for merging into parent.

        Because merging needs folding, this method overrides the aggregation function by invoking `head()` internally
        if this instance is not configured to fold nodes into a single node.

        Args:
            namer: The naming function. If `None`, the property is used as it is.
        Returns:
            This instance.
        &#34;&#34;&#34;
        if namer and not callable(namer):
            raise ValueError(f&#34;The method merging a node into its parent node must be callable or None.&#34;)
        self._namer = namer or (lambda x:x)
        self._be_merged = True
        if not self.be_singular:
            self.head()
        return self

    #----------------------------------------------------------------
    # Aggregation
    #----------------------------------------------------------------
    def at(self, index: int, alt: Any = None) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set an *aggregator* which picks up the node at the index.

        Args:
            index: An index of the element.
            alt: A value used when no node is found at the index.
        Returns:
            This instance.
        &#34;&#34;&#34;
        def agg(vs: list[T]) -&gt; (Optional[T] if alt is None else T):
            return vs[index] if len(vs) &gt; index else alt
        #return self.fold(lambda vs: vs[index] if len(vs) &gt; index else alt)
        return self.fold(agg)

    def head(self, alt: Any = None) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set an *aggregator* which picks up the first node.

        Args:
            alt: A value used when there exists no nodes.
        Returns:
            This instance.
        &#34;&#34;&#34;
        return self.at(0, alt)

    def last(self, alt: Any = None) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set an *aggregator* which picks up the last node.

        Args:
            alt: A value used when there exists no nodes.
        Returns:
            This instance.
        &#34;&#34;&#34;
        def agg(vs: list[T]) -&gt; (Optional[T] if alt is None else T):
            return vs[-1] if len(vs) &gt; 0 else alt
        #return self.fold(lambda vs: vs[-1] if len(vs) &gt; 0 else alt)
        return self.fold(agg)

    def fold(self, aggregator: Callable[[list[Node]], Any]) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set an aggregation function converting a list of nodes into a single node or any value.

        Args:
            aggregator: An aggregation function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        return self._set_aggregator(aggregator, True)

    def select(self, aggregator: Callable[[list[Node]], list[Node]]) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set an aggregation function selecting a list of nodes from all nodes from the container.

        Args:
            aggregator: An aggregation function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        return self._set_aggregator(aggregator, False)

    #----------------------------------------------------------------
    # Serizlization
    #----------------------------------------------------------------
    def each(self, func: Serializer) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set a *serializer* .

        *serializer* is a function which will be invoked with a single argument of `NodeContext` ,
        from which internal code of *serializer* can get information of the node.

        For the sake of static typing, the *serializer* should have correct returns annotation.

        Args:
            func: A function converting a node entity into a value.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self._serializers.append(func)
        return self

    def sub(self, **settings) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Set serialization settings for sub graph.

        This method is used for the property whose kind is `GraphTemplate` .
        The form of `settings` is same as keyword arguments used to serialize the graph.

        Args:
            settings: Serialization settings used to serialize sub graph.
        Returns:
            This instance.
        &#34;&#34;&#34;
        from pyracmon.graph.schema import GraphSchema
        class SubGraph(Typeable[T]):
            serializers = settings.copy()

            @staticmethod
            def resolve(sub_graph, bound, arg, spec):
                return GraphSchema(spec, arg.template, **sub_graph.serializers).schema

        def to_dict(cxt: NodeContext) -&gt; SubGraph[T]:
            vv = cxt.serialize()
            return SerializationContext(
                settings,
                cxt.context.finder if cxt.context else lambda t: [],
            ).execute(vv.view) # type: ignore

        self._serializers.append(to_dict)
        return self.head()

    def alter(
        self,
        generator: Optional[Serializer] = None,
        excludes: Optional[Iterable[str]] = None,
        includes: Optional[Iterable[str]] = None,
    ) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Extends and shrinks the dictionary obtained as a result of *serializer*s applied beforehand.

        `generator` is a kind of *serializer* returning `dict` which will be merged into serialization result.
        This can be used to add extra key value pairs into the result.
        For the sake of static typing, `generator` should have correct return annotation of `TypedDict` .

        `excludes` and `includes` are used to select keys from the result.

        Args:
            generator: A function generating dictionary to be merged.
            excludes: Keys to exclude.
            includes: Keys to keep.
        Returns:
            This instance.
        &#34;&#34;&#34;
        excludes = excludes or []

        class EachExtend(Extend[T]):
            @classmethod
            def schema(cls, bound, arg):
                return signature(generator).return_annotation if generator else Signature.empty

        class EachShrink(Shrink[T]):
            @classmethod
            def select(cls, td, bound):
                return excludes, includes

        def convert(cxt) -&gt; EachShrink[EachExtend[T]]:
            ext = generator(cxt) if generator else {}
            vv = cxt.serialize()
            vv.update(**to_rawdict(ext, True))
            return {k:v for k, v in vv.items() if (not includes or k in includes) and k not in excludes} # type: ignore

        self._serializers.append(convert)
        return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.graph.serialize.NodeSerializing" href="#pyracmon.graph.serialize.NodeSerializing">NodeSerializing</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.graph.serialize.NodeSerializer.aggregator"><code class="name">var <span class="ident">aggregator</span> : Callable[[list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]], Union[list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>], <a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>, Any]]</code></dt>
<dd>
<div class="desc"><p>Returns <em>aggregator</em> supplied with correct return annotation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def aggregator(self) -&gt; Callable[[list[Node]], Union[list[Node], Node, Any]]:
    &#34;&#34;&#34;
    Returns *aggregator* supplied with correct return annotation.
    &#34;&#34;&#34;
    if self._aggregator is None:
        def agg1(values: list[T]) -&gt; list[T]:
            return values
        return agg1
    elif signature(self._aggregator).return_annotation == Signature.empty:
        # TODO: No return annotation implies list to list aggregation.
        def agg2(values: list[T]) -&gt; list[T]:
            return self._aggregator(values) # type: ignore
        return agg2
    else:
        return self._aggregator</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializer.be_merged"><code class="name">var <span class="ident">be_merged</span> : bool</code></dt>
<dd>
<div class="desc"><p>Returns whether the converted value will be merged into parent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def be_merged(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns whether the converted value will be merged into parent.
    &#34;&#34;&#34;
    return self._be_merged</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializer.be_singular"><code class="name">var <span class="ident">be_singular</span> : bool</code></dt>
<dd>
<div class="desc"><p>Returns whether the converted value will be a singular object, not a list.</p>
<p>This is estimated by annotation of aggregation function. If its returning type is not annotated, this property always returns <code>False</code> .
Builder methods adds appropriate annotation to given function when it does not have the annotation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def be_singular(self) -&gt; bool:
    &#34;&#34;&#34;
    Returns whether the converted value will be a singular object, not a list.

    This is estimated by annotation of aggregation function. If its returning type is not annotated, this property always returns `False` .
    Builder methods adds appropriate annotation to given function when it does not have the annotation.
    &#34;&#34;&#34;
    rt = signature(self.aggregator).return_annotation
    return not issubgeneric(rt, list)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializer.namer"><code class="name">var <span class="ident">namer</span> : Callable[[str], str]</code></dt>
<dd>
<div class="desc"><p>Returns <em>namer</em> in the form of function even when not to merge.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def namer(self) -&gt; Callable[[str], str]:
    &#34;&#34;&#34;
    Returns *namer* in the form of function even when not to merge.
    &#34;&#34;&#34;
    def f(v: str) -&gt; str:
        if self._namer is None:
            return v
        elif isinstance(self._namer, str):
            return self._namer
        else:
            return self._namer(v)
    return f</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializer.serializer"><code class="name">var <span class="ident">serializer</span> : Callable[[<a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a>], Any]</code></dt>
<dd>
<div class="desc"><p>Returns merged <em>serializer</em> which has correctly annotated signature.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def serializer(self) -&gt; Serializer:
    &#34;&#34;&#34;
    Returns merged *serializer* which has correctly annotated signature.
    &#34;&#34;&#34;
    return chain_serializers(self._serializers)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.serialize.NodeSerializer.alter"><code class="name flex">
<span>def <span class="ident">alter</span></span>(<span>self, generator: Optional[Callable[[ForwardRef('<a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a>')], Any]] = None, excludes: Optional[collections.abc.Iterable[str]] = None, includes: Optional[collections.abc.Iterable[str]] = None) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Extends and shrinks the dictionary obtained as a result of <em>serializer</em>s applied beforehand.</p>
<p><code>generator</code> is a kind of <em>serializer</em> returning <code>dict</code> which will be merged into serialization result.
This can be used to add extra key value pairs into the result.
For the sake of static typing, <code>generator</code> should have correct return annotation of <code>TypedDict</code> .</p>
<p><code>excludes</code> and <code>includes</code> are used to select keys from the result.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>generator</code></strong></dt>
<dd>A function generating dictionary to be merged.</dd>
<dt><strong><code>excludes</code></strong></dt>
<dd>Keys to exclude.</dd>
<dt><strong><code>includes</code></strong></dt>
<dd>Keys to keep.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alter(
    self,
    generator: Optional[Serializer] = None,
    excludes: Optional[Iterable[str]] = None,
    includes: Optional[Iterable[str]] = None,
) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Extends and shrinks the dictionary obtained as a result of *serializer*s applied beforehand.

    `generator` is a kind of *serializer* returning `dict` which will be merged into serialization result.
    This can be used to add extra key value pairs into the result.
    For the sake of static typing, `generator` should have correct return annotation of `TypedDict` .

    `excludes` and `includes` are used to select keys from the result.

    Args:
        generator: A function generating dictionary to be merged.
        excludes: Keys to exclude.
        includes: Keys to keep.
    Returns:
        This instance.
    &#34;&#34;&#34;
    excludes = excludes or []

    class EachExtend(Extend[T]):
        @classmethod
        def schema(cls, bound, arg):
            return signature(generator).return_annotation if generator else Signature.empty

    class EachShrink(Shrink[T]):
        @classmethod
        def select(cls, td, bound):
            return excludes, includes

    def convert(cxt) -&gt; EachShrink[EachExtend[T]]:
        ext = generator(cxt) if generator else {}
        vv = cxt.serialize()
        vv.update(**to_rawdict(ext, True))
        return {k:v for k, v in vv.items() if (not includes or k in includes) and k not in excludes} # type: ignore

    self._serializers.append(convert)
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializer.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, index: int, alt: Any = None) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Set an <em>aggregator</em> which picks up the node at the index.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>index</code></strong></dt>
<dd>An index of the element.</dd>
<dt><strong><code>alt</code></strong></dt>
<dd>A value used when no node is found at the index.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, index: int, alt: Any = None) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Set an *aggregator* which picks up the node at the index.

    Args:
        index: An index of the element.
        alt: A value used when no node is found at the index.
    Returns:
        This instance.
    &#34;&#34;&#34;
    def agg(vs: list[T]) -&gt; (Optional[T] if alt is None else T):
        return vs[index] if len(vs) &gt; index else alt
    #return self.fold(lambda vs: vs[index] if len(vs) &gt; index else alt)
    return self.fold(agg)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializer.doc"><code class="name flex">
<span>def <span class="ident">doc</span></span>(<span>self, document: str, **options: Any) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Set the documentation for this node.</p>
<p><code>document</code> is used in graph schema as a parameter of <code>Annotated</code> .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>document</code></strong></dt>
<dd>A documentation string.</dd>
<dt><strong><code>options</code></strong></dt>
<dd>Documentation options.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def doc(self, document: str, **options: Any) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Set the documentation for this node.

    `document` is used in graph schema as a parameter of `Annotated` .

    Args:
        document: A documentation string.
        options: Documentation options.
    Returns:
        This instance.
    &#34;&#34;&#34;
    self._doc = document
    self._doc_options = options
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializer.each"><code class="name flex">
<span>def <span class="ident">each</span></span>(<span>self, func: Callable[[ForwardRef('<a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a>')], Any]) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Set a <em>serializer</em> .</p>
<p><em>serializer</em> is a function which will be invoked with a single argument of <code><a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a></code> ,
from which internal code of <em>serializer</em> can get information of the node.</p>
<p>For the sake of static typing, the <em>serializer</em> should have correct returns annotation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>func</code></strong></dt>
<dd>A function converting a node entity into a value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def each(self, func: Serializer) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Set a *serializer* .

    *serializer* is a function which will be invoked with a single argument of `NodeContext` ,
    from which internal code of *serializer* can get information of the node.

    For the sake of static typing, the *serializer* should have correct returns annotation.

    Args:
        func: A function converting a node entity into a value.
    Returns:
        This instance.
    &#34;&#34;&#34;
    self._serializers.append(func)
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializer.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>self, aggregator: Callable[[list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]], Any]) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Set an aggregation function converting a list of nodes into a single node or any value.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>aggregator</code></strong></dt>
<dd>An aggregation function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(self, aggregator: Callable[[list[Node]], Any]) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Set an aggregation function converting a list of nodes into a single node or any value.

    Args:
        aggregator: An aggregation function.
    Returns:
        This instance.
    &#34;&#34;&#34;
    return self._set_aggregator(aggregator, True)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializer.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>self, alt: Any = None) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Set an <em>aggregator</em> which picks up the first node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>alt</code></strong></dt>
<dd>A value used when there exists no nodes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(self, alt: Any = None) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Set an *aggregator* which picks up the first node.

    Args:
        alt: A value used when there exists no nodes.
    Returns:
        This instance.
    &#34;&#34;&#34;
    return self.at(0, alt)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializer.last"><code class="name flex">
<span>def <span class="ident">last</span></span>(<span>self, alt: Any = None) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Set an <em>aggregator</em> which picks up the last node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>alt</code></strong></dt>
<dd>A value used when there exists no nodes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last(self, alt: Any = None) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Set an *aggregator* which picks up the last node.

    Args:
        alt: A value used when there exists no nodes.
    Returns:
        This instance.
    &#34;&#34;&#34;
    def agg(vs: list[T]) -&gt; (Optional[T] if alt is None else T):
        return vs[-1] if len(vs) &gt; 0 else alt
    #return self.fold(lambda vs: vs[-1] if len(vs) &gt; 0 else alt)
    return self.fold(agg)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializer.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, namer: Optional[Callable[[str], str]] = None) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Set a naming function for merging into parent.</p>
<p>Because merging needs folding, this method overrides the aggregation function by invoking <code>head()</code> internally
if this instance is not configured to fold nodes into a single node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>namer</code></strong></dt>
<dd>The naming function. If <code>None</code>, the property is used as it is.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, namer: Optional[Callable[[str], str]] = None) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Set a naming function for merging into parent.

    Because merging needs folding, this method overrides the aggregation function by invoking `head()` internally
    if this instance is not configured to fold nodes into a single node.

    Args:
        namer: The naming function. If `None`, the property is used as it is.
    Returns:
        This instance.
    &#34;&#34;&#34;
    if namer and not callable(namer):
        raise ValueError(f&#34;The method merging a node into its parent node must be callable or None.&#34;)
    self._namer = namer or (lambda x:x)
    self._be_merged = True
    if not self.be_singular:
        self.head()
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializer.name"><code class="name flex">
<span>def <span class="ident">name</span></span>(<span>self, name: str) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Set a key in parent dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>A key string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def name(self, name: str) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Set a key in parent dictionary.

    Args:
        name: A key string.
    Returns:
        This instance.
    &#34;&#34;&#34;
    if not isinstance(name, str):
        raise ValueError(f&#34;The name of node must be a string but {type(name)} is given.&#34;)
    self._namer = name
    self._be_merged = False
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializer.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, aggregator: Callable[[list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]], list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]]) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Set an aggregation function selecting a list of nodes from all nodes from the container.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>aggregator</code></strong></dt>
<dd>An aggregation function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self, aggregator: Callable[[list[Node]], list[Node]]) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Set an aggregation function selecting a list of nodes from all nodes from the container.

    Args:
        aggregator: An aggregation function.
    Returns:
        This instance.
    &#34;&#34;&#34;
    return self._set_aggregator(aggregator, False)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializer.sub"><code class="name flex">
<span>def <span class="ident">sub</span></span>(<span>self, **settings) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Set serialization settings for sub graph.</p>
<p>This method is used for the property whose kind is <code>GraphTemplate</code> .
The form of <code>settings</code> is same as keyword arguments used to serialize the graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>settings</code></strong></dt>
<dd>Serialization settings used to serialize sub graph.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sub(self, **settings) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Set serialization settings for sub graph.

    This method is used for the property whose kind is `GraphTemplate` .
    The form of `settings` is same as keyword arguments used to serialize the graph.

    Args:
        settings: Serialization settings used to serialize sub graph.
    Returns:
        This instance.
    &#34;&#34;&#34;
    from pyracmon.graph.schema import GraphSchema
    class SubGraph(Typeable[T]):
        serializers = settings.copy()

        @staticmethod
        def resolve(sub_graph, bound, arg, spec):
            return GraphSchema(spec, arg.template, **sub_graph.serializers).schema

    def to_dict(cxt: NodeContext) -&gt; SubGraph[T]:
        vv = cxt.serialize()
        return SerializationContext(
            settings,
            cxt.context.finder if cxt.context else lambda t: [],
        ).execute(vv.view) # type: ignore

    self._serializers.append(to_dict)
    return self.head()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializing"><code class="flex name class">
<span>class <span class="ident">NodeSerializing</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeSerializing(Protocol):
    def doc(self, document: str, **options: Any) -&gt; &#39;NodeSerializer&#39;: ...
    def name(self, name: str) -&gt; &#39;NodeSerializer&#39;: ...
    def merge(self, namer: Optional[Callable[[str], str]] = None) -&gt; &#39;NodeSerializer&#39;: ...
    def at(self, index: int, alt: Any = None) -&gt; &#39;NodeSerializer&#39;: ...
    def head(self, alt: Any = None) -&gt; &#39;NodeSerializer&#39;: ...
    def last(self, alt: Any = None) -&gt; &#39;NodeSerializer&#39;: ...
    def fold(self, aggregator: Callable[[list[Node]], Any]) -&gt; &#39;NodeSerializer&#39;: ...
    def select(self, aggregator: Callable[[list[Node]], list[Node]]) -&gt; &#39;NodeSerializer&#39;: ...
    def each(self, func: Serializer) -&gt; &#39;NodeSerializer&#39;: ...
    def sub(self, **settings) -&gt; &#39;NodeSerializer&#39;: ...
    def alter(
        self,
        generator: Optional[Serializer] = None,
        excludes: Optional[Iterable[str]] = None,
        includes: Optional[Iterable[str]] = None,
    ) -&gt; &#39;NodeSerializer&#39;: ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></li>
<li><a title="pyracmon.graph.serialize.SerializerMeta" href="#pyracmon.graph.serialize.SerializerMeta">SerializerMeta</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.serialize.NodeSerializing.alter"><code class="name flex">
<span>def <span class="ident">alter</span></span>(<span>self, generator: Optional[Callable[[ForwardRef('<a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a>')], Any]] = None, excludes: Optional[collections.abc.Iterable[str]] = None, includes: Optional[collections.abc.Iterable[str]] = None) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alter(
    self,
    generator: Optional[Serializer] = None,
    excludes: Optional[Iterable[str]] = None,
    includes: Optional[Iterable[str]] = None,
) -&gt; &#39;NodeSerializer&#39;: ...</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializing.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>self, index: int, alt: Any = None) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def at(self, index: int, alt: Any = None) -&gt; &#39;NodeSerializer&#39;: ...</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializing.doc"><code class="name flex">
<span>def <span class="ident">doc</span></span>(<span>self, document: str, **options: Any) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def doc(self, document: str, **options: Any) -&gt; &#39;NodeSerializer&#39;: ...</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializing.each"><code class="name flex">
<span>def <span class="ident">each</span></span>(<span>self, func: Callable[[ForwardRef('<a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a>')], Any]) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def each(self, func: Serializer) -&gt; &#39;NodeSerializer&#39;: ...</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializing.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>self, aggregator: Callable[[list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]], Any]) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fold(self, aggregator: Callable[[list[Node]], Any]) -&gt; &#39;NodeSerializer&#39;: ...</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializing.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>self, alt: Any = None) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def head(self, alt: Any = None) -&gt; &#39;NodeSerializer&#39;: ...</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializing.last"><code class="name flex">
<span>def <span class="ident">last</span></span>(<span>self, alt: Any = None) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last(self, alt: Any = None) -&gt; &#39;NodeSerializer&#39;: ...</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializing.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>self, namer: Optional[Callable[[str], str]] = None) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge(self, namer: Optional[Callable[[str], str]] = None) -&gt; &#39;NodeSerializer&#39;: ...</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializing.name"><code class="name flex">
<span>def <span class="ident">name</span></span>(<span>self, name: str) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def name(self, name: str) -&gt; &#39;NodeSerializer&#39;: ...</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializing.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, aggregator: Callable[[list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]], list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]]) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self, aggregator: Callable[[list[Node]], list[Node]]) -&gt; &#39;NodeSerializer&#39;: ...</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.NodeSerializing.sub"><code class="name flex">
<span>def <span class="ident">sub</span></span>(<span>self, **settings) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sub(self, **settings) -&gt; &#39;NodeSerializer&#39;: ...</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.graph.serialize.S"><code class="flex name class">
<span>class <span class="ident">S</span></span>
</code></dt>
<dd>
<div class="desc"><p>An utility class to build <code><a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></code> .</p>
<p>This class provides factory class methods to create <code><a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></code>
each of which works in the same way as the method of the same name declared on <code><a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></code> .</p>
<p>Use them to supply <code><a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></code>s to functions to serialize a graph or to create a graph schema
such as <code>graph_dict</code> or <code>graph_schema</code> .</p>
<pre><code class="language-python">graph_dict(
    graph,
    a = S.of(),
    b = S.head(),
)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class S(metaclass=SerializerMeta):
    &#34;&#34;&#34;
    An utility class to build `NodeSerializer` .

    This class provides factory class methods to create `NodeSerializer`
    each of which works in the same way as the method of the same name declared on `NodeSerializer` .

    Use them to supply `NodeSerializer`s to functions to serialize a graph or to create a graph schema
    such as `graph_dict` or `graph_schema` .

    ```python
    graph_dict(
        graph,
        a = S.of(),
        b = S.head(),
    )
    ```
    &#34;&#34;&#34;
    @classmethod
    def of(
        cls,
        namer: Optional[Union[str, Callable[[str], str]]] = None,
        aggregator: Optional[Union[Callable[[list[Node]], Node], Callable[[list[Node]], list[Node]]]] = None,
        *serializers: Serializer,
    ) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Create an instance of `NodeSerializer`.

        Args:
            namer: A string or naming function.
            aggregator: An aggregation function or an index of node to select in node container.
            serializer: A list of *serializer* s.
        Returns:
            Created `NodeSerializer` .
        &#34;&#34;&#34;
        return NodeSerializer(namer, aggregator, *serializers)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.graph.serialize.S.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>namer: Union[str, Callable[[str], str], ForwardRef(None)] = None, aggregator: Union[Callable[[list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]], <a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>], Callable[[list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]], list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]], ForwardRef(None)] = None, *serializers: Callable[[ForwardRef('<a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a>')], Any]) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create an instance of <code><a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>namer</code></strong></dt>
<dd>A string or naming function.</dd>
<dt><strong><code>aggregator</code></strong></dt>
<dd>An aggregation function or an index of node to select in node container.</dd>
<dt><strong><code>serializer</code></strong></dt>
<dd>A list of <em>serializer</em> s.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Created <code><a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def of(
    cls,
    namer: Optional[Union[str, Callable[[str], str]]] = None,
    aggregator: Optional[Union[Callable[[list[Node]], Node], Callable[[list[Node]], list[Node]]]] = None,
    *serializers: Serializer,
) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Create an instance of `NodeSerializer`.

    Args:
        namer: A string or naming function.
        aggregator: An aggregation function or an index of node to select in node container.
        serializer: A list of *serializer* s.
    Returns:
        Created `NodeSerializer` .
    &#34;&#34;&#34;
    return NodeSerializer(namer, aggregator, *serializers)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.serialize.S.alter"><code class="name flex">
<span>def <span class="ident">alter</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.S.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.S.doc"><code class="name flex">
<span>def <span class="ident">doc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.S.each"><code class="name flex">
<span>def <span class="ident">each</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.S.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.S.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.S.last"><code class="name flex">
<span>def <span class="ident">last</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.S.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.S.name"><code class="name flex">
<span>def <span class="ident">name</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.S.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.S.sub"><code class="name flex">
<span>def <span class="ident">sub</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.graph.serialize.SerializationContext"><code class="flex name class">
<span>class <span class="ident">SerializationContext</span></span>
<span>(</span><span>settings: dict[str, <a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>], finder: Callable[[type], list[Callable[[ForwardRef('<a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a>')], Any]]], node_params: Optional[dict[str, dict[str, typing.Any]]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class implements actual serialization flow applied to a graph.</p>
<p><code>node_params</code> is a <code>dict</code> whose values will be passed to <em>serializer</em> via <code>params</code> attribute of <code><a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a></code> .
The property name of the node is used to get values (also a <code>dict</code> ) from the <code>dict</code>
and the <code>params</code> exposes them as its attributes of the same names as their keys.</p>
<p>Arbitrary values can be passed in <code>node_params</code> which is a <code>dict</code> </p>
<p>Following code shows the example passing a parameter to a <em>serializer</em> .</p>
<pre><code class="language-python">cxt = SerializationContext(
    dict(
        a = S.each(lambda cxt: cxt.value*c.params.value),
    ),
    finder,
    dict(a={&quot;value&quot;: 10})
)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>settings</code></strong></dt>
<dd>Mapping of node name to <code><a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></code> .</dd>
<dt><strong><code>finder</code></strong></dt>
<dd>A function to find base <em>serializer</em> s by a <code>type</code> .</dd>
<dt><strong><code>node_params</code></strong></dt>
<dd>Arbitrary parameters passed to <em>serializer</em>s.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SerializationContext:
    &#34;&#34;&#34;
    This class implements actual serialization flow applied to a graph.

    `node_params` is a `dict` whose values will be passed to *serializer* via `params` attribute of `NodeContext` .
    The property name of the node is used to get values (also a `dict` ) from the `dict`
    and the `params` exposes them as its attributes of the same names as their keys.

    Arbitrary values can be passed in `node_params` which is a `dict` 

    Following code shows the example passing a parameter to a *serializer* .

    ```python
    cxt = SerializationContext(
        dict(
            a = S.each(lambda cxt: cxt.value*c.params.value),
        ),
        finder,
        dict(a={&#34;value&#34;: 10})
    )
    ```

    Args:
        settings: Mapping of node name to `NodeSerializer` .
        finder: A function to find base *serializer* s by a `type` .
        node_params: Arbitrary parameters passed to *serializer*s.
    &#34;&#34;&#34;
    def __init__(
        self,
        settings: dict[str, NodeSerializer],
        finder: Callable[[type], list[Serializer]],
        node_params: Optional[dict[str, dict[str, Any]]] = None,
    ):
        self.settings: dict[str, NodeSerializer] = settings
        self.finder: Callable[[type], list[Serializer]] = finder
        self._node_params: dict[str, dict[str, Any]] = node_params or {}
        self._context_factories: dict[str, NodeContextFactory] = {}

    def __getitem__(self, node: Union[Node, str]) -&gt; Any:
        &#34;&#34;&#34;
        Returns an accessor to parameters for given node.

        Args:
            node: Node or node name.
        Returns:
            An object exposing parameters for the node as attributes.
        &#34;&#34;&#34;
        name = node.name if isinstance(node, Node) else node
        params = self._node_params.get(name, {})

        class Accessor:
            def __getattr__(self, key):
                return params.get(key, None)

        return Accessor()

    def execute(self, graph: GraphView) -&gt; dict[str, Any]:
        &#34;&#34;&#34;
        Serializes a graph.

        Args:
            graph: The view of graph to serialize.
        Returns:
            Serialization result.
        &#34;&#34;&#34;
        result = {}
        for c in graph().roots:
            self.serialize_to(c.name, c, result)
        return result

    def serialize_to(self, name: str, container: Union[NodeContainer, Node.Children], parent: dict[str, Any]) -&gt; None:
        &#34;&#34;&#34;
        Serialize nodes and appends them into the dictionary.

        Args:
            name: Name of the template property associated with the nodes.
            container: Container of nodes. 
            parent: A parent dictionary to which serialized values will be appended.
        &#34;&#34;&#34;
        ns = self.settings.get(name, None)

        if not ns:
            # Nodes whose names are not supplied to settings are not serialized.
            return

        # First, aggregate nodes into its subset or a single node.
        nodes: Union[list[Node], Node, Any] = ns.aggregator(container.nodes)

        if ns.be_singular:
            if isinstance(nodes, list):
                raise ValueError(f&#34;Aggregation function is marked to create a single value but returns node list.&#34;)

            # Alternative value given to aggregation function may be returned instead of node.
            value = self._serialize_node(nodes, ns) if isinstance(nodes, Node) else nodes

            if ns.be_merged:
                if value is None:
                    # When empty, no key-value pair is added to parent.
                    return
                elif not isinstance(value, dict):
                    raise ValueError(f&#34;Serialized value must be dict but {type(value)}.&#34;)

                parent.update({ns.namer(k):v for k, v in value.items()})
            else:
                parent[ns.namer(name)] = value
        else:
            if not isinstance(nodes, list):
                raise ValueError(f&#34;Aggregation function is marked to return node list but returns a single value.&#34;)
            if ns.be_merged:
                raise ValueError(f&#34;Merging to parent dict requires folding.&#34;)

            parent[ns.namer(name)] = [self._serialize_node(n, ns) for n in nodes]

    def _find_serializer(self, prop: GraphTemplate.Property) -&gt; list[Serializer]:
        return self.finder(prop.kind) if isinstance(prop.kind, type) else []

    def _serialize_node(self, node: Node, node_serializer: NodeSerializer):
        if not node.prop.name in self._context_factories:
            self._context_factories[node.prop.name] = NodeContextFactory(
                self,
                self._find_serializer(node.prop),
                self._node_params.get(node.prop.name, {}),
            )

        factory = self._context_factories[node.prop.name]

        with factory.begin(node, node_serializer._serializers) as cxt:
            value = cxt.serialize()

            # Child nodes are serialized only when the parent node is serialized into a dict.
            if isinstance(value, dict):
                for n, ch in node.children.items():
                    self.serialize_to(n, ch, value)

            return value</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.serialize.SerializationContext.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, graph: <a title="pyracmon.graph.graph.GraphView" href="graph.html#pyracmon.graph.graph.GraphView">GraphView</a>) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Serializes a graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>The view of graph to serialize.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Serialization result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, graph: GraphView) -&gt; dict[str, Any]:
    &#34;&#34;&#34;
    Serializes a graph.

    Args:
        graph: The view of graph to serialize.
    Returns:
        Serialization result.
    &#34;&#34;&#34;
    result = {}
    for c in graph().roots:
        self.serialize_to(c.name, c, result)
    return result</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.serialize.SerializationContext.serialize_to"><code class="name flex">
<span>def <span class="ident">serialize_to</span></span>(<span>self, name: str, container: Union[<a title="pyracmon.graph.graph.NodeContainer" href="graph.html#pyracmon.graph.graph.NodeContainer">NodeContainer</a>, <a title="pyracmon.graph.graph.Node.Children" href="graph.html#pyracmon.graph.graph.Node.Children">Node.Children</a>], parent: dict[str, typing.Any]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize nodes and appends them into the dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the template property associated with the nodes.</dd>
<dt><strong><code>container</code></strong></dt>
<dd>Container of nodes. </dd>
<dt><strong><code>parent</code></strong></dt>
<dd>A parent dictionary to which serialized values will be appended.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize_to(self, name: str, container: Union[NodeContainer, Node.Children], parent: dict[str, Any]) -&gt; None:
    &#34;&#34;&#34;
    Serialize nodes and appends them into the dictionary.

    Args:
        name: Name of the template property associated with the nodes.
        container: Container of nodes. 
        parent: A parent dictionary to which serialized values will be appended.
    &#34;&#34;&#34;
    ns = self.settings.get(name, None)

    if not ns:
        # Nodes whose names are not supplied to settings are not serialized.
        return

    # First, aggregate nodes into its subset or a single node.
    nodes: Union[list[Node], Node, Any] = ns.aggregator(container.nodes)

    if ns.be_singular:
        if isinstance(nodes, list):
            raise ValueError(f&#34;Aggregation function is marked to create a single value but returns node list.&#34;)

        # Alternative value given to aggregation function may be returned instead of node.
        value = self._serialize_node(nodes, ns) if isinstance(nodes, Node) else nodes

        if ns.be_merged:
            if value is None:
                # When empty, no key-value pair is added to parent.
                return
            elif not isinstance(value, dict):
                raise ValueError(f&#34;Serialized value must be dict but {type(value)}.&#34;)

            parent.update({ns.namer(k):v for k, v in value.items()})
        else:
            parent[ns.namer(name)] = value
    else:
        if not isinstance(nodes, list):
            raise ValueError(f&#34;Aggregation function is marked to return node list but returns a single value.&#34;)
        if ns.be_merged:
            raise ValueError(f&#34;Merging to parent dict requires folding.&#34;)

        parent[ns.namer(name)] = [self._serialize_node(n, ns) for n in nodes]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.graph.serialize.SerializerMeta"><code class="flex name class">
<span>class <span class="ident">SerializerMeta</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SerializerMeta(NodeSerializing, type): # type: ignore
    @classmethod
    def __prepare__(cls, __name: str, __bases: tuple[type, ...], **kwds: Any) -&gt; Mapping[str, object]:
        def wrap(n, f):
            def g(*args, **kwargs):
                ns = NodeSerializer()
                nf = getattr(ns, n)
                return nf(*args, **kwargs)
            return g
        return {n: wrap(n, f) for n, f in getmembers(NodeSerializing, isfunction) if not n.startswith(&#34;__&#34;)}</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.graph.serialize.NodeSerializing" href="#pyracmon.graph.serialize.NodeSerializing">NodeSerializing</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
<li>builtins.type</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyracmon.graph" href="index.html">pyracmon.graph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyracmon.graph.serialize.chain_serializers" href="#pyracmon.graph.serialize.chain_serializers">chain_serializers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyracmon.graph.serialize.NodeContext" href="#pyracmon.graph.serialize.NodeContext">NodeContext</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.graph.serialize.NodeContext.context" href="#pyracmon.graph.serialize.NodeContext.context">context</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeContext.node" href="#pyracmon.graph.serialize.NodeContext.node">node</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeContext.params" href="#pyracmon.graph.serialize.NodeContext.params">params</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeContext.serialize" href="#pyracmon.graph.serialize.NodeContext.serialize">serialize</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeContext.value" href="#pyracmon.graph.serialize.NodeContext.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.serialize.NodeContextFactory" href="#pyracmon.graph.serialize.NodeContextFactory">NodeContextFactory</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.graph.serialize.NodeContextFactory.begin" href="#pyracmon.graph.serialize.NodeContextFactory.begin">begin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.serialize.NodeParams" href="#pyracmon.graph.serialize.NodeParams">NodeParams</a></code></h4>
</li>
<li>
<h4><code><a title="pyracmon.graph.serialize.NodeSerializer" href="#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.aggregator" href="#pyracmon.graph.serialize.NodeSerializer.aggregator">aggregator</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.alter" href="#pyracmon.graph.serialize.NodeSerializer.alter">alter</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.at" href="#pyracmon.graph.serialize.NodeSerializer.at">at</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.be_merged" href="#pyracmon.graph.serialize.NodeSerializer.be_merged">be_merged</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.be_singular" href="#pyracmon.graph.serialize.NodeSerializer.be_singular">be_singular</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.doc" href="#pyracmon.graph.serialize.NodeSerializer.doc">doc</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.each" href="#pyracmon.graph.serialize.NodeSerializer.each">each</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.fold" href="#pyracmon.graph.serialize.NodeSerializer.fold">fold</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.head" href="#pyracmon.graph.serialize.NodeSerializer.head">head</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.last" href="#pyracmon.graph.serialize.NodeSerializer.last">last</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.merge" href="#pyracmon.graph.serialize.NodeSerializer.merge">merge</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.name" href="#pyracmon.graph.serialize.NodeSerializer.name">name</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.namer" href="#pyracmon.graph.serialize.NodeSerializer.namer">namer</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.select" href="#pyracmon.graph.serialize.NodeSerializer.select">select</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.serializer" href="#pyracmon.graph.serialize.NodeSerializer.serializer">serializer</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializer.sub" href="#pyracmon.graph.serialize.NodeSerializer.sub">sub</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.serialize.NodeSerializing" href="#pyracmon.graph.serialize.NodeSerializing">NodeSerializing</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.graph.serialize.NodeSerializing.alter" href="#pyracmon.graph.serialize.NodeSerializing.alter">alter</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializing.at" href="#pyracmon.graph.serialize.NodeSerializing.at">at</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializing.doc" href="#pyracmon.graph.serialize.NodeSerializing.doc">doc</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializing.each" href="#pyracmon.graph.serialize.NodeSerializing.each">each</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializing.fold" href="#pyracmon.graph.serialize.NodeSerializing.fold">fold</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializing.head" href="#pyracmon.graph.serialize.NodeSerializing.head">head</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializing.last" href="#pyracmon.graph.serialize.NodeSerializing.last">last</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializing.merge" href="#pyracmon.graph.serialize.NodeSerializing.merge">merge</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializing.name" href="#pyracmon.graph.serialize.NodeSerializing.name">name</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializing.select" href="#pyracmon.graph.serialize.NodeSerializing.select">select</a></code></li>
<li><code><a title="pyracmon.graph.serialize.NodeSerializing.sub" href="#pyracmon.graph.serialize.NodeSerializing.sub">sub</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.serialize.S" href="#pyracmon.graph.serialize.S">S</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.graph.serialize.S.alter" href="#pyracmon.graph.serialize.S.alter">alter</a></code></li>
<li><code><a title="pyracmon.graph.serialize.S.at" href="#pyracmon.graph.serialize.S.at">at</a></code></li>
<li><code><a title="pyracmon.graph.serialize.S.doc" href="#pyracmon.graph.serialize.S.doc">doc</a></code></li>
<li><code><a title="pyracmon.graph.serialize.S.each" href="#pyracmon.graph.serialize.S.each">each</a></code></li>
<li><code><a title="pyracmon.graph.serialize.S.fold" href="#pyracmon.graph.serialize.S.fold">fold</a></code></li>
<li><code><a title="pyracmon.graph.serialize.S.head" href="#pyracmon.graph.serialize.S.head">head</a></code></li>
<li><code><a title="pyracmon.graph.serialize.S.last" href="#pyracmon.graph.serialize.S.last">last</a></code></li>
<li><code><a title="pyracmon.graph.serialize.S.merge" href="#pyracmon.graph.serialize.S.merge">merge</a></code></li>
<li><code><a title="pyracmon.graph.serialize.S.name" href="#pyracmon.graph.serialize.S.name">name</a></code></li>
<li><code><a title="pyracmon.graph.serialize.S.of" href="#pyracmon.graph.serialize.S.of">of</a></code></li>
<li><code><a title="pyracmon.graph.serialize.S.select" href="#pyracmon.graph.serialize.S.select">select</a></code></li>
<li><code><a title="pyracmon.graph.serialize.S.sub" href="#pyracmon.graph.serialize.S.sub">sub</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.serialize.SerializationContext" href="#pyracmon.graph.serialize.SerializationContext">SerializationContext</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.graph.serialize.SerializationContext.execute" href="#pyracmon.graph.serialize.SerializationContext.execute">execute</a></code></li>
<li><code><a title="pyracmon.graph.serialize.SerializationContext.serialize_to" href="#pyracmon.graph.serialize.SerializationContext.serialize_to">serialize_to</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.serialize.SerializerMeta" href="#pyracmon.graph.serialize.SerializerMeta">SerializerMeta</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>