<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyracmon.graph.typing API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyracmon.graph.typing</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from dataclasses import is_dataclass, fields
from inspect import Signature
from typing import Any, TypeVar, Generic, Optional, TypedDict, Annotated, Union, get_args, get_origin, get_type_hints, cast
try:
    from typing import is_typeddict
except:
    from typing_extensions import is_typeddict
try:
    # &gt; python3.10
    from types import UnionType
except:
    UnionType = None


T = TypeVar(&#39;T&#39;)


def issubgeneric(t: Any, p: type) -&gt; bool:
    &#34;&#34;&#34;
    Checks whether a type is subclass of a generic type.

    Args:
        t: A type to check.
        p: A generic type.
    Returns:
        Whether the type in subclass of the generic type.
    &#34;&#34;&#34;
    if type(t) is type:
        return issubclass(t, p)
    else:
        origin = get_origin(t)
        return isinstance(origin, type) and issubclass(origin, p)


def issubtype(t: type, p: type) -&gt; bool:
    &#34;&#34;&#34;
    Checks whether a type is subclass of another type.

    Args:
        t: A type to check.
        p: Another type.
    Returns:
        Whether the type in subclass of another type.
    &#34;&#34;&#34;
    if is_typeddict(p):
        return is_typeddict(t) and set(t.__annotations__.items()) &gt;= set(p.__annotations__.items())
    else:
        return issubclass(t, p)


def is_optional(t: Any) -&gt; Optional[Any]:
    &#34;&#34;&#34;
    Checks if the given annotation corresponds to an optional type and returns the inner type.

    Args:
        t: Annotation value.
    Returns:
        Optional type if the annotation is optional, otherwise `None` .
    &#34;&#34;&#34;
    org = get_origin(t)

    if org == Optional:
        return get_args(t)[0]
    elif org == Union or org == UnionType:
        args = get_args(t)
        return args[0] if len(args) == 2 and args[1] == type(None) else None
    else:
        return None


def replace_optional_typevar(t: Any, actual: Any) -&gt; Any:
    &#34;&#34;&#34;
    Replaces the first type variable in annotation value with actual type.

    This function is designed to deal with only optional types whose inner structure depends on python version and code style.

    Args:
        t: Annotation value.
    Returns:
        Annotation value with replaced type variable.
    &#34;&#34;&#34;
    if t == Signature.empty or isinstance(t, TypeVar):
        return actual

    org = get_origin(t)
    args = get_args(t)

    def replace(gen: Any, targs: list[Any]) -&gt; Any:
        var_found = False
        rargs: list[Any] = []

        for a in targs:
            if not var_found and isinstance(a, TypeVar):
                var_found = True
                rargs.append(replace_optional_typevar(a, actual))
            else:
                rargs.append(a)

        if get_origin(rargs[0]) == Annotated:
            # Move Annotated to the outermost.
            # Optional[Annotated[int, &#34;ann&#34;]] -&gt; Annotated[Optional[int], &#34;ann&#34;]
            # Union[Annotated[int, &#34;ann&#34;], None] -&gt; Annotated[Union[int, None], &#34;ann&#34;]
            ann_args = get_args(rargs[0])
            res = Annotated[replace(gen, [ann_args[0]] + rargs[1:]), ann_args[1]]
            for a in ann_args[2:]:
                res = Annotated[res, a]
        elif len(rargs) == 1:
            res = gen[rargs[0]]
        else:
            res = gen[rargs[0], rargs[1]]
            for a in rargs[2:]:
                res = gen[res, a]

        return res

    if org == Optional:
        return Optional[replace_optional_typevar(args[0], actual)]
    elif org == Union or org == UnionType:
        return replace(Union, list(args))
    elif org == Annotated:
        return replace(Annotated, list(args))
    else:
        return t


def to_typeddict(t: Any, strict: bool) -&gt; type[TypedDict]:
    &#34;&#34;&#34;
    Convert an annotation `t` into `TypedDict` type.

    Args:
        t: Any kind of annotation.
        strict: If `True` , `TypeError` will be raised when `t` is neither a `TypeDict` nor a dataclass.
    Returns:
        `TypedDict` type which represents `t` .
    &#34;&#34;&#34;
    if is_typeddict(t):
        return t
    elif is_dataclass(t):
        return TypedDict(t.__name__, {f.name:f.type for f in fields(t)}) # type: ignore
    else:
        if strict:
            raise TypeError(f&#34;Type parameter must be resolved to TypedDict but {t}.&#34;)
        else:
            return TypedDict


def to_rawdict(v: Any, strict: bool) -&gt; dict:
    &#34;&#34;&#34;
    Convert a value into builtin `dict` .

    Args:
        v: Any value.
        strict: If `True` , `TypeError` will be raised when `v` is an instance of neither a `dict` nor a dataclass.
    Returns:
        Converted `dict` .
    &#34;&#34;&#34;
    if isinstance(v, dict):
        return v
    elif is_dataclass(v):
        return {f.name:getattr(v, f.name) for f in fields(v)}
    else:
        if strict:
            raise TypeError(f&#34;The value must be a dict or dataclass instance but {type(v)}.&#34;)
        else:
            return {}


def generate_schema(annotations: dict[str, Any], base: Optional[type[TypedDict]] = None) -&gt; type[TypedDict]:
    &#34;&#34;&#34;
    Generate schema as `TypedDict` by extending base schema.

    Args:
        annotations: Annotations to be set to new schema.
        base: Base schema if necessary.
    Returns:
        Generated schema.
    &#34;&#34;&#34;
    class Schema(base or TypedDict):
        pass

    # In python3.6, &#34;__annotations__&#34; does not exist in &#34;__dict__&#34;
    # In python3.8, it exists even the class does not have any field.
    if &#34;__annotations__&#34; not in Schema.__dict__:
        setattr(Schema, &#34;__annotations__&#34;, annotations)
    else:
        Schema.__annotations__.update(**annotations)

    return Schema


class Typeable(Generic[T]):
    &#34;&#34;&#34;
    An interface for generic type which is resolved into a concrete type by a type parameter.

    Inherit this class and declare static method whose signature is `resolve(me, bound, arg, spec) -&gt; type`.

    ```python
    &gt;&gt;&gt; class A(Typeable[T]):
    &gt;&gt;&gt;     @staticmethod
    &gt;&gt;&gt;     def resolve(me, bound, arg, spec):
    &gt;&gt;&gt;         ...
    &gt;&gt;&gt;         return some_type
    &gt;&gt;&gt;
    &gt;&gt;&gt; Typeable.resolve(A[T], int, spec)
    ```

    Type resolution starts from `Typeable.resolve` which invokes the static method with following arguments.

    - Type to resolve itself, in this case, `A[T]`.
    - A resolved type which replace `T`.
        - `arg` is the first candidate.
        - When `arg` is also `Typeable` , this resolution flow is applied to it recursively until concrete type if determined.
    - `arg` is passed through as it is.
    - `spec` is passed through as it is.
    &#34;&#34;&#34;
    @staticmethod
    def resolve(typeable, arg: type, spec: Any) -&gt; type:
        &#34;&#34;&#34;
        Resolve a `Typeable` type into a concrete type by a type for its type parameter.

        Args:
            typeable: `Typeable` type having a generic type parameter.
            arg: Type to replace a type parameter.
            spec: An object containing information for schema generation.
        Returns:
            Resolved type.
        &#34;&#34;&#34;
        if get_origin(typeable) is Typeable:
            raise ValueError(f&#34;Typeable should not be used directly. Use inheriting class instead.&#34;)

        bound = get_args(typeable)[0]

        if isinstance(bound, TypeVar):
            return Typeable.resolve(typeable[arg], arg, spec)
        elif issubgeneric(bound, Typeable):
            bound = Typeable.resolve(bound, arg, spec)
            return typeable.resolve(typeable, bound, arg, spec)
        else:
            return typeable.resolve(typeable, bound, arg, spec)

    @staticmethod
    def is_resolved(typeable: type[&#39;Typeable&#39;]) -&gt; bool:
        &#34;&#34;&#34;
        Checks a type parameter of given `Typeable` is alredy resolved.

        Args:
            typeable: `Typeable` type having a generic type parameter.
        Returns:
            Whether the type parameter is already resolved or not.
        &#34;&#34;&#34;
        bound = get_args(typeable)[0]
        if isinstance(bound, TypeVar):
            return False
        elif issubgeneric(bound, Typeable):
            return Typeable.is_resolved(bound)
        else:
            return True


class DynamicType(Typeable[T]):
    &#34;&#34;&#34;
    A `Typeable` type which can be resolved dynamically with resolved type parameter.
    &#34;&#34;&#34;
    @staticmethod
    def resolve(dynamic: type[&#39;DynamicType&#39;], bound: type, arg: type, spec: Any) -&gt; type:
        return dynamic.fix(bound, arg)

    @classmethod
    def fix(cls, bound: type, arg: type) -&gt; type:
        &#34;&#34;&#34;
        Resolve a resolved type into another type.

        Override this method to apply specific logic of the inheriting type to resolved type.
        ex) Convert resolved model type into `TypedDict` for serialization.

        Args:
            bound: Resolved type of `T`.
            arg: A type used for the resolution of `bound`.
        Returns:
            Another type.
        &#34;&#34;&#34;
        return bound


class Shrink(Typeable[T]):
    &#34;&#34;&#34;
    A type to remove keys from `TypedDict` bound to the type parameter `T`.

    This class only works when `TypedDict` parameter is set, otherwise `TypeError` is raised.
    &#34;&#34;&#34;
    @staticmethod
    def resolve(shrink: type[&#39;Shrink&#39;], bound: Union[type[TypedDict], Signature], arg: type, spec: Any) -&gt; type:
        &#34;&#34;&#34;
        Resolve a `TypedDict` into another `TypedDict` by removing some keys defined by `select` .
        &#34;&#34;&#34;
        if bound == Signature.empty:
            return TypedDict

        bound = to_typeddict(bound, True)

        exc, inc = shrink.select(bound, arg)
        annotations = {n:t for n, t in get_type_hints(bound, include_extras=True).items() if (not inc or n in inc) and (n not in exc)}

        return generate_schema(annotations)

    @classmethod
    def select(cls, bound: type[TypedDict], arg: type) -&gt; tuple[list[str], list[str]]:
        &#34;&#34;&#34;
        Select excluding and including keys from `TypedDict`.

        Subclass should consider the case when the `bound` is `Signautre.empty`.

        This method should return excluding and including keys.
        Excluding key is always excluded if it is contained in including keys.
        Empty including keys specify that all keys are used.

        Args:
            bound: `TypedDict` to be shrinked.
            arg: A type used for the resolution of `bound`.
        Returns:
            Keys to exclude and include.
        &#34;&#34;&#34;
        raise NotImplementedError()


class Extend(Typeable[T]):
    &#34;&#34;&#34;
    A type to add keys to `TypedDict` bound to the type parameter `T`.

    This class only works when `TypedDict` parameter is set, otherwise `TypeError` is raised.
    &#34;&#34;&#34;
    @staticmethod
    def resolve(extend: type[&#39;Extend&#39;], bound: Union[type[TypedDict], Signature], arg: type, spec: Any) -&gt; type:
        &#34;&#34;&#34;
        Resolve a `TypedDict` into another `TypedDict` by adding some keys retrieved by `schema` .
        &#34;&#34;&#34;
        if bound == Signature.empty:
            return TypedDict

        bound = to_typeddict(bound, True)

        ext = extend.schema(bound, arg)
        td = to_typeddict(ext, False)

        return generate_schema(td.__annotations__, bound)

    @classmethod
    def schema(cls, bound: type[TypedDict], arg: type) -&gt; Any:
        &#34;&#34;&#34;
        Creates a `TypedDict` representing a schema of adding keys and their types.

        Subclass should consider the case when the `bound` is `Signautre.empty`.

        Args:
            bound: `TypedDict` to be extended.
            arg: A type used for the resolution of `bound`.
        Returns:
            `TypedDict` extending schema of base `TypedDict` .
        &#34;&#34;&#34;
        raise NotImplementedError()


def document_type(t: type, doc: str) -&gt; Annotated:
    &#34;&#34;&#34;
    Supplies a document to a type.

    Args:
        t: A type.
        doc: A document.
    Returns:
        Documented type.
    &#34;&#34;&#34;
    return Annotated[t, doc]


def decompose_document(t: type) -&gt; tuple[type, str]:
    if get_origin(t) == Annotated:
        args = get_args(t)
        # Annotated must have at least 2 arguments.
        # Last annotated string is used as document.
        t, d = args[0], args[-1]
        return t, d if isinstance(d, str) else d.__doc__
    else:
        return t, &#34;&#34;


def walk_schema(td, with_doc=False) -&gt; dict[str, Union[type, Annotated]]:
    &#34;&#34;&#34;
    Returns a dictionary as a result of walking a schema object from its root.

    Args:
        td: A schema represented by `TypedDict`.
        with_doc: Flag to include documentations into result.
    Returns:
        Key value representation of the schema. If `with_doc` is `True`, each value is `Annotated`.
    &#34;&#34;&#34;
    if &#39;__annotations__&#39; not in td.__dict__:
        return {}

    result = {}

    def put(k, t, doc):
        if with_doc:
            result[k] = (t, doc)
        else:
            result[k] = t

    def expand(t):
        return (get_args(t)[0], lambda x:[x]) if issubgeneric(t, list) else (t, lambda x:x)

    for k, t in get_type_hints(td, include_extras=True).items():
        t, doc = decompose_document(t)

        t, conv = expand(t)

        opt_type = is_optional(t)

        if is_typeddict(t):
            put(k, conv(walk_schema(t, with_doc)), doc)
        elif opt_type is not None and is_typeddict(opt_type):
            put(k, conv(walk_schema(opt_type, with_doc)), doc)
        else:
            put(k, conv(t), doc)
    
    return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyracmon.graph.typing.decompose_document"><code class="name flex">
<span>def <span class="ident">decompose_document</span></span>(<span>t: type) ‑> tuple[type, str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decompose_document(t: type) -&gt; tuple[type, str]:
    if get_origin(t) == Annotated:
        args = get_args(t)
        # Annotated must have at least 2 arguments.
        # Last annotated string is used as document.
        t, d = args[0], args[-1]
        return t, d if isinstance(d, str) else d.__doc__
    else:
        return t, &#34;&#34;</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.typing.document_type"><code class="name flex">
<span>def <span class="ident">document_type</span></span>(<span>t: type, doc: str) ‑> <class 'Annotated'></span>
</code></dt>
<dd>
<div class="desc"><p>Supplies a document to a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>A type.</dd>
<dt><strong><code>doc</code></strong></dt>
<dd>A document.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Documented type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def document_type(t: type, doc: str) -&gt; Annotated:
    &#34;&#34;&#34;
    Supplies a document to a type.

    Args:
        t: A type.
        doc: A document.
    Returns:
        Documented type.
    &#34;&#34;&#34;
    return Annotated[t, doc]</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.typing.generate_schema"><code class="name flex">
<span>def <span class="ident">generate_schema</span></span>(<span>annotations: dict[str, typing.Any], base: Optional[type[typing.TypedDict]] = None) ‑> type[typing.TypedDict]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate schema as <code>TypedDict</code> by extending base schema.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>annotations</code></strong></dt>
<dd>Annotations to be set to new schema.</dd>
<dt><strong><code>base</code></strong></dt>
<dd>Base schema if necessary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Generated schema.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_schema(annotations: dict[str, Any], base: Optional[type[TypedDict]] = None) -&gt; type[TypedDict]:
    &#34;&#34;&#34;
    Generate schema as `TypedDict` by extending base schema.

    Args:
        annotations: Annotations to be set to new schema.
        base: Base schema if necessary.
    Returns:
        Generated schema.
    &#34;&#34;&#34;
    class Schema(base or TypedDict):
        pass

    # In python3.6, &#34;__annotations__&#34; does not exist in &#34;__dict__&#34;
    # In python3.8, it exists even the class does not have any field.
    if &#34;__annotations__&#34; not in Schema.__dict__:
        setattr(Schema, &#34;__annotations__&#34;, annotations)
    else:
        Schema.__annotations__.update(**annotations)

    return Schema</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.typing.is_optional"><code class="name flex">
<span>def <span class="ident">is_optional</span></span>(<span>t: Any) ‑> Optional[Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the given annotation corresponds to an optional type and returns the inner type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Annotation value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Optional type if the annotation is optional, otherwise <code>None</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_optional(t: Any) -&gt; Optional[Any]:
    &#34;&#34;&#34;
    Checks if the given annotation corresponds to an optional type and returns the inner type.

    Args:
        t: Annotation value.
    Returns:
        Optional type if the annotation is optional, otherwise `None` .
    &#34;&#34;&#34;
    org = get_origin(t)

    if org == Optional:
        return get_args(t)[0]
    elif org == Union or org == UnionType:
        args = get_args(t)
        return args[0] if len(args) == 2 and args[1] == type(None) else None
    else:
        return None</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.typing.issubgeneric"><code class="name flex">
<span>def <span class="ident">issubgeneric</span></span>(<span>t: Any, p: type) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether a type is subclass of a generic type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>A type to check.</dd>
<dt><strong><code>p</code></strong></dt>
<dd>A generic type.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the type in subclass of the generic type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def issubgeneric(t: Any, p: type) -&gt; bool:
    &#34;&#34;&#34;
    Checks whether a type is subclass of a generic type.

    Args:
        t: A type to check.
        p: A generic type.
    Returns:
        Whether the type in subclass of the generic type.
    &#34;&#34;&#34;
    if type(t) is type:
        return issubclass(t, p)
    else:
        origin = get_origin(t)
        return isinstance(origin, type) and issubclass(origin, p)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.typing.issubtype"><code class="name flex">
<span>def <span class="ident">issubtype</span></span>(<span>t: type, p: type) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether a type is subclass of another type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>A type to check.</dd>
<dt><strong><code>p</code></strong></dt>
<dd>Another type.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the type in subclass of another type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def issubtype(t: type, p: type) -&gt; bool:
    &#34;&#34;&#34;
    Checks whether a type is subclass of another type.

    Args:
        t: A type to check.
        p: Another type.
    Returns:
        Whether the type in subclass of another type.
    &#34;&#34;&#34;
    if is_typeddict(p):
        return is_typeddict(t) and set(t.__annotations__.items()) &gt;= set(p.__annotations__.items())
    else:
        return issubclass(t, p)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.typing.replace_optional_typevar"><code class="name flex">
<span>def <span class="ident">replace_optional_typevar</span></span>(<span>t: Any, actual: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Replaces the first type variable in annotation value with actual type.</p>
<p>This function is designed to deal with only optional types whose inner structure depends on python version and code style.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Annotation value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Annotation value with replaced type variable.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace_optional_typevar(t: Any, actual: Any) -&gt; Any:
    &#34;&#34;&#34;
    Replaces the first type variable in annotation value with actual type.

    This function is designed to deal with only optional types whose inner structure depends on python version and code style.

    Args:
        t: Annotation value.
    Returns:
        Annotation value with replaced type variable.
    &#34;&#34;&#34;
    if t == Signature.empty or isinstance(t, TypeVar):
        return actual

    org = get_origin(t)
    args = get_args(t)

    def replace(gen: Any, targs: list[Any]) -&gt; Any:
        var_found = False
        rargs: list[Any] = []

        for a in targs:
            if not var_found and isinstance(a, TypeVar):
                var_found = True
                rargs.append(replace_optional_typevar(a, actual))
            else:
                rargs.append(a)

        if get_origin(rargs[0]) == Annotated:
            # Move Annotated to the outermost.
            # Optional[Annotated[int, &#34;ann&#34;]] -&gt; Annotated[Optional[int], &#34;ann&#34;]
            # Union[Annotated[int, &#34;ann&#34;], None] -&gt; Annotated[Union[int, None], &#34;ann&#34;]
            ann_args = get_args(rargs[0])
            res = Annotated[replace(gen, [ann_args[0]] + rargs[1:]), ann_args[1]]
            for a in ann_args[2:]:
                res = Annotated[res, a]
        elif len(rargs) == 1:
            res = gen[rargs[0]]
        else:
            res = gen[rargs[0], rargs[1]]
            for a in rargs[2:]:
                res = gen[res, a]

        return res

    if org == Optional:
        return Optional[replace_optional_typevar(args[0], actual)]
    elif org == Union or org == UnionType:
        return replace(Union, list(args))
    elif org == Annotated:
        return replace(Annotated, list(args))
    else:
        return t</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.typing.to_rawdict"><code class="name flex">
<span>def <span class="ident">to_rawdict</span></span>(<span>v: Any, strict: bool) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a value into builtin <code>dict</code> .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>v</code></strong></dt>
<dd>Any value.</dd>
<dt><strong><code>strict</code></strong></dt>
<dd>If <code>True</code> , <code>TypeError</code> will be raised when <code>v</code> is an instance of neither a <code>dict</code> nor a dataclass.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Converted <code>dict</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_rawdict(v: Any, strict: bool) -&gt; dict:
    &#34;&#34;&#34;
    Convert a value into builtin `dict` .

    Args:
        v: Any value.
        strict: If `True` , `TypeError` will be raised when `v` is an instance of neither a `dict` nor a dataclass.
    Returns:
        Converted `dict` .
    &#34;&#34;&#34;
    if isinstance(v, dict):
        return v
    elif is_dataclass(v):
        return {f.name:getattr(v, f.name) for f in fields(v)}
    else:
        if strict:
            raise TypeError(f&#34;The value must be a dict or dataclass instance but {type(v)}.&#34;)
        else:
            return {}</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.typing.to_typeddict"><code class="name flex">
<span>def <span class="ident">to_typeddict</span></span>(<span>t: Any, strict: bool) ‑> type[typing.TypedDict]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an annotation <code>t</code> into <code>TypedDict</code> type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Any kind of annotation.</dd>
<dt><strong><code>strict</code></strong></dt>
<dd>If <code>True</code> , <code>TypeError</code> will be raised when <code>t</code> is neither a <code>TypeDict</code> nor a dataclass.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>TypedDict</code> type which represents <code>t</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_typeddict(t: Any, strict: bool) -&gt; type[TypedDict]:
    &#34;&#34;&#34;
    Convert an annotation `t` into `TypedDict` type.

    Args:
        t: Any kind of annotation.
        strict: If `True` , `TypeError` will be raised when `t` is neither a `TypeDict` nor a dataclass.
    Returns:
        `TypedDict` type which represents `t` .
    &#34;&#34;&#34;
    if is_typeddict(t):
        return t
    elif is_dataclass(t):
        return TypedDict(t.__name__, {f.name:f.type for f in fields(t)}) # type: ignore
    else:
        if strict:
            raise TypeError(f&#34;Type parameter must be resolved to TypedDict but {t}.&#34;)
        else:
            return TypedDict</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.typing.walk_schema"><code class="name flex">
<span>def <span class="ident">walk_schema</span></span>(<span>td, with_doc=False) ‑> dict[str, typing.Union[type, typing.Annotated]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary as a result of walking a schema object from its root.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>td</code></strong></dt>
<dd>A schema represented by <code>TypedDict</code>.</dd>
<dt><strong><code>with_doc</code></strong></dt>
<dd>Flag to include documentations into result.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Key value representation of the schema. If <code>with_doc</code> is <code>True</code>, each value is <code>Annotated</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walk_schema(td, with_doc=False) -&gt; dict[str, Union[type, Annotated]]:
    &#34;&#34;&#34;
    Returns a dictionary as a result of walking a schema object from its root.

    Args:
        td: A schema represented by `TypedDict`.
        with_doc: Flag to include documentations into result.
    Returns:
        Key value representation of the schema. If `with_doc` is `True`, each value is `Annotated`.
    &#34;&#34;&#34;
    if &#39;__annotations__&#39; not in td.__dict__:
        return {}

    result = {}

    def put(k, t, doc):
        if with_doc:
            result[k] = (t, doc)
        else:
            result[k] = t

    def expand(t):
        return (get_args(t)[0], lambda x:[x]) if issubgeneric(t, list) else (t, lambda x:x)

    for k, t in get_type_hints(td, include_extras=True).items():
        t, doc = decompose_document(t)

        t, conv = expand(t)

        opt_type = is_optional(t)

        if is_typeddict(t):
            put(k, conv(walk_schema(t, with_doc)), doc)
        elif opt_type is not None and is_typeddict(opt_type):
            put(k, conv(walk_schema(opt_type, with_doc)), doc)
        else:
            put(k, conv(t), doc)
    
    return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyracmon.graph.typing.DynamicType"><code class="flex name class">
<span>class <span class="ident">DynamicType</span></span>
</code></dt>
<dd>
<div class="desc"><p>A <code><a title="pyracmon.graph.typing.Typeable" href="#pyracmon.graph.typing.Typeable">Typeable</a></code> type which can be resolved dynamically with resolved type parameter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DynamicType(Typeable[T]):
    &#34;&#34;&#34;
    A `Typeable` type which can be resolved dynamically with resolved type parameter.
    &#34;&#34;&#34;
    @staticmethod
    def resolve(dynamic: type[&#39;DynamicType&#39;], bound: type, arg: type, spec: Any) -&gt; type:
        return dynamic.fix(bound, arg)

    @classmethod
    def fix(cls, bound: type, arg: type) -&gt; type:
        &#34;&#34;&#34;
        Resolve a resolved type into another type.

        Override this method to apply specific logic of the inheriting type to resolved type.
        ex) Convert resolved model type into `TypedDict` for serialization.

        Args:
            bound: Resolved type of `T`.
            arg: A type used for the resolution of `bound`.
        Returns:
            Another type.
        &#34;&#34;&#34;
        return bound</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.graph.typing.Typeable" href="#pyracmon.graph.typing.Typeable">Typeable</a></li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.model_graph.ModelSchema" href="../model_graph.html#pyracmon.model_graph.ModelSchema">ModelSchema</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.graph.typing.DynamicType.fix"><code class="name flex">
<span>def <span class="ident">fix</span></span>(<span>bound: type, arg: type) ‑> type</span>
</code></dt>
<dd>
<div class="desc"><p>Resolve a resolved type into another type.</p>
<p>Override this method to apply specific logic of the inheriting type to resolved type.
ex) Convert resolved model type into <code>TypedDict</code> for serialization.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bound</code></strong></dt>
<dd>Resolved type of <code>T</code>.</dd>
<dt><strong><code>arg</code></strong></dt>
<dd>A type used for the resolution of <code>bound</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Another type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fix(cls, bound: type, arg: type) -&gt; type:
    &#34;&#34;&#34;
    Resolve a resolved type into another type.

    Override this method to apply specific logic of the inheriting type to resolved type.
    ex) Convert resolved model type into `TypedDict` for serialization.

    Args:
        bound: Resolved type of `T`.
        arg: A type used for the resolution of `bound`.
    Returns:
        Another type.
    &#34;&#34;&#34;
    return bound</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyracmon.graph.typing.Typeable" href="#pyracmon.graph.typing.Typeable">Typeable</a></b></code>:
<ul class="hlist">
<li><code><a title="pyracmon.graph.typing.Typeable.is_resolved" href="#pyracmon.graph.typing.Typeable.is_resolved">is_resolved</a></code></li>
<li><code><a title="pyracmon.graph.typing.Typeable.resolve" href="#pyracmon.graph.typing.Typeable.resolve">resolve</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyracmon.graph.typing.Extend"><code class="flex name class">
<span>class <span class="ident">Extend</span></span>
</code></dt>
<dd>
<div class="desc"><p>A type to add keys to <code>TypedDict</code> bound to the type parameter <code>T</code>.</p>
<p>This class only works when <code>TypedDict</code> parameter is set, otherwise <code>TypeError</code> is raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Extend(Typeable[T]):
    &#34;&#34;&#34;
    A type to add keys to `TypedDict` bound to the type parameter `T`.

    This class only works when `TypedDict` parameter is set, otherwise `TypeError` is raised.
    &#34;&#34;&#34;
    @staticmethod
    def resolve(extend: type[&#39;Extend&#39;], bound: Union[type[TypedDict], Signature], arg: type, spec: Any) -&gt; type:
        &#34;&#34;&#34;
        Resolve a `TypedDict` into another `TypedDict` by adding some keys retrieved by `schema` .
        &#34;&#34;&#34;
        if bound == Signature.empty:
            return TypedDict

        bound = to_typeddict(bound, True)

        ext = extend.schema(bound, arg)
        td = to_typeddict(ext, False)

        return generate_schema(td.__annotations__, bound)

    @classmethod
    def schema(cls, bound: type[TypedDict], arg: type) -&gt; Any:
        &#34;&#34;&#34;
        Creates a `TypedDict` representing a schema of adding keys and their types.

        Subclass should consider the case when the `bound` is `Signautre.empty`.

        Args:
            bound: `TypedDict` to be extended.
            arg: A type used for the resolution of `bound`.
        Returns:
            `TypedDict` extending schema of base `TypedDict` .
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.graph.typing.Typeable" href="#pyracmon.graph.typing.Typeable">Typeable</a></li>
<li>typing.Generic</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.graph.typing.Extend.resolve"><code class="name flex">
<span>def <span class="ident">resolve</span></span>(<span>extend: type['<a title="pyracmon.graph.typing.Extend" href="#pyracmon.graph.typing.Extend">Extend</a>'], bound: Union[type[TypedDict], inspect.Signature], arg: type, spec: Any) ‑> type</span>
</code></dt>
<dd>
<div class="desc"><p>Resolve a <code>TypedDict</code> into another <code>TypedDict</code> by adding some keys retrieved by <code>schema</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def resolve(extend: type[&#39;Extend&#39;], bound: Union[type[TypedDict], Signature], arg: type, spec: Any) -&gt; type:
    &#34;&#34;&#34;
    Resolve a `TypedDict` into another `TypedDict` by adding some keys retrieved by `schema` .
    &#34;&#34;&#34;
    if bound == Signature.empty:
        return TypedDict

    bound = to_typeddict(bound, True)

    ext = extend.schema(bound, arg)
    td = to_typeddict(ext, False)

    return generate_schema(td.__annotations__, bound)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.typing.Extend.schema"><code class="name flex">
<span>def <span class="ident">schema</span></span>(<span>bound: type[typing.TypedDict], arg: type) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a <code>TypedDict</code> representing a schema of adding keys and their types.</p>
<p>Subclass should consider the case when the <code>bound</code> is <code>Signautre.empty</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bound</code></strong></dt>
<dd><code>TypedDict</code> to be extended.</dd>
<dt><strong><code>arg</code></strong></dt>
<dd>A type used for the resolution of <code>bound</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>TypedDict</code> extending schema of base <code>TypedDict</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def schema(cls, bound: type[TypedDict], arg: type) -&gt; Any:
    &#34;&#34;&#34;
    Creates a `TypedDict` representing a schema of adding keys and their types.

    Subclass should consider the case when the `bound` is `Signautre.empty`.

    Args:
        bound: `TypedDict` to be extended.
        arg: A type used for the resolution of `bound`.
    Returns:
        `TypedDict` extending schema of base `TypedDict` .
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyracmon.graph.typing.Typeable" href="#pyracmon.graph.typing.Typeable">Typeable</a></b></code>:
<ul class="hlist">
<li><code><a title="pyracmon.graph.typing.Typeable.is_resolved" href="#pyracmon.graph.typing.Typeable.is_resolved">is_resolved</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyracmon.graph.typing.Shrink"><code class="flex name class">
<span>class <span class="ident">Shrink</span></span>
</code></dt>
<dd>
<div class="desc"><p>A type to remove keys from <code>TypedDict</code> bound to the type parameter <code>T</code>.</p>
<p>This class only works when <code>TypedDict</code> parameter is set, otherwise <code>TypeError</code> is raised.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Shrink(Typeable[T]):
    &#34;&#34;&#34;
    A type to remove keys from `TypedDict` bound to the type parameter `T`.

    This class only works when `TypedDict` parameter is set, otherwise `TypeError` is raised.
    &#34;&#34;&#34;
    @staticmethod
    def resolve(shrink: type[&#39;Shrink&#39;], bound: Union[type[TypedDict], Signature], arg: type, spec: Any) -&gt; type:
        &#34;&#34;&#34;
        Resolve a `TypedDict` into another `TypedDict` by removing some keys defined by `select` .
        &#34;&#34;&#34;
        if bound == Signature.empty:
            return TypedDict

        bound = to_typeddict(bound, True)

        exc, inc = shrink.select(bound, arg)
        annotations = {n:t for n, t in get_type_hints(bound, include_extras=True).items() if (not inc or n in inc) and (n not in exc)}

        return generate_schema(annotations)

    @classmethod
    def select(cls, bound: type[TypedDict], arg: type) -&gt; tuple[list[str], list[str]]:
        &#34;&#34;&#34;
        Select excluding and including keys from `TypedDict`.

        Subclass should consider the case when the `bound` is `Signautre.empty`.

        This method should return excluding and including keys.
        Excluding key is always excluded if it is contained in including keys.
        Empty including keys specify that all keys are used.

        Args:
            bound: `TypedDict` to be shrinked.
            arg: A type used for the resolution of `bound`.
        Returns:
            Keys to exclude and include.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.graph.typing.Typeable" href="#pyracmon.graph.typing.Typeable">Typeable</a></li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.model_graph.ExcludeFK" href="../model_graph.html#pyracmon.model_graph.ExcludeFK">ExcludeFK</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.graph.typing.Shrink.resolve"><code class="name flex">
<span>def <span class="ident">resolve</span></span>(<span>shrink: type['<a title="pyracmon.graph.typing.Shrink" href="#pyracmon.graph.typing.Shrink">Shrink</a>'], bound: Union[type[TypedDict], inspect.Signature], arg: type, spec: Any) ‑> type</span>
</code></dt>
<dd>
<div class="desc"><p>Resolve a <code>TypedDict</code> into another <code>TypedDict</code> by removing some keys defined by <code>select</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def resolve(shrink: type[&#39;Shrink&#39;], bound: Union[type[TypedDict], Signature], arg: type, spec: Any) -&gt; type:
    &#34;&#34;&#34;
    Resolve a `TypedDict` into another `TypedDict` by removing some keys defined by `select` .
    &#34;&#34;&#34;
    if bound == Signature.empty:
        return TypedDict

    bound = to_typeddict(bound, True)

    exc, inc = shrink.select(bound, arg)
    annotations = {n:t for n, t in get_type_hints(bound, include_extras=True).items() if (not inc or n in inc) and (n not in exc)}

    return generate_schema(annotations)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.typing.Shrink.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>bound: type[typing.TypedDict], arg: type) ‑> tuple[list[str], list[str]]</span>
</code></dt>
<dd>
<div class="desc"><p>Select excluding and including keys from <code>TypedDict</code>.</p>
<p>Subclass should consider the case when the <code>bound</code> is <code>Signautre.empty</code>.</p>
<p>This method should return excluding and including keys.
Excluding key is always excluded if it is contained in including keys.
Empty including keys specify that all keys are used.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bound</code></strong></dt>
<dd><code>TypedDict</code> to be shrinked.</dd>
<dt><strong><code>arg</code></strong></dt>
<dd>A type used for the resolution of <code>bound</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Keys to exclude and include.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def select(cls, bound: type[TypedDict], arg: type) -&gt; tuple[list[str], list[str]]:
    &#34;&#34;&#34;
    Select excluding and including keys from `TypedDict`.

    Subclass should consider the case when the `bound` is `Signautre.empty`.

    This method should return excluding and including keys.
    Excluding key is always excluded if it is contained in including keys.
    Empty including keys specify that all keys are used.

    Args:
        bound: `TypedDict` to be shrinked.
        arg: A type used for the resolution of `bound`.
    Returns:
        Keys to exclude and include.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyracmon.graph.typing.Typeable" href="#pyracmon.graph.typing.Typeable">Typeable</a></b></code>:
<ul class="hlist">
<li><code><a title="pyracmon.graph.typing.Typeable.is_resolved" href="#pyracmon.graph.typing.Typeable.is_resolved">is_resolved</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyracmon.graph.typing.Typeable"><code class="flex name class">
<span>class <span class="ident">Typeable</span></span>
</code></dt>
<dd>
<div class="desc"><p>An interface for generic type which is resolved into a concrete type by a type parameter.</p>
<p>Inherit this class and declare static method whose signature is <code>resolve(me, bound, arg, spec) -&gt; type</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; class A(Typeable[T]):
&gt;&gt;&gt;     @staticmethod
&gt;&gt;&gt;     def resolve(me, bound, arg, spec):
&gt;&gt;&gt;         ...
&gt;&gt;&gt;         return some_type
&gt;&gt;&gt;
&gt;&gt;&gt; Typeable.resolve(A[T], int, spec)
</code></pre>
<p>Type resolution starts from <code><a title="pyracmon.graph.typing.Typeable.resolve" href="#pyracmon.graph.typing.Typeable.resolve">Typeable.resolve()</a></code> which invokes the static method with following arguments.</p>
<ul>
<li>Type to resolve itself, in this case, <code>A[T]</code>.</li>
<li>A resolved type which replace <code>T</code>.<ul>
<li><code>arg</code> is the first candidate.</li>
<li>When <code>arg</code> is also <code><a title="pyracmon.graph.typing.Typeable" href="#pyracmon.graph.typing.Typeable">Typeable</a></code> , this resolution flow is applied to it recursively until concrete type if determined.</li>
</ul>
</li>
<li><code>arg</code> is passed through as it is.</li>
<li><code>spec</code> is passed through as it is.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Typeable(Generic[T]):
    &#34;&#34;&#34;
    An interface for generic type which is resolved into a concrete type by a type parameter.

    Inherit this class and declare static method whose signature is `resolve(me, bound, arg, spec) -&gt; type`.

    ```python
    &gt;&gt;&gt; class A(Typeable[T]):
    &gt;&gt;&gt;     @staticmethod
    &gt;&gt;&gt;     def resolve(me, bound, arg, spec):
    &gt;&gt;&gt;         ...
    &gt;&gt;&gt;         return some_type
    &gt;&gt;&gt;
    &gt;&gt;&gt; Typeable.resolve(A[T], int, spec)
    ```

    Type resolution starts from `Typeable.resolve` which invokes the static method with following arguments.

    - Type to resolve itself, in this case, `A[T]`.
    - A resolved type which replace `T`.
        - `arg` is the first candidate.
        - When `arg` is also `Typeable` , this resolution flow is applied to it recursively until concrete type if determined.
    - `arg` is passed through as it is.
    - `spec` is passed through as it is.
    &#34;&#34;&#34;
    @staticmethod
    def resolve(typeable, arg: type, spec: Any) -&gt; type:
        &#34;&#34;&#34;
        Resolve a `Typeable` type into a concrete type by a type for its type parameter.

        Args:
            typeable: `Typeable` type having a generic type parameter.
            arg: Type to replace a type parameter.
            spec: An object containing information for schema generation.
        Returns:
            Resolved type.
        &#34;&#34;&#34;
        if get_origin(typeable) is Typeable:
            raise ValueError(f&#34;Typeable should not be used directly. Use inheriting class instead.&#34;)

        bound = get_args(typeable)[0]

        if isinstance(bound, TypeVar):
            return Typeable.resolve(typeable[arg], arg, spec)
        elif issubgeneric(bound, Typeable):
            bound = Typeable.resolve(bound, arg, spec)
            return typeable.resolve(typeable, bound, arg, spec)
        else:
            return typeable.resolve(typeable, bound, arg, spec)

    @staticmethod
    def is_resolved(typeable: type[&#39;Typeable&#39;]) -&gt; bool:
        &#34;&#34;&#34;
        Checks a type parameter of given `Typeable` is alredy resolved.

        Args:
            typeable: `Typeable` type having a generic type parameter.
        Returns:
            Whether the type parameter is already resolved or not.
        &#34;&#34;&#34;
        bound = get_args(typeable)[0]
        if isinstance(bound, TypeVar):
            return False
        elif issubgeneric(bound, Typeable):
            return Typeable.is_resolved(bound)
        else:
            return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.graph.typing.DynamicType" href="#pyracmon.graph.typing.DynamicType">DynamicType</a></li>
<li><a title="pyracmon.graph.typing.Extend" href="#pyracmon.graph.typing.Extend">Extend</a></li>
<li><a title="pyracmon.graph.typing.Shrink" href="#pyracmon.graph.typing.Shrink">Shrink</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.graph.typing.Typeable.is_resolved"><code class="name flex">
<span>def <span class="ident">is_resolved</span></span>(<span>typeable: type['<a title="pyracmon.graph.typing.Typeable" href="#pyracmon.graph.typing.Typeable">Typeable</a>']) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks a type parameter of given <code><a title="pyracmon.graph.typing.Typeable" href="#pyracmon.graph.typing.Typeable">Typeable</a></code> is alredy resolved.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>typeable</code></strong></dt>
<dd><code><a title="pyracmon.graph.typing.Typeable" href="#pyracmon.graph.typing.Typeable">Typeable</a></code> type having a generic type parameter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the type parameter is already resolved or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_resolved(typeable: type[&#39;Typeable&#39;]) -&gt; bool:
    &#34;&#34;&#34;
    Checks a type parameter of given `Typeable` is alredy resolved.

    Args:
        typeable: `Typeable` type having a generic type parameter.
    Returns:
        Whether the type parameter is already resolved or not.
    &#34;&#34;&#34;
    bound = get_args(typeable)[0]
    if isinstance(bound, TypeVar):
        return False
    elif issubgeneric(bound, Typeable):
        return Typeable.is_resolved(bound)
    else:
        return True</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.typing.Typeable.resolve"><code class="name flex">
<span>def <span class="ident">resolve</span></span>(<span>typeable, arg: type, spec: Any) ‑> type</span>
</code></dt>
<dd>
<div class="desc"><p>Resolve a <code><a title="pyracmon.graph.typing.Typeable" href="#pyracmon.graph.typing.Typeable">Typeable</a></code> type into a concrete type by a type for its type parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>typeable</code></strong></dt>
<dd><code><a title="pyracmon.graph.typing.Typeable" href="#pyracmon.graph.typing.Typeable">Typeable</a></code> type having a generic type parameter.</dd>
<dt><strong><code>arg</code></strong></dt>
<dd>Type to replace a type parameter.</dd>
<dt><strong><code>spec</code></strong></dt>
<dd>An object containing information for schema generation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Resolved type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def resolve(typeable, arg: type, spec: Any) -&gt; type:
    &#34;&#34;&#34;
    Resolve a `Typeable` type into a concrete type by a type for its type parameter.

    Args:
        typeable: `Typeable` type having a generic type parameter.
        arg: Type to replace a type parameter.
        spec: An object containing information for schema generation.
    Returns:
        Resolved type.
    &#34;&#34;&#34;
    if get_origin(typeable) is Typeable:
        raise ValueError(f&#34;Typeable should not be used directly. Use inheriting class instead.&#34;)

    bound = get_args(typeable)[0]

    if isinstance(bound, TypeVar):
        return Typeable.resolve(typeable[arg], arg, spec)
    elif issubgeneric(bound, Typeable):
        bound = Typeable.resolve(bound, arg, spec)
        return typeable.resolve(typeable, bound, arg, spec)
    else:
        return typeable.resolve(typeable, bound, arg, spec)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyracmon.graph" href="index.html">pyracmon.graph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyracmon.graph.typing.decompose_document" href="#pyracmon.graph.typing.decompose_document">decompose_document</a></code></li>
<li><code><a title="pyracmon.graph.typing.document_type" href="#pyracmon.graph.typing.document_type">document_type</a></code></li>
<li><code><a title="pyracmon.graph.typing.generate_schema" href="#pyracmon.graph.typing.generate_schema">generate_schema</a></code></li>
<li><code><a title="pyracmon.graph.typing.is_optional" href="#pyracmon.graph.typing.is_optional">is_optional</a></code></li>
<li><code><a title="pyracmon.graph.typing.issubgeneric" href="#pyracmon.graph.typing.issubgeneric">issubgeneric</a></code></li>
<li><code><a title="pyracmon.graph.typing.issubtype" href="#pyracmon.graph.typing.issubtype">issubtype</a></code></li>
<li><code><a title="pyracmon.graph.typing.replace_optional_typevar" href="#pyracmon.graph.typing.replace_optional_typevar">replace_optional_typevar</a></code></li>
<li><code><a title="pyracmon.graph.typing.to_rawdict" href="#pyracmon.graph.typing.to_rawdict">to_rawdict</a></code></li>
<li><code><a title="pyracmon.graph.typing.to_typeddict" href="#pyracmon.graph.typing.to_typeddict">to_typeddict</a></code></li>
<li><code><a title="pyracmon.graph.typing.walk_schema" href="#pyracmon.graph.typing.walk_schema">walk_schema</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyracmon.graph.typing.DynamicType" href="#pyracmon.graph.typing.DynamicType">DynamicType</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.graph.typing.DynamicType.fix" href="#pyracmon.graph.typing.DynamicType.fix">fix</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.typing.Extend" href="#pyracmon.graph.typing.Extend">Extend</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.graph.typing.Extend.resolve" href="#pyracmon.graph.typing.Extend.resolve">resolve</a></code></li>
<li><code><a title="pyracmon.graph.typing.Extend.schema" href="#pyracmon.graph.typing.Extend.schema">schema</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.typing.Shrink" href="#pyracmon.graph.typing.Shrink">Shrink</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.graph.typing.Shrink.resolve" href="#pyracmon.graph.typing.Shrink.resolve">resolve</a></code></li>
<li><code><a title="pyracmon.graph.typing.Shrink.select" href="#pyracmon.graph.typing.Shrink.select">select</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.typing.Typeable" href="#pyracmon.graph.typing.Typeable">Typeable</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.graph.typing.Typeable.is_resolved" href="#pyracmon.graph.typing.Typeable.is_resolved">is_resolved</a></code></li>
<li><code><a title="pyracmon.graph.typing.Typeable.resolve" href="#pyracmon.graph.typing.Typeable.resolve">resolve</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>