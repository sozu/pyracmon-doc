<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyracmon.graph API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyracmon.graph</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .graph import new_graph, Graph
from .spec import GraphSpec
from .serialize import S
from .template import GraphTemplate
from .identify import IdentifyPolicy


__all__ = [
    &#34;new_graph&#34;,
    &#34;S&#34;,
    &#34;GraphSpec&#34;,
    &#34;Graph&#34;,
    &#34;GraphTemplate&#34;,
    &#34;IdentifyPolicy&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyracmon.graph.graph" href="graph.html">pyracmon.graph.graph</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph.identify" href="identify.html">pyracmon.graph.identify</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph.schema" href="schema.html">pyracmon.graph.schema</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph.serialize" href="serialize.html">pyracmon.graph.serialize</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph.spec" href="spec.html">pyracmon.graph.spec</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph.template" href="template.html">pyracmon.graph.template</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph.typing" href="typing.html">pyracmon.graph.typing</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph.util" href="util.html">pyracmon.graph.util</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyracmon.graph.new_graph"><code class="name flex">
<span>def <span class="ident">new_graph</span></span>(<span>template: <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, *bases: <a title="pyracmon.graph.graph.Graph" href="graph.html#pyracmon.graph.graph.Graph">Graph</a>) ‑> <a title="pyracmon.graph.graph.Graph" href="graph.html#pyracmon.graph.graph.Graph">Graph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a graph from a template.</p>
<p>Use this function instead of invoking constructor directly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template</code></strong></dt>
<dd>A template of a graph.</dd>
<dt><strong><code>bases</code></strong></dt>
<dd>Other graphs whose nodes are appended to created graph.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Created graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_graph(template: GraphTemplate, *bases: Graph) -&gt; Graph:
    &#34;&#34;&#34;
    Create a graph from a template.

    Use this function instead of invoking constructor directly.

    Args:
        template: A template of a graph.
        bases: Other graphs whose nodes are appended to created graph.
    Returns:
        Created graph.
    &#34;&#34;&#34;
    graph = Graph(template)

    for b in bases:
        graph += b

    return graph</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyracmon.graph.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>template: <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a graph composed of tree-structured node containers.</p>
<p>The structure is determined by <code><a title="pyracmon.graph.GraphTemplate" href="#pyracmon.graph.GraphTemplate">GraphTemplate</a></code>. Use <code><a title="pyracmon.graph.new_graph" href="#pyracmon.graph.new_graph">new_graph()</a></code> Instead of constructor to create new graph instance.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; template = GraphSpac().new_template(
&gt;&gt;&gt;     a = (int, lambda x:x),
&gt;&gt;&gt;     b = (str, lambda x:x),
&gt;&gt;&gt;     c = (str, lambda x:x),
&gt;&gt;&gt; )
&gt;&gt;&gt; template.a &lt;&lt; template.b &lt;&lt; template.c
&gt;&gt;&gt; graph = new_graph(template)
</code></pre>
<p><code>append</code> ( <code>replace</code> ) is a method to store entities in the graph with tying them each other according to the structure.
Entites are encapsulated by <code>Node</code> which can have an edge to parent node.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.append(a=1, b=&quot;a&quot;, c=&quot;x&quot;).append(a=2, b=&quot;b&quot;, c=&quot;y&quot;)
</code></pre>
<p>In <code>append</code>, entities are first sorted in descending order, and then:</p>
<ul>
<li>Search a node whose entity is <em>identical</em> to the first entity from the corresponding node container.<ul>
<li>If found, new node is not created and the <em>identical</em> node is set to next parent.</li>
<li>Otherwise, new node is appended and it is set to next parent.</li>
</ul>
</li>
<li>Repeat above to following entities. A difference is that <em>identical</em> node is searched from the parent set in previous operation.</li>
</ul>
<p>In example here, the identification is done by entity value itself. Next code is the example where <em>identical</em> nodes are found.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.append(a=1, b=&quot;a&quot;, c=&quot;z&quot;).append(a=2, b=&quot;c&quot;, c=&quot;y&quot;)
</code></pre>
<p>In the first <code>append</code>, <code>a</code> and <code>b</code> has its <em>identical</em> node and <code>a</code> is <em>identical</em> in the second.
<code>c</code> in the second one is not <em>identical</em> to any node because parent node <code>b="c"</code> is added as new node.</p>
<p>Due to the identification mechanism, repeatin <code>append</code> is sufficient to reconstruct entity relationships in the graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph:
    &#34;&#34;&#34;
    This class represents a graph composed of tree-structured node containers.

    The structure is determined by `GraphTemplate`. Use `new_graph` Instead of constructor to create new graph instance.

    &gt;&gt;&gt; template = GraphSpac().new_template(
    &gt;&gt;&gt;     a = (int, lambda x:x),
    &gt;&gt;&gt;     b = (str, lambda x:x),
    &gt;&gt;&gt;     c = (str, lambda x:x),
    &gt;&gt;&gt; )
    &gt;&gt;&gt; template.a &lt;&lt; template.b &lt;&lt; template.c
    &gt;&gt;&gt; graph = new_graph(template)

    `append` ( `replace` ) is a method to store entities in the graph with tying them each other according to the structure.
    Entites are encapsulated by `Node` which can have an edge to parent node.

    &gt;&gt;&gt; graph.append(a=1, b=&#34;a&#34;, c=&#34;x&#34;).append(a=2, b=&#34;b&#34;, c=&#34;y&#34;)

    In `append`, entities are first sorted in descending order, and then:

    - Search a node whose entity is *identical* to the first entity from the corresponding node container.
        - If found, new node is not created and the *identical* node is set to next parent.
        - Otherwise, new node is appended and it is set to next parent.
    - Repeat above to following entities. A difference is that *identical* node is searched from the parent set in previous operation.

    In example here, the identification is done by entity value itself. Next code is the example where *identical* nodes are found.

    &gt;&gt;&gt; graph.append(a=1, b=&#34;a&#34;, c=&#34;z&#34;).append(a=2, b=&#34;c&#34;, c=&#34;y&#34;)

    In the first `append`, `a` and `b` has its *identical* node and `a` is *identical* in the second.
    `c` in the second one is not *identical* to any node because parent node `b=&#34;c&#34;` is added as new node.

    Due to the identification mechanism, repeatin `append` is sufficient to reconstruct entity relationships in the graph.
    &#34;&#34;&#34;
    def __init__(self, template: GraphTemplate):
        #: Graph template.
        self.template = template
        #: A `dict` containing node containers by their names.
        self.containers = {p.name:self._to_container(p) for p in template._properties}
        self._view = None

    def _to_container(self, prop):
        if isinstance(prop.kind, GraphTemplate):
            return _GraphNodeContainer(prop)
        else:
            return NodeContainer(prop)

    def _container_of(self, prop):
        cands = [c for c in self.containers.values() if c.prop.is_compatible(prop)]
        if len(cands) &gt; 1:
            raise ValueError(f&#34;Container can&#39;t be determined from property &#39;{prop.name}&#39;.&#34;)
        return cands[0] if cands else None

    def __add__(self, another: Union[&#39;Graph&#39;, GraphView]) -&gt; &#39;Graph&#39;:
        &#34;&#34;&#34;
        Create new graph by adding this graph and another graph.

        New graph has the same template as this graph&#39;S.
        On the other hand, because this method depends on `__iadd__()`, another graph must not have the same template.

        Args:
            another: Graph or its view.
        Returns:
            Created graph.
        &#34;&#34;&#34;
        graph = Graph(self.template)

        graph += self
        graph += another

        return graph

    def __iadd__(self, another: Union[&#39;Graph&#39;, GraphView]) -&gt; &#39;Graph&#39;:
        &#34;&#34;&#34;
        Append nodes from another graph.

        Templates of this graph and another graph must not be the same.
        Nodes of another graph are traversed from its root and appended to compatible containers each other.

        Args:
            another: Graph or its view.
        Returns:
            This graph.
        &#34;&#34;&#34;
        another = another if isinstance(another, Graph) else another()

        roots_ = filter(lambda c: c.prop.parent is None, another.containers.values())

        def add(n, anc):
            c = self._container_of(n.prop)
            if c:
                c.append(n.entity, anc)
            for ch_ in n.children.values():
                for m in ch_.nodes:
                    add(m, anc.copy())

        for c_ in roots_:
            for n_ in c_.nodes:
                add(n_, {})

        return self

    @property
    def view(self) -&gt; GraphView:
        &#34;&#34;&#34;
        Returns an unmodifiable view of this graph.

        The view object works as the accessor to graph components.

        - Returns a graph instance when invoked as callable object.
        - The attribute of a container name returns the container view.
        - In iteration context, it iterates views of root containers.
            - Root container is the container which has no parent.

        &gt;&gt;&gt; template = GraphSpac().new_template(a=int, b=str, c=str)
        &gt;&gt;&gt; template.a &lt;&lt; template.b
        &gt;&gt;&gt; graph = new_graph(template)
        &gt;&gt;&gt; view = graph.view
        &gt;&gt;&gt; assert view() is graph                        # invocation
        &gt;&gt;&gt; assert view.a is graph.containers[&#34;a&#34;].view   # attribute
        &gt;&gt;&gt; assert [c().name for c in view] == [&#34;a&#34;, &#34;c&#34;] # iteration
        &#34;&#34;&#34;
        if self._view is None:
            graph = self
            class _GraphView:
                def __call__(self):
                    &#34;&#34;&#34;Returns the greph of this view.&#34;&#34;&#34;
                    return graph
                def __iter__(self):
                    &#34;&#34;&#34;Iterates views of root containers.&#34;&#34;&#34;
                    return map(lambda c: (c.name, c.view), filter(lambda c: c.prop.parent is None, graph.containers.values()))
                def __getattr__(self, name):
                    &#34;&#34;&#34;Returns a view of a container of the name.&#34;&#34;&#34;
                    return graph.containers[name].view
            self._view = _GraphView()
        return self._view

    def _append(self, to_replace, entities):
        props = [p for p in self.template if p.name in entities]

        filtered = set()
        for p in props:
            if (p.parent is None) or (p.parent.name not in entities) or (p.parent.name in filtered):
                if p.entity_filter is None or p.entity_filter(entities[p.name]):
                    filtered.add(p.name)

        ancestors = {}
        for k in [p.name for p in props if p.name in filtered]:
            self.containers[k].append(entities[k], ancestors, to_replace)

        return self

    def append(self, **entities: Any) -&gt; &#39;Graph&#39;:
        &#34;&#34;&#34;
        Append entities with associated property names.

        Args:
            entities: Entities keyed with associated property names.
        Returns:
            This graph.
        &#34;&#34;&#34;
        return self._append(False, entities)

    def replace(self, **entities: Any) -&gt; &#39;Graph&#39;:
        &#34;&#34;&#34;
        Works similarly to `append`, but entities of identical nodes are replaced with given entities.

        Args:
            entities: Entities keyed with associated property names.
        Returns:
            This graph.
        &#34;&#34;&#34;
        return self._append(True, entities)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.graph.Graph.containers"><code class="name">var <span class="ident">containers</span></code></dt>
<dd>
<div class="desc"><p>A <code>dict</code> containing node containers by their names.</p></div>
</dd>
<dt id="pyracmon.graph.Graph.template"><code class="name">var <span class="ident">template</span></code></dt>
<dd>
<div class="desc"><p>Graph template.</p></div>
</dd>
<dt id="pyracmon.graph.Graph.view"><code class="name">var <span class="ident">view</span> : <a title="pyracmon.graph.graph.GraphView" href="graph.html#pyracmon.graph.graph.GraphView">GraphView</a></code></dt>
<dd>
<div class="desc"><p>Returns an unmodifiable view of this graph.</p>
<p>The view object works as the accessor to graph components.</p>
<ul>
<li>Returns a graph instance when invoked as callable object.</li>
<li>The attribute of a container name returns the container view.</li>
<li>In iteration context, it iterates views of root containers.<ul>
<li>Root container is the container which has no parent.</li>
</ul>
</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; template = GraphSpac().new_template(a=int, b=str, c=str)
&gt;&gt;&gt; template.a &lt;&lt; template.b
&gt;&gt;&gt; graph = new_graph(template)
&gt;&gt;&gt; view = graph.view
&gt;&gt;&gt; assert view() is graph                        # invocation
&gt;&gt;&gt; assert view.a is graph.containers[&quot;a&quot;].view   # attribute
&gt;&gt;&gt; assert [c().name for c in view] == [&quot;a&quot;, &quot;c&quot;] # iteration
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def view(self) -&gt; GraphView:
    &#34;&#34;&#34;
    Returns an unmodifiable view of this graph.

    The view object works as the accessor to graph components.

    - Returns a graph instance when invoked as callable object.
    - The attribute of a container name returns the container view.
    - In iteration context, it iterates views of root containers.
        - Root container is the container which has no parent.

    &gt;&gt;&gt; template = GraphSpac().new_template(a=int, b=str, c=str)
    &gt;&gt;&gt; template.a &lt;&lt; template.b
    &gt;&gt;&gt; graph = new_graph(template)
    &gt;&gt;&gt; view = graph.view
    &gt;&gt;&gt; assert view() is graph                        # invocation
    &gt;&gt;&gt; assert view.a is graph.containers[&#34;a&#34;].view   # attribute
    &gt;&gt;&gt; assert [c().name for c in view] == [&#34;a&#34;, &#34;c&#34;] # iteration
    &#34;&#34;&#34;
    if self._view is None:
        graph = self
        class _GraphView:
            def __call__(self):
                &#34;&#34;&#34;Returns the greph of this view.&#34;&#34;&#34;
                return graph
            def __iter__(self):
                &#34;&#34;&#34;Iterates views of root containers.&#34;&#34;&#34;
                return map(lambda c: (c.name, c.view), filter(lambda c: c.prop.parent is None, graph.containers.values()))
            def __getattr__(self, name):
                &#34;&#34;&#34;Returns a view of a container of the name.&#34;&#34;&#34;
                return graph.containers[name].view
        self._view = _GraphView()
    return self._view</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.Graph.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, **entities: Any) ‑> <a title="pyracmon.graph.graph.Graph" href="graph.html#pyracmon.graph.graph.Graph">Graph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Append entities with associated property names.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entities</code></strong></dt>
<dd>Entities keyed with associated property names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, **entities: Any) -&gt; &#39;Graph&#39;:
    &#34;&#34;&#34;
    Append entities with associated property names.

    Args:
        entities: Entities keyed with associated property names.
    Returns:
        This graph.
    &#34;&#34;&#34;
    return self._append(False, entities)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.Graph.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, **entities: Any) ‑> <a title="pyracmon.graph.graph.Graph" href="graph.html#pyracmon.graph.graph.Graph">Graph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works similarly to <code>append</code>, but entities of identical nodes are replaced with given entities.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entities</code></strong></dt>
<dd>Entities keyed with associated property names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(self, **entities: Any) -&gt; &#39;Graph&#39;:
    &#34;&#34;&#34;
    Works similarly to `append`, but entities of identical nodes are replaced with given entities.

    Args:
        entities: Entities keyed with associated property names.
    Returns:
        This graph.
    &#34;&#34;&#34;
    return self._append(True, entities)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.graph.GraphSpec"><code class="flex name class">
<span>class <span class="ident">GraphSpec</span></span>
<span>(</span><span>identifiers: List[Tuple[type, Callable[[Any], Any]]] = None, entity_filters: List[Tuple[type, Callable[[Any], bool]]] = None, serializers: List[Tuple[type, Callable[[ForwardRef('NodeContext')], Any]]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class contains the specifications of graph which control various behaviors in the lifecycles of graphs.</p>
<p>Each instance contains 3 kind of functions; <em>identifier</em>, <em>entity filter</em> and <em>serializer</em>.</p>
<p><em>Identifier</em> is a function to get a value used for the identification of graph entity. See <code><a title="pyracmon.graph.Graph" href="#pyracmon.graph.Graph">Graph</a></code> to know how this works.</p>
<p><em>Entity fliter</em> is a function to determine whether the entity should be appended to a graph or not.
If <code>False</code> is returned for an entity, it is just ignored.</p>
<p><em>Serializer</em> is a function which converts an entity value into a serializable object,
whose signature is one of signatures described in <code><a title="pyracmon.graph.S.each" href="#pyracmon.graph.S.each">S.builder.<locals>.f()</a></code>.
In serialization phase, registered <em>serializer</em> s are first applied and <em>serializer</em> in <code>NodeSerializer</code> follows.</p>
<p>Any kind of function is bound to a type when added, which will work as a key to determine whether it should be applied to a node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphSpec:
    &#34;&#34;&#34;
    This class contains the specifications of graph which control various behaviors in the lifecycles of graphs.

    Each instance contains 3 kind of functions; *identifier*, *entity filter* and *serializer*.

    *Identifier* is a function to get a value used for the identification of graph entity. See `Graph` to know how this works.

    *Entity fliter* is a function to determine whether the entity should be appended to a graph or not.
    If `False` is returned for an entity, it is just ignored.

    *Serializer* is a function which converts an entity value into a serializable object,
    whose signature is one of signatures described in `S.each`.
    In serialization phase, registered *serializer* s are first applied and *serializer* in `NodeSerializer` follows.

    Any kind of function is bound to a type when added, which will work as a key to determine whether it should be applied to a node.
    &#34;&#34;&#34;
    def __init__(
        self,
        identifiers: List[Tuple[type, Callable[[Any], Any]]] = None,
        entity_filters: List[Tuple[type, Callable[[Any], bool]]] = None,
        serializers: List[Tuple[type, Serializer]] = None,
    ):
        #: A list of pairs of type and *identifier*.
        self.identifiers = identifiers or []
        #: A list of pairs of type and *entity_filter*.
        self.entity_filters = entity_filters or []
        #: A list of pairs of type and *serializer*.
        self.serializers = serializers or []

    def _get_inherited(self, holder, t):
        if not isinstance(t, type):
            return None
        return next(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), holder)), None)

    def get_identifier(self, t: type) -&gt; Optional[Callable[[Any], Any]]:
        &#34;&#34;&#34;
        Returns the most appropriate identifier for a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Identifier if exists.
        &#34;&#34;&#34;
        return self._get_inherited(self.identifiers, t)

    def get_entity_filter(self, t: type) -&gt; Optional[Callable[[Any], bool]]:
        &#34;&#34;&#34;
        Returns the most appropriate entity filter for a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Entity filter if exists.
        &#34;&#34;&#34;
        return self._get_inherited(self.entity_filters, t)

    def find_serializers(self, t: type) -&gt; List[Serializer]:
        &#34;&#34;&#34;
        Returns a list of serializers applicable to a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Serializers found.
        &#34;&#34;&#34;
        if not isinstance(t, type):
            return []
        return list(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), self.serializers[::-1])))

    def add_identifier(self, c: type, f: Callable[[Any], Any]) -&gt; &#39;GraphSpec&#39;:
        &#34;&#34;&#34;
        Register an identifier with a type.

        Args:
            c: A type bound to the identifier.
            f: An identifier function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self.identifiers[0:0] = [(c, f)]
        return self

    def add_entity_filter(self, c: type, f: Callable[[Any], bool]) -&gt; &#39;GraphSpec&#39;:
        &#34;&#34;&#34;
        Register an entity filter with a type.

        Args:
            c: A type bound to the identifier.
            f: An entity filter function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self.entity_filters[0:0] = [(c, f)]
        return self

    def add_serializer(self, c: type, f: Serializer) -&gt; &#39;GraphSpec&#39;:
        &#34;&#34;&#34;
        Register a serializer with a type.

        Args:
            c: A type bound to the identifier.
            f: A serializer function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        if isinstance(f, NodeSerializer):
            f = f.serializer
        self.serializers[0:0] = [(c, f)]
        return self

    def _make_policy(self, t, f):
        f = f or self.get_identifier(t)

        if isinstance(f, IdentifyPolicy):
            return f
        elif callable(f):
            return HierarchicalPolicy(f)
        else:
            return neverPolicy()

    def _get_property_definition(self, d):
        if d is None or isinstance(d, tuple):
            d = iter(d or ())
            kind = next(d, None)
            ident = self._make_policy(kind, next(d, None))
            ef = next(d, self.get_entity_filter(kind))
            return kind, ident, ef
        elif isinstance(d, type):
            return d, self._make_policy(d, None), self.get_entity_filter(d)
        elif isinstance(d, GraphTemplate):
            return d, neverPolicy(), None
        else:
            raise ValueError(f&#34;Invalid value was found in keyword arguments of new_template().&#34;)

    def new_template(self, *bases: GraphTemplate, **properties: TemplateProperty) -&gt; GraphTemplate:
        &#34;&#34;&#34;
        Creates a graph template with given definitions for template properties.

        Each keyword argument corresponds to a template property where the key is proprety name and value is property definition.

        Property definition can be a `type` object or a tuple of at most 3 values.
        The former is the equivalent to a tuple which contains the `type` object alone.
        Values in the tuple are interpreted into following attributes in order.

        - The kind of property which indicates a type of entity.
        - *Identifier* of the property.
        - *Entity filter* of the property. 

        Omitted values are complented with registered items in this object.

        &gt;&gt;&gt; template = GraphSpac().new_template(
        &gt;&gt;&gt;     a = int,
        &gt;&gt;&gt;     b = (str, lambda x:x),
        &gt;&gt;&gt;     c = (str, lambda x:x, lambda x:len(x)&gt;5),
        &gt;&gt;&gt; )

        Args:
            bases: Base templates whose properties and relations are merged into new template.
            properties: Definitions of template properties.
        Returns:
            Created graph template.
        &#34;&#34;&#34;
        base = sum(bases, GraphTemplate([]))

        return base + GraphTemplate([(n, *self._get_property_definition(d)) for n, d in properties.items()])

    def to_dict(self, graph: &#39;GraphView&#39;, _params_: Dict[str, Dict[str, Any]] = {}, **settings: NodeSerializer) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;
        Generates a dictionary representing structured entity values of a graph.

        Only nodes whose names appear in keys of `settings` are serialized into the result.
        Each `NodeSerializer` object can be built by factory methods on `S`.

        &gt;&gt;&gt; GraphSpec().to_dict(
        &gt;&gt;&gt;     graph,
        &gt;&gt;&gt;     a = S.of(),
        &gt;&gt;&gt;     b = S.name(&#34;B&#34;),
        &gt;&gt;&gt; )

        Args:
            graph: A view of the graph.
            _params_: Parameters passed to `SerializationContext` and used by *serializer*s.
            settings: `NodeSerializer` for each property.
        Returns:
            Serialization result.
        &#34;&#34;&#34;
        return SerializationContext(settings, self.find_serializers, _params_).execute(graph)

    def to_schema(self, template: GraphTemplate, **settings: NodeSerializer) -&gt; GraphSchema:
        &#34;&#34;&#34;
        Creates `GraphSchema` representing the structure of serialization result under given settings.

        Args:
            template: Template of a graph.
            settings: `NodeSerializer` for each property.
        Returns:
            Schema of serialization result.
        &#34;&#34;&#34;
        return GraphSchema(self, template, **settings)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.model_graph.ConfigurableSpec" href="../model_graph.html#pyracmon.model_graph.ConfigurableSpec">ConfigurableSpec</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.graph.GraphSpec.entity_filters"><code class="name">var <span class="ident">entity_filters</span></code></dt>
<dd>
<div class="desc"><p>A list of pairs of type and <em>entity_filter</em>.</p></div>
</dd>
<dt id="pyracmon.graph.GraphSpec.identifiers"><code class="name">var <span class="ident">identifiers</span></code></dt>
<dd>
<div class="desc"><p>A list of pairs of type and <em>identifier</em>.</p></div>
</dd>
<dt id="pyracmon.graph.GraphSpec.serializers"><code class="name">var <span class="ident">serializers</span></code></dt>
<dd>
<div class="desc"><p>A list of pairs of type and <em>serializer</em>.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.GraphSpec.add_entity_filter"><code class="name flex">
<span>def <span class="ident">add_entity_filter</span></span>(<span>self, c: type, f: Callable[[Any], bool]) ‑> <a title="pyracmon.graph.spec.GraphSpec" href="spec.html#pyracmon.graph.spec.GraphSpec">GraphSpec</a></span>
</code></dt>
<dd>
<div class="desc"><p>Register an entity filter with a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd>A type bound to the identifier.</dd>
<dt><strong><code>f</code></strong></dt>
<dd>An entity filter function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_entity_filter(self, c: type, f: Callable[[Any], bool]) -&gt; &#39;GraphSpec&#39;:
    &#34;&#34;&#34;
    Register an entity filter with a type.

    Args:
        c: A type bound to the identifier.
        f: An entity filter function.
    Returns:
        This instance.
    &#34;&#34;&#34;
    self.entity_filters[0:0] = [(c, f)]
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.add_identifier"><code class="name flex">
<span>def <span class="ident">add_identifier</span></span>(<span>self, c: type, f: Callable[[Any], Any]) ‑> <a title="pyracmon.graph.spec.GraphSpec" href="spec.html#pyracmon.graph.spec.GraphSpec">GraphSpec</a></span>
</code></dt>
<dd>
<div class="desc"><p>Register an identifier with a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd>A type bound to the identifier.</dd>
<dt><strong><code>f</code></strong></dt>
<dd>An identifier function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_identifier(self, c: type, f: Callable[[Any], Any]) -&gt; &#39;GraphSpec&#39;:
    &#34;&#34;&#34;
    Register an identifier with a type.

    Args:
        c: A type bound to the identifier.
        f: An identifier function.
    Returns:
        This instance.
    &#34;&#34;&#34;
    self.identifiers[0:0] = [(c, f)]
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.add_serializer"><code class="name flex">
<span>def <span class="ident">add_serializer</span></span>(<span>self, c: type, f: Callable[[ForwardRef('NodeContext')], Any]) ‑> <a title="pyracmon.graph.spec.GraphSpec" href="spec.html#pyracmon.graph.spec.GraphSpec">GraphSpec</a></span>
</code></dt>
<dd>
<div class="desc"><p>Register a serializer with a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd>A type bound to the identifier.</dd>
<dt><strong><code>f</code></strong></dt>
<dd>A serializer function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_serializer(self, c: type, f: Serializer) -&gt; &#39;GraphSpec&#39;:
    &#34;&#34;&#34;
    Register a serializer with a type.

    Args:
        c: A type bound to the identifier.
        f: A serializer function.
    Returns:
        This instance.
    &#34;&#34;&#34;
    if isinstance(f, NodeSerializer):
        f = f.serializer
    self.serializers[0:0] = [(c, f)]
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.find_serializers"><code class="name flex">
<span>def <span class="ident">find_serializers</span></span>(<span>self, t: type) ‑> List[Callable[[<a title="pyracmon.graph.serialize.NodeContext" href="serialize.html#pyracmon.graph.serialize.NodeContext">NodeContext</a>], Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of serializers applicable to a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Type of an entity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Serializers found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_serializers(self, t: type) -&gt; List[Serializer]:
    &#34;&#34;&#34;
    Returns a list of serializers applicable to a type.
    
    Args:
        t: Type of an entity.
    Returns:
        Serializers found.
    &#34;&#34;&#34;
    if not isinstance(t, type):
        return []
    return list(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), self.serializers[::-1])))</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.get_entity_filter"><code class="name flex">
<span>def <span class="ident">get_entity_filter</span></span>(<span>self, t: type) ‑> Optional[Callable[[Any], bool]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the most appropriate entity filter for a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Type of an entity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Entity filter if exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_entity_filter(self, t: type) -&gt; Optional[Callable[[Any], bool]]:
    &#34;&#34;&#34;
    Returns the most appropriate entity filter for a type.
    
    Args:
        t: Type of an entity.
    Returns:
        Entity filter if exists.
    &#34;&#34;&#34;
    return self._get_inherited(self.entity_filters, t)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.get_identifier"><code class="name flex">
<span>def <span class="ident">get_identifier</span></span>(<span>self, t: type) ‑> Optional[Callable[[Any], Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the most appropriate identifier for a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Type of an entity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Identifier if exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_identifier(self, t: type) -&gt; Optional[Callable[[Any], Any]]:
    &#34;&#34;&#34;
    Returns the most appropriate identifier for a type.
    
    Args:
        t: Type of an entity.
    Returns:
        Identifier if exists.
    &#34;&#34;&#34;
    return self._get_inherited(self.identifiers, t)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.new_template"><code class="name flex">
<span>def <span class="ident">new_template</span></span>(<span>self, *bases: <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, **properties: Union[type, Tuple[type, Callable[[Any], Any]], Tuple[type, Callable[[Any], Any], Callable[[Any], bool]]]) ‑> <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a graph template with given definitions for template properties.</p>
<p>Each keyword argument corresponds to a template property where the key is proprety name and value is property definition.</p>
<p>Property definition can be a <code>type</code> object or a tuple of at most 3 values.
The former is the equivalent to a tuple which contains the <code>type</code> object alone.
Values in the tuple are interpreted into following attributes in order.</p>
<ul>
<li>The kind of property which indicates a type of entity.</li>
<li><em>Identifier</em> of the property.</li>
<li><em>Entity filter</em> of the property. </li>
</ul>
<p>Omitted values are complented with registered items in this object.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; template = GraphSpac().new_template(
&gt;&gt;&gt;     a = int,
&gt;&gt;&gt;     b = (str, lambda x:x),
&gt;&gt;&gt;     c = (str, lambda x:x, lambda x:len(x)&gt;5),
&gt;&gt;&gt; )
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bases</code></strong></dt>
<dd>Base templates whose properties and relations are merged into new template.</dd>
<dt><strong><code>properties</code></strong></dt>
<dd>Definitions of template properties.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Created graph template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_template(self, *bases: GraphTemplate, **properties: TemplateProperty) -&gt; GraphTemplate:
    &#34;&#34;&#34;
    Creates a graph template with given definitions for template properties.

    Each keyword argument corresponds to a template property where the key is proprety name and value is property definition.

    Property definition can be a `type` object or a tuple of at most 3 values.
    The former is the equivalent to a tuple which contains the `type` object alone.
    Values in the tuple are interpreted into following attributes in order.

    - The kind of property which indicates a type of entity.
    - *Identifier* of the property.
    - *Entity filter* of the property. 

    Omitted values are complented with registered items in this object.

    &gt;&gt;&gt; template = GraphSpac().new_template(
    &gt;&gt;&gt;     a = int,
    &gt;&gt;&gt;     b = (str, lambda x:x),
    &gt;&gt;&gt;     c = (str, lambda x:x, lambda x:len(x)&gt;5),
    &gt;&gt;&gt; )

    Args:
        bases: Base templates whose properties and relations are merged into new template.
        properties: Definitions of template properties.
    Returns:
        Created graph template.
    &#34;&#34;&#34;
    base = sum(bases, GraphTemplate([]))

    return base + GraphTemplate([(n, *self._get_property_definition(d)) for n, d in properties.items()])</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, graph: GraphView, **settings: <a title="pyracmon.graph.serialize.NodeSerializer" href="serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a dictionary representing structured entity values of a graph.</p>
<p>Only nodes whose names appear in keys of <code>settings</code> are serialized into the result.
Each <code>NodeSerializer</code> object can be built by factory methods on <code><a title="pyracmon.graph.S" href="#pyracmon.graph.S">S</a></code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; GraphSpec().to_dict(
&gt;&gt;&gt;     graph,
&gt;&gt;&gt;     a = S.of(),
&gt;&gt;&gt;     b = S.name(&quot;B&quot;),
&gt;&gt;&gt; )
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>A view of the graph.</dd>
<dt><strong><code>_params_</code></strong></dt>
<dd>Parameters passed to <code>SerializationContext</code> and used by <em>serializer</em>s.</dd>
<dt><strong><code>settings</code></strong></dt>
<dd><code>NodeSerializer</code> for each property.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Serialization result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, graph: &#39;GraphView&#39;, _params_: Dict[str, Dict[str, Any]] = {}, **settings: NodeSerializer) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Generates a dictionary representing structured entity values of a graph.

    Only nodes whose names appear in keys of `settings` are serialized into the result.
    Each `NodeSerializer` object can be built by factory methods on `S`.

    &gt;&gt;&gt; GraphSpec().to_dict(
    &gt;&gt;&gt;     graph,
    &gt;&gt;&gt;     a = S.of(),
    &gt;&gt;&gt;     b = S.name(&#34;B&#34;),
    &gt;&gt;&gt; )

    Args:
        graph: A view of the graph.
        _params_: Parameters passed to `SerializationContext` and used by *serializer*s.
        settings: `NodeSerializer` for each property.
    Returns:
        Serialization result.
    &#34;&#34;&#34;
    return SerializationContext(settings, self.find_serializers, _params_).execute(graph)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.to_schema"><code class="name flex">
<span>def <span class="ident">to_schema</span></span>(<span>self, template: <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, **settings: <a title="pyracmon.graph.serialize.NodeSerializer" href="serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>) ‑> <a title="pyracmon.graph.schema.GraphSchema" href="schema.html#pyracmon.graph.schema.GraphSchema">GraphSchema</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates <code>GraphSchema</code> representing the structure of serialization result under given settings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template</code></strong></dt>
<dd>Template of a graph.</dd>
<dt><strong><code>settings</code></strong></dt>
<dd><code>NodeSerializer</code> for each property.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Schema of serialization result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_schema(self, template: GraphTemplate, **settings: NodeSerializer) -&gt; GraphSchema:
    &#34;&#34;&#34;
    Creates `GraphSchema` representing the structure of serialization result under given settings.

    Args:
        template: Template of a graph.
        settings: `NodeSerializer` for each property.
    Returns:
        Schema of serialization result.
    &#34;&#34;&#34;
    return GraphSchema(self, template, **settings)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.graph.GraphTemplate"><code class="flex name class">
<span>class <span class="ident">GraphTemplate</span></span>
<span>(</span><span>definitions: List[Tuple[str, type, Callable[[Any], Any], Callable[[Any], bool]]])</span>
</code></dt>
<dd>
<div class="desc"><p>This class specifies the structure of a graph.</p>
<p>The template is composed of template properties each of which corresponds to a node container of a graph.
Each template property can be obtained via an attribute of its name from the template.</p>
<p>Applying shift operator between properties creates the parent-child relationship between them.
In next code, the template is composed of 4 properties where <code>d</code> is a child of <code>c</code>, and <code>b</code> and <code>c</code> are children of <code>a</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; template = GraphSpec().new_template(a=int, b=str, c=int, d=float)
&gt;&gt;&gt; template.a &lt;&lt; [template.b, template.c]
&gt;&gt;&gt; template.c &lt;&lt; template.d
</code></pre>
<p>Templates are merged when <code>+</code> is applied to them. The result has properties defined in both templates with keeping their relationships.
Merging of templates having properties of the same name fails by raising <code>ValueError</code>.</p>
<p>Use <code><a title="pyracmon.graph.GraphSpec.new_template" href="#pyracmon.graph.GraphSpec.new_template">GraphSpec.new_template()</a></code> or other factory functions to create a template instead of using constructor directly.</p>
<p>Construct template with its properties.
Don't use this constructor directly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>definitions</code></strong></dt>
<dd>Definitions of template properties.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphTemplate:
    &#34;&#34;&#34;
    This class specifies the structure of a graph.

    The template is composed of template properties each of which corresponds to a node container of a graph.
    Each template property can be obtained via an attribute of its name from the template.

    Applying shift operator between properties creates the parent-child relationship between them.
    In next code, the template is composed of 4 properties where `d` is a child of `c`, and `b` and `c` are children of `a`.

    &gt;&gt;&gt; template = GraphSpec().new_template(a=int, b=str, c=int, d=float)
    &gt;&gt;&gt; template.a &lt;&lt; [template.b, template.c]
    &gt;&gt;&gt; template.c &lt;&lt; template.d

    Templates are merged when `+` is applied to them. The result has properties defined in both templates with keeping their relationships.
    Merging of templates having properties of the same name fails by raising `ValueError`.

    Use `GraphSpec.new_template` or other factory functions to create a template instead of using constructor directly.
    &#34;&#34;&#34;
    class Property:
        &#34;&#34;&#34;
        Template property which determines various behaviors of graph nodes.
        &#34;&#34;&#34;
        def __init__(
            self,
            template: &#39;GraphTemplate&#39;,
            name: str,
            kind: type,
            policy: Optional[IdentifyPolicy],
            entity_filter: Optional[Callable[[Any], bool]],
            origin = None,
        ):
            #: Graph template this property belongs to.
            self.template = template
            #: Property name.
            self.name = name
            #: Graph node bound to this property should have entity of this type.
            self.kind = kind
            #: Policy of entity identification.
            self.policy = policy
            #: Entity filter function.
            self.entity_filter = entity_filter
            self._origin = origin

        def _assert_canbe_parent(self, another):
            if another.parent is not None:
                raise ValueError(f&#34;Graph template property can not have multiple parents.&#34;)
            if self.template != another.template:
                raise ValueError(f&#34;Properties can make parent-child relationship only when they are declared in the same template.&#34;)
            if self == another:
                raise ValueError(f&#34;Recursive relationship is not allowed.&#34;)
            if isinstance(self.kind, GraphTemplate):
                raise ValueError(f&#34;Property for graph template can&#39;t have child.&#34;)
            p = self
            while p.parent is not None:
                if p.parent == another:
                    raise ValueError(f&#34;Recursive relationship is not allowed.&#34;)
                p = p.parent

        @property
        def parent(self) -&gt; Optional[&#39;GraphTemplate.Property&#39;]:
            &#34;&#34;&#34;
            Returns parent property if exists.
            &#34;&#34;&#34;
            return next(filter(lambda r: r[0] == self, self.template._relations), (None, None))[1]

        @property
        def children(self) -&gt; List[&#39;GraphTemplate.Property&#39;]:
            &#34;&#34;&#34;
            Returns child properties.
            &#34;&#34;&#34;
            return [r[0] for r in self.template._relations if r[1] == self]

        @property
        def origin(self):
            p = self
            while p._origin:
                p = p._origin
            return p

        def is_compatible(self, other):
            return self.origin is other.origin

        def _move_template(self, dest, new_name=None):
            new_name = new_name or self.name
            prop = GraphTemplate.Property(dest, new_name, self.kind, self.policy, self.entity_filter, origin=self)
            _set_template_property(dest, prop)
            for c in self.children:
                cc = c._move_template(dest)
                prop &lt;&lt; cc
            return prop

        def __lshift__(
            self,
            children: Union[&#39;GraphTemplate.Property&#39;, List[&#39;GraphTemplate.Property&#39;]],
        ) -&gt; Union[&#39;GraphTemplate.Property&#39;, List[&#39;GraphTemplate.Property&#39;]]:
            &#34;&#34;&#34;
            Makes this property as a parent of child properties.

            Args:
                children: Property or properties to be children of this property.
            Returns:
                The same object as the argument.
            &#34;&#34;&#34;
            targets = [children] if isinstance(children, GraphTemplate.Property) else children
            for c in targets:
                self._assert_canbe_parent(c)
            self.template._relations += [(c, self) for c in targets]
            return children

        def __rshift__(self, parent: &#39;GraphTemplate.Property&#39;) -&gt; &#39;GraphTemplate.Property&#39;:
            &#34;&#34;&#34;
            Makes this property as a child of another property.

            Args:
                parent: A Property to be a parent of this property.
            Returns:
                The same object as the argument.
            &#34;&#34;&#34;
            parent._assert_canbe_parent(self)
            self.template._relations += [(self, parent)]
            return parent

        def __rrshift__(
            self,
            children: Union[&#39;GraphTemplate.Property&#39;, List[&#39;GraphTemplate.Property&#39;]],
        ) -&gt; Union[&#39;GraphTemplate.Property&#39;, List[&#39;GraphTemplate.Property&#39;]]:
            &#34;&#34;&#34;
            Reversed version of `__lshift__()` prepared to locate a list of properties on the left side.

            Args:
                children: Property or properties to be children of this property.
            Returns:
                The same object as the argument.
            &#34;&#34;&#34;
            self.__lshift__(children)
            return self

    def __init__(self, definitions: List[Tuple[str, type, Callable[[Any], Any], Callable[[Any], bool]]]):
        &#34;&#34;&#34;
        Construct template with its properties.  Don&#39;t use this constructor directly.

        Args:
            definitions: Definitions of template properties.
        &#34;&#34;&#34;
        self._properties = []
        self._relations = []

        for d in definitions:
            it = iter(d)
            name, kind, ident, ef = (next(it), next(it), next(it, None), next(it, None))

            if isinstance(kind, GraphTemplate):
                prop = GraphTemplate.Property(self, name, kind, None, None)
                _set_template_property(self, prop)
            elif isinstance(kind, GraphTemplate.Property):
                kind._move_template(self, name)
            else:
                _set_template_property(self, GraphTemplate.Property(self, name, kind, ident, ef))

    def __iter__(self) -&gt; Iterator[&#39;GraphTemplate.Property&#39;]:
        &#34;&#34;&#34;
        Iterates properties in parent-to-child order.

        Returns:
            Property iterator.
        &#34;&#34;&#34;
        return _sort_properties(self._properties)

    def __iadd__(self, another: &#39;GraphTemplate&#39;) -&gt; &#39;GraphTemplate&#39;:
        &#34;&#34;&#34;
        Add another template to this template.

        Args:
            another: Another template.
        Returns:
            This instance.
        &#34;&#34;&#34;
        for p in another._properties:
            prop = GraphTemplate.Property(self, p.name, p.kind, p.policy, p.entity_filter, origin=p)
            _set_template_property(self, prop)

        for n, p in another._relations:
            getattr(self, n.name) &gt;&gt; getattr(self, p.name)

        return self

    def __add__(self, another: &#39;GraphTemplate&#39;) -&gt; &#39;GraphTemplate&#39;:
        &#34;&#34;&#34;
        Create new template by merging this template and another one.

        Args:
            another: Another template.
        Returns:
            New template.
        &#34;&#34;&#34;
        template = GraphTemplate([])
        template += self
        template += another

        return template</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyracmon.graph.GraphTemplate.Property"><code class="name">var <span class="ident">Property</span></code></dt>
<dd>
<div class="desc"><p>Template property which determines various behaviors of graph nodes.</p></div>
</dd>
</dl>
</dd>
<dt id="pyracmon.graph.IdentifyPolicy"><code class="flex name class">
<span>class <span class="ident">IdentifyPolicy</span></span>
<span>(</span><span>identifier: Callable[[Any], Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Provides entity identification functionalities used during appending entities to a graph.</p>
<p>Identification mechanism is based on the equality of identification keys extracted by entities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IdentifyPolicy:
    &#34;&#34;&#34;
    Provides entity identification functionalities used during appending entities to a graph.

    Identification mechanism is based on the equality of identification keys extracted by entities.
    &#34;&#34;&#34;
    def __init__(self, identifier: Callable[[Any], Any]):
        #: A function to extract the identification key from an entity.
        self.identifier = identifier

    def get_identifier(self, value: Any) -&gt; Any:
        &#34;&#34;&#34;
        Returns identification key from an entity.

        Args:
            value: An entity.
        Returns:
            Identification key.
        &#34;&#34;&#34;
        return self.identifier(value) if self.identifier else None

    def identify(
        self,
        prop: &#39;GraphTemplate.Property&#39;,
        candidates: List[&#39;Node&#39;],
        ancestors: Dict[str, List[&#39;Node&#39;]],
    ) -&gt; Tuple[List[Optional[&#39;Node&#39;]], List[&#39;Node&#39;]]:
        &#34;&#34;&#34;
        Select parent nodes and identical nodes of a new entity.

        This method is called during appending an entity to a graph.

        Args:
            prop: Template property for new entity.
            candidates: Nodes having the same identification key as the key of new entity.
            ancestors: Parent nodes mapped by property names.
        Returns
            The first item is a list of Parent nodes which the node of new entity should be appended newly.
            `None` means to append a new node without parent. The second item is a list of identical nodes,
            which will be merged into ancestors and used in subsequent identifications of child entities.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.graph.identify.AlwaysPolicy" href="identify.html#pyracmon.graph.identify.AlwaysPolicy">AlwaysPolicy</a></li>
<li><a title="pyracmon.graph.identify.HierarchicalPolicy" href="identify.html#pyracmon.graph.identify.HierarchicalPolicy">HierarchicalPolicy</a></li>
<li><a title="pyracmon.graph.identify.NeverPolicy" href="identify.html#pyracmon.graph.identify.NeverPolicy">NeverPolicy</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.graph.IdentifyPolicy.identifier"><code class="name">var <span class="ident">identifier</span></code></dt>
<dd>
<div class="desc"><p>A function to extract the identification key from an entity.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.IdentifyPolicy.get_identifier"><code class="name flex">
<span>def <span class="ident">get_identifier</span></span>(<span>self, value: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Returns identification key from an entity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>An entity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Identification key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_identifier(self, value: Any) -&gt; Any:
    &#34;&#34;&#34;
    Returns identification key from an entity.

    Args:
        value: An entity.
    Returns:
        Identification key.
    &#34;&#34;&#34;
    return self.identifier(value) if self.identifier else None</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.IdentifyPolicy.identify"><code class="name flex">
<span>def <span class="ident">identify</span></span>(<span>self, prop: <a title="pyracmon.graph.GraphTemplate.Property" href="#pyracmon.graph.GraphTemplate.Property">GraphTemplate.Property</a>, candidates: List[ForwardRef('Node')], ancestors: Dict[str, List[ForwardRef('Node')]]) ‑> Tuple[List[Optional[Node]], List[Node]]</span>
</code></dt>
<dd>
<div class="desc"><p>Select parent nodes and identical nodes of a new entity.</p>
<p>This method is called during appending an entity to a graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>prop</code></strong></dt>
<dd>Template property for new entity.</dd>
<dt><strong><code>candidates</code></strong></dt>
<dd>Nodes having the same identification key as the key of new entity.</dd>
<dt><strong><code>ancestors</code></strong></dt>
<dd>Parent nodes mapped by property names.</dd>
</dl>
<p>Returns
The first item is a list of Parent nodes which the node of new entity should be appended newly.
<code>None</code> means to append a new node without parent. The second item is a list of identical nodes,
which will be merged into ancestors and used in subsequent identifications of child entities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify(
    self,
    prop: &#39;GraphTemplate.Property&#39;,
    candidates: List[&#39;Node&#39;],
    ancestors: Dict[str, List[&#39;Node&#39;]],
) -&gt; Tuple[List[Optional[&#39;Node&#39;]], List[&#39;Node&#39;]]:
    &#34;&#34;&#34;
    Select parent nodes and identical nodes of a new entity.

    This method is called during appending an entity to a graph.

    Args:
        prop: Template property for new entity.
        candidates: Nodes having the same identification key as the key of new entity.
        ancestors: Parent nodes mapped by property names.
    Returns
        The first item is a list of Parent nodes which the node of new entity should be appended newly.
        `None` means to append a new node without parent. The second item is a list of identical nodes,
        which will be merged into ancestors and used in subsequent identifications of child entities.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.graph.S"><code class="flex name class">
<span>class <span class="ident">S</span></span>
</code></dt>
<dd>
<div class="desc"><p>An utility class to build <code>NodeSerializer</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class S:
    &#34;&#34;&#34;
    An utility class to build `NodeSerializer`.
    &#34;&#34;&#34;
    @classmethod
    def of(
        cls,
        namer: Optional[Union[str, Callable[[str], str]]] = None,
        aggregator: Optional[Union[Callable[[Node], Node], Callable[[Node], List[Node]], int]] = None,
        *serializers: Serializer,
    ) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Create an instance of `NodeSerializer`.

        Args:
            namer: A string or naming function.
            aggregator: An aggregation function or an index of node to select in node container.
            serializer: A list of *serializer* s.
        Returns:
            Created `NodeSerializer` .
        &#34;&#34;&#34;
        return NodeSerializer(namer, aggregator, *serializers)

    @classmethod
    def builder(cls, builder: Callable[[Any], Any]):
        &#34;&#34;&#34;
        This method is used as decorator to put decorating target to `S` builder methods.

        &gt;&gt;&gt; @S.builder
        &gt;&gt;&gt; def some_func():
        &gt;&gt;&gt;     ...
        &gt;&gt;&gt; S.some_func()

        Args:
            builder: Decorating target.
        Returns:
            Decorated builder.
        &#34;&#34;&#34;
        def f(*args, **kwargs):
            return builder(S.of(), *args, **kwargs)
        setattr(S, builder.__name__, f)
        return builder</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.graph.S.builder"><code class="name flex">
<span>def <span class="ident">builder</span></span>(<span>builder: Callable[[Any], Any])</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used as decorator to put decorating target to <code><a title="pyracmon.graph.S" href="#pyracmon.graph.S">S</a></code> builder methods.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @S.builder
&gt;&gt;&gt; def some_func():
&gt;&gt;&gt;     ...
&gt;&gt;&gt; S.some_func()
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>builder</code></strong></dt>
<dd>Decorating target.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Decorated builder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def builder(cls, builder: Callable[[Any], Any]):
    &#34;&#34;&#34;
    This method is used as decorator to put decorating target to `S` builder methods.

    &gt;&gt;&gt; @S.builder
    &gt;&gt;&gt; def some_func():
    &gt;&gt;&gt;     ...
    &gt;&gt;&gt; S.some_func()

    Args:
        builder: Decorating target.
    Returns:
        Decorated builder.
    &#34;&#34;&#34;
    def f(*args, **kwargs):
        return builder(S.of(), *args, **kwargs)
    setattr(S, builder.__name__, f)
    return builder</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>namer: Union[str, Callable[[str], str], None] = None, aggregator: Union[Callable[[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>], <a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>], Callable[[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>], List[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]], int, None] = None, *serializers: Callable[[ForwardRef('NodeContext')], Any]) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create an instance of <code>NodeSerializer</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>namer</code></strong></dt>
<dd>A string or naming function.</dd>
<dt><strong><code>aggregator</code></strong></dt>
<dd>An aggregation function or an index of node to select in node container.</dd>
<dt><strong><code>serializer</code></strong></dt>
<dd>A list of <em>serializer</em> s.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Created <code>NodeSerializer</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def of(
    cls,
    namer: Optional[Union[str, Callable[[str], str]]] = None,
    aggregator: Optional[Union[Callable[[Node], Node], Callable[[Node], List[Node]], int]] = None,
    *serializers: Serializer,
) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Create an instance of `NodeSerializer`.

    Args:
        namer: A string or naming function.
        aggregator: An aggregation function or an index of node to select in node container.
        serializer: A list of *serializer* s.
    Returns:
        Created `NodeSerializer` .
    &#34;&#34;&#34;
    return NodeSerializer(namer, aggregator, *serializers)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.S.alter"><code class="name flex">
<span>def <span class="ident">alter</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.doc"><code class="name flex">
<span>def <span class="ident">doc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.each"><code class="name flex">
<span>def <span class="ident">each</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.last"><code class="name flex">
<span>def <span class="ident">last</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.name"><code class="name flex">
<span>def <span class="ident">name</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.sub"><code class="name flex">
<span>def <span class="ident">sub</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyracmon" href="../index.html">pyracmon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyracmon.graph.graph" href="graph.html">pyracmon.graph.graph</a></code></li>
<li><code><a title="pyracmon.graph.identify" href="identify.html">pyracmon.graph.identify</a></code></li>
<li><code><a title="pyracmon.graph.schema" href="schema.html">pyracmon.graph.schema</a></code></li>
<li><code><a title="pyracmon.graph.serialize" href="serialize.html">pyracmon.graph.serialize</a></code></li>
<li><code><a title="pyracmon.graph.spec" href="spec.html">pyracmon.graph.spec</a></code></li>
<li><code><a title="pyracmon.graph.template" href="template.html">pyracmon.graph.template</a></code></li>
<li><code><a title="pyracmon.graph.typing" href="typing.html">pyracmon.graph.typing</a></code></li>
<li><code><a title="pyracmon.graph.util" href="util.html">pyracmon.graph.util</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyracmon.graph.new_graph" href="#pyracmon.graph.new_graph">new_graph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyracmon.graph.Graph" href="#pyracmon.graph.Graph">Graph</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.graph.Graph.append" href="#pyracmon.graph.Graph.append">append</a></code></li>
<li><code><a title="pyracmon.graph.Graph.containers" href="#pyracmon.graph.Graph.containers">containers</a></code></li>
<li><code><a title="pyracmon.graph.Graph.replace" href="#pyracmon.graph.Graph.replace">replace</a></code></li>
<li><code><a title="pyracmon.graph.Graph.template" href="#pyracmon.graph.Graph.template">template</a></code></li>
<li><code><a title="pyracmon.graph.Graph.view" href="#pyracmon.graph.Graph.view">view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.GraphSpec" href="#pyracmon.graph.GraphSpec">GraphSpec</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.graph.GraphSpec.add_entity_filter" href="#pyracmon.graph.GraphSpec.add_entity_filter">add_entity_filter</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.add_identifier" href="#pyracmon.graph.GraphSpec.add_identifier">add_identifier</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.add_serializer" href="#pyracmon.graph.GraphSpec.add_serializer">add_serializer</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.entity_filters" href="#pyracmon.graph.GraphSpec.entity_filters">entity_filters</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.find_serializers" href="#pyracmon.graph.GraphSpec.find_serializers">find_serializers</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.get_entity_filter" href="#pyracmon.graph.GraphSpec.get_entity_filter">get_entity_filter</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.get_identifier" href="#pyracmon.graph.GraphSpec.get_identifier">get_identifier</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.identifiers" href="#pyracmon.graph.GraphSpec.identifiers">identifiers</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.new_template" href="#pyracmon.graph.GraphSpec.new_template">new_template</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.serializers" href="#pyracmon.graph.GraphSpec.serializers">serializers</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.to_dict" href="#pyracmon.graph.GraphSpec.to_dict">to_dict</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.to_schema" href="#pyracmon.graph.GraphSpec.to_schema">to_schema</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.GraphTemplate" href="#pyracmon.graph.GraphTemplate">GraphTemplate</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.graph.GraphTemplate.Property" href="#pyracmon.graph.GraphTemplate.Property">Property</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.IdentifyPolicy" href="#pyracmon.graph.IdentifyPolicy">IdentifyPolicy</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.graph.IdentifyPolicy.get_identifier" href="#pyracmon.graph.IdentifyPolicy.get_identifier">get_identifier</a></code></li>
<li><code><a title="pyracmon.graph.IdentifyPolicy.identifier" href="#pyracmon.graph.IdentifyPolicy.identifier">identifier</a></code></li>
<li><code><a title="pyracmon.graph.IdentifyPolicy.identify" href="#pyracmon.graph.IdentifyPolicy.identify">identify</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.S" href="#pyracmon.graph.S">S</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.graph.S.alter" href="#pyracmon.graph.S.alter">alter</a></code></li>
<li><code><a title="pyracmon.graph.S.at" href="#pyracmon.graph.S.at">at</a></code></li>
<li><code><a title="pyracmon.graph.S.builder" href="#pyracmon.graph.S.builder">builder</a></code></li>
<li><code><a title="pyracmon.graph.S.doc" href="#pyracmon.graph.S.doc">doc</a></code></li>
<li><code><a title="pyracmon.graph.S.each" href="#pyracmon.graph.S.each">each</a></code></li>
<li><code><a title="pyracmon.graph.S.fold" href="#pyracmon.graph.S.fold">fold</a></code></li>
<li><code><a title="pyracmon.graph.S.head" href="#pyracmon.graph.S.head">head</a></code></li>
<li><code><a title="pyracmon.graph.S.last" href="#pyracmon.graph.S.last">last</a></code></li>
<li><code><a title="pyracmon.graph.S.merge" href="#pyracmon.graph.S.merge">merge</a></code></li>
<li><code><a title="pyracmon.graph.S.name" href="#pyracmon.graph.S.name">name</a></code></li>
<li><code><a title="pyracmon.graph.S.of" href="#pyracmon.graph.S.of">of</a></code></li>
<li><code><a title="pyracmon.graph.S.select" href="#pyracmon.graph.S.select">select</a></code></li>
<li><code><a title="pyracmon.graph.S.sub" href="#pyracmon.graph.S.sub">sub</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>