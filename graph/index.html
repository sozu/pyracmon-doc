<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyracmon.graph API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyracmon.graph</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .graph import new_graph, Graph
from .spec import GraphSpec
from .serialize import S
from .template import GraphTemplate
from .identify import IdentifyPolicy


__all__ = [
    &#34;new_graph&#34;,
    &#34;S&#34;,
    &#34;GraphSpec&#34;,
    &#34;Graph&#34;,
    &#34;GraphTemplate&#34;,
    &#34;IdentifyPolicy&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyracmon.graph.graph" href="graph.html">pyracmon.graph.graph</a></code></dt>
<dd>
<div class="desc"><p>This module exports types representing graphs.</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph.identify" href="identify.html">pyracmon.graph.identify</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph.protocol" href="protocol.html">pyracmon.graph.protocol</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph.schema" href="schema.html">pyracmon.graph.schema</a></code></dt>
<dd>
<div class="desc"><p>This module provides the way to generate schema of the graph after being serialized …</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph.serialize" href="serialize.html">pyracmon.graph.serialize</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph.spec" href="spec.html">pyracmon.graph.spec</a></code></dt>
<dd>
<div class="desc"><p>This module provides a type which contains objects to control how graphs work.</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph.stub" href="stub.html">pyracmon.graph.stub</a></code></dt>
<dd>
<div class="desc"><p>from collections.abc import Iterator
from typing import Any, Optional, Generic, TypeVar, ForwardRef, TYPE_CHECKING, cast
from typing_extensions import …</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph.template" href="template.html">pyracmon.graph.template</a></code></dt>
<dd>
<div class="desc"><p>This module provides a type specifying graph structure.</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph.typing" href="typing.html">pyracmon.graph.typing</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyracmon.graph.new_graph"><code class="name flex">
<span>def <span class="ident">new_graph</span></span>(<span>template: <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, *bases: Union[<a title="pyracmon.graph.graph.Graph" href="graph.html#pyracmon.graph.graph.Graph">Graph</a>, <a title="pyracmon.graph.graph.GraphView" href="graph.html#pyracmon.graph.graph.GraphView">GraphView</a>]) ‑> <a title="pyracmon.graph.graph.Graph" href="graph.html#pyracmon.graph.graph.Graph">Graph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a graph from a template.</p>
<p>Use this function instead of invoking constructor directly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template</code></strong></dt>
<dd>A template of a graph.</dd>
<dt><strong><code>bases</code></strong></dt>
<dd>Other graphs whose nodes are appended to created graph.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Created graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_graph(template: GraphTemplate, *bases: Union[Graph, GraphView]) -&gt; Graph:
    &#34;&#34;&#34;
    Create a graph from a template.

    Use this function instead of invoking constructor directly.

    Args:
        template: A template of a graph.
        bases: Other graphs whose nodes are appended to created graph.
    Returns:
        Created graph.
    &#34;&#34;&#34;
    graph = Graph(template)

    for b in bases:
        graph += b

    return graph</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyracmon.graph.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>template: <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a graph composed of tree-structured node containers.</p>
<p>The structure is determined by <code><a title="pyracmon.graph.GraphTemplate" href="#pyracmon.graph.GraphTemplate">GraphTemplate</a></code>. Use <code><a title="pyracmon.graph.new_graph" href="#pyracmon.graph.new_graph">new_graph()</a></code> Instead of constructor to create new graph instance.</p>
<pre><code class="language-python">template = GraphSpac().new_template(
    a = (int, lambda x:x),
    b = (str, lambda x:x),
    c = (str, lambda x:x),
)
template.a &lt;&lt; template.b &lt;&lt; template.c
graph = new_graph(template)
</code></pre>
<p>In above code, a graph which has 3 properties ( <code>a</code> <code>b</code> <code>c</code> ) and a structure where <code>a</code> is parent of <code>b</code> and <code>b</code> is parent of <code>c</code> is created.</p>
<p><code>append</code> ( <code>replace</code> ) is a method to store entities in the graph with tying them each other according to the structure.
Entites are encapsulated by <code>Node</code> which can have an edge to parent node.</p>
<pre><code class="language-python">graph.append(a=1, b=&quot;a&quot;, c=&quot;x&quot;).append(a=2, b=&quot;b&quot;, c=&quot;y&quot;)
</code></pre>
<p>In <code>append</code>, entities are first sorted in descending order, and then:</p>
<ul>
<li>Search a node whose entity is <em>identical</em> to the first entity from the corresponding node container.<ul>
<li>If found, new node is not created and the <em>identical</em> node is set to next parent.</li>
<li>Otherwise, new node is appended and it is set to next parent.</li>
</ul>
</li>
<li>Apply this to following entities in order. A difference is that <em>identical</em> node is searched from the sequence of parents in the session.</li>
</ul>
<p>In example here, the identification is done by entity value itself ( <code>lambda x:x</code> ). Next code is the example where <em>identical</em> nodes are found.</p>
<pre><code class="language-python">graph.append(a=1, b=&quot;a&quot;, c=&quot;z&quot;).append(a=2, b=&quot;c&quot;, c=&quot;y&quot;)
</code></pre>
<p>In the first <code>append</code>, <code>a</code> and <code>b</code> has its <em>identical</em> node and <code>a</code> is <em>identical</em> in the second.
<code>c</code> in the second one is not <em>identical</em> to any node because parent node <code>b="c"</code> is already added as new node.</p>
<p>Due to the identification mechanism, entity relationships in the graph is guaranteed after repeating <code>append</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph:
    &#34;&#34;&#34;
    This class represents a graph composed of tree-structured node containers.

    The structure is determined by `GraphTemplate`. Use `new_graph` Instead of constructor to create new graph instance.

    ```python
    template = GraphSpac().new_template(
        a = (int, lambda x:x),
        b = (str, lambda x:x),
        c = (str, lambda x:x),
    )
    template.a &lt;&lt; template.b &lt;&lt; template.c
    graph = new_graph(template)
    ```

    In above code, a graph which has 3 properties ( `a` `b` `c` ) and a structure where `a` is parent of `b` and `b` is parent of `c` is created.

    `append` ( `replace` ) is a method to store entities in the graph with tying them each other according to the structure.
    Entites are encapsulated by `Node` which can have an edge to parent node.

    ```python
    graph.append(a=1, b=&#34;a&#34;, c=&#34;x&#34;).append(a=2, b=&#34;b&#34;, c=&#34;y&#34;)
    ```

    In `append`, entities are first sorted in descending order, and then:

    - Search a node whose entity is *identical* to the first entity from the corresponding node container.
        - If found, new node is not created and the *identical* node is set to next parent.
        - Otherwise, new node is appended and it is set to next parent.
    - Apply this to following entities in order. A difference is that *identical* node is searched from the sequence of parents in the session.

    In example here, the identification is done by entity value itself ( `lambda x:x` ). Next code is the example where *identical* nodes are found.

    ```python
    graph.append(a=1, b=&#34;a&#34;, c=&#34;z&#34;).append(a=2, b=&#34;c&#34;, c=&#34;y&#34;)
    ```

    In the first `append`, `a` and `b` has its *identical* node and `a` is *identical* in the second.
    `c` in the second one is not *identical* to any node because parent node `b=&#34;c&#34;` is already added as new node.

    Due to the identification mechanism, entity relationships in the graph is guaranteed after repeating `append` .
    &#34;&#34;&#34;
    def __init__(self, template: GraphTemplate):
        #: Graph template.
        self.template: GraphTemplate = template
        #: A `dict` containing node containers by their names.
        self.containers: dict[str, NodeContainer] = {p.name:self._to_container(p) for p in template}
        self._view = None

    def _to_container(self, prop: GraphTemplate.Property) -&gt; &#39;NodeContainer&#39;:
        if isinstance(prop.kind, GraphTemplate):
            return _GraphNodeContainer(prop)
        else:
            return NodeContainer(prop)

    def _container_of(self, prop: GraphTemplate.Property) -&gt; Optional[&#39;NodeContainer&#39;]:
        candidates = [c for c in self.containers.values() if c.prop.is_compatible(prop)]
        if len(candidates) &gt; 1:
            raise ValueError(f&#34;Container can&#39;t be determined from property &#39;{prop.name}&#39;.&#34;)
        return candidates[0] if candidates else None

    def __add__(self, another: Union[Self, GraphView]) -&gt; &#39;Graph&#39;:
        &#34;&#34;&#34;
        Create new graph by adding this graph and another graph.

        New graph has the same template as this graph&#39;s.
        On the other hand, because this method depends on `__iadd__()`, another graph must not have the same template.

        Args:
            another: Graph or its view.
        Returns:
            Created graph.
        &#34;&#34;&#34;
        graph = Graph(self.template)

        graph += self
        graph += another

        return graph

    def __iadd__(self, another: Union[Self, GraphView]) -&gt; Self:
        &#34;&#34;&#34;
        Append nodes from another graph.

        Nodes of another graph are traversed from its root and appended to compatible containers each other.

        Args:
            another: Graph or its view.
        Returns:
            This graph.
        &#34;&#34;&#34;
        graph = another if isinstance(another, Graph) else another()

        def add(n: Node, anc: dict[str, list[Node]]):
            c = self._container_of(n.prop)
            if c:
                c.append(n.entity, anc)
            for ch_ in n.children.values():
                for m in ch_.nodes:
                    add(m, anc.copy())

        for c_ in graph.roots:
            for n_ in c_.nodes:
                add(n_, {})

        return self

    @property
    def roots(self) -&gt; Iterable[&#39;NodeContainer&#39;]:
        &#34;&#34;&#34;
        Returns root node containers.
        &#34;&#34;&#34;
        return filter(lambda c: c.prop.parent is None, self.containers.values())

    @property
    def view(self) -&gt; GraphView:
        &#34;&#34;&#34;
        Returns an unmodifiable view of this graph.

        The view object works as the accessor to graph nodes.

        ```python
        &gt;&gt;&gt; template = GraphSpac().new_template(a=int, b=str, c=str)
        &gt;&gt;&gt; template.a &lt;&lt; template.b
        &gt;&gt;&gt; graph = new_graph(template)
        &gt;&gt;&gt; view = graph.view
        &gt;&gt;&gt; assert view() is graph                        # invocation
        &gt;&gt;&gt; assert view.a is graph.containers[&#34;a&#34;].view   # attribute
        &gt;&gt;&gt; assert [c().name for c in view] == [&#34;a&#34;, &#34;c&#34;] # iteration
        ```
        &#34;&#34;&#34;
        if self._view is None:
            graph = self
            class _GraphView:
                def __call__(self) -&gt; Graph:
                    &#34;&#34;&#34;Returns the greph of this view.&#34;&#34;&#34;
                    return graph
                def __iter__(self) -&gt; Iterator[tuple[str, ContainerView[NodeContainer]]]:
                    &#34;&#34;&#34;Iterates views of root containers.&#34;&#34;&#34;
                    return map(lambda c: (c.name, c.view), filter(lambda c: c.prop.parent is None, graph.containers.values()))
                def __getattr__(self, name: str) -&gt; ContainerView:
                    &#34;&#34;&#34;Returns a view of a container of the name.&#34;&#34;&#34;
                    return graph.containers[name].view
            self._view = _GraphView()
        return self._view

    def _append(self, to_replace: bool, entities: dict[str, Any]) -&gt; Self:
        props = [p for p in self.template if p.name in entities]

        filtered = set()
        for p in props:
            if (p.parent is None) or (p.parent.name not in entities) or (p.parent.name in filtered):
                if p.entity_filter is None or p.entity_filter(entities[p.name]):
                    filtered.add(p.name)

        ancestors = {}
        for k in [p.name for p in props if p.name in filtered]:
            self.containers[k].append(entities[k], ancestors, to_replace)

        return self

    def append(self, **entities: Any) -&gt; Self:
        &#34;&#34;&#34;
        Append entities with associated property names.

        Args:
            entities: Entities keyed with associated property names.
        Returns:
            This graph.
        &#34;&#34;&#34;
        return self._append(False, entities)

    def replace(self, **entities: Any) -&gt; Self:
        &#34;&#34;&#34;
        Works similarly to `append`, but entities of identical nodes are replaced with given entities.

        Args:
            entities: Entities keyed with associated property names.
        Returns:
            This graph.
        &#34;&#34;&#34;
        return self._append(True, entities)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.graph.Graph.containers"><code class="name">var <span class="ident">containers</span></code></dt>
<dd>
<div class="desc"><p>A <code>dict</code> containing node containers by their names.</p></div>
</dd>
<dt id="pyracmon.graph.Graph.roots"><code class="name">var <span class="ident">roots</span> : collections.abc.Iterable['NodeContainer']</code></dt>
<dd>
<div class="desc"><p>Returns root node containers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def roots(self) -&gt; Iterable[&#39;NodeContainer&#39;]:
    &#34;&#34;&#34;
    Returns root node containers.
    &#34;&#34;&#34;
    return filter(lambda c: c.prop.parent is None, self.containers.values())</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.Graph.template"><code class="name">var <span class="ident">template</span></code></dt>
<dd>
<div class="desc"><p>Graph template.</p></div>
</dd>
<dt id="pyracmon.graph.Graph.view"><code class="name">var <span class="ident">view</span> : <a title="pyracmon.graph.graph.GraphView" href="graph.html#pyracmon.graph.graph.GraphView">GraphView</a></code></dt>
<dd>
<div class="desc"><p>Returns an unmodifiable view of this graph.</p>
<p>The view object works as the accessor to graph nodes.</p>
<pre><code class="language-python">&gt;&gt;&gt; template = GraphSpac().new_template(a=int, b=str, c=str)
&gt;&gt;&gt; template.a &lt;&lt; template.b
&gt;&gt;&gt; graph = new_graph(template)
&gt;&gt;&gt; view = graph.view
&gt;&gt;&gt; assert view() is graph                        # invocation
&gt;&gt;&gt; assert view.a is graph.containers[&quot;a&quot;].view   # attribute
&gt;&gt;&gt; assert [c().name for c in view] == [&quot;a&quot;, &quot;c&quot;] # iteration
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def view(self) -&gt; GraphView:
    &#34;&#34;&#34;
    Returns an unmodifiable view of this graph.

    The view object works as the accessor to graph nodes.

    ```python
    &gt;&gt;&gt; template = GraphSpac().new_template(a=int, b=str, c=str)
    &gt;&gt;&gt; template.a &lt;&lt; template.b
    &gt;&gt;&gt; graph = new_graph(template)
    &gt;&gt;&gt; view = graph.view
    &gt;&gt;&gt; assert view() is graph                        # invocation
    &gt;&gt;&gt; assert view.a is graph.containers[&#34;a&#34;].view   # attribute
    &gt;&gt;&gt; assert [c().name for c in view] == [&#34;a&#34;, &#34;c&#34;] # iteration
    ```
    &#34;&#34;&#34;
    if self._view is None:
        graph = self
        class _GraphView:
            def __call__(self) -&gt; Graph:
                &#34;&#34;&#34;Returns the greph of this view.&#34;&#34;&#34;
                return graph
            def __iter__(self) -&gt; Iterator[tuple[str, ContainerView[NodeContainer]]]:
                &#34;&#34;&#34;Iterates views of root containers.&#34;&#34;&#34;
                return map(lambda c: (c.name, c.view), filter(lambda c: c.prop.parent is None, graph.containers.values()))
            def __getattr__(self, name: str) -&gt; ContainerView:
                &#34;&#34;&#34;Returns a view of a container of the name.&#34;&#34;&#34;
                return graph.containers[name].view
        self._view = _GraphView()
    return self._view</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.Graph.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, **entities: Any) ‑> typing_extensions.Self</span>
</code></dt>
<dd>
<div class="desc"><p>Append entities with associated property names.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entities</code></strong></dt>
<dd>Entities keyed with associated property names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, **entities: Any) -&gt; Self:
    &#34;&#34;&#34;
    Append entities with associated property names.

    Args:
        entities: Entities keyed with associated property names.
    Returns:
        This graph.
    &#34;&#34;&#34;
    return self._append(False, entities)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.Graph.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, **entities: Any) ‑> typing_extensions.Self</span>
</code></dt>
<dd>
<div class="desc"><p>Works similarly to <code>append</code>, but entities of identical nodes are replaced with given entities.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entities</code></strong></dt>
<dd>Entities keyed with associated property names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(self, **entities: Any) -&gt; Self:
    &#34;&#34;&#34;
    Works similarly to `append`, but entities of identical nodes are replaced with given entities.

    Args:
        entities: Entities keyed with associated property names.
    Returns:
        This graph.
    &#34;&#34;&#34;
    return self._append(True, entities)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.graph.GraphSpec"><code class="flex name class">
<span>class <span class="ident">GraphSpec</span></span>
<span>(</span><span>identifiers: Optional[list[tuple[type, typing.Callable[[typing.Any], typing.Any]]]] = None, entity_filters: Optional[list[tuple[type, typing.Callable[[typing.Any], bool]]]] = None, serializers: Optional[list[tuple[type, typing.Callable[[ForwardRef('NodeContext')], typing.Any]]]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This class contains the specifications of graph which control various behaviors in the lifecycles of graphs.</p>
<p>3 kinds of functions are the core of graph behaviors: <em>identifier</em>, <em>entity filter</em> and <em>serializer</em> .</p>
<p><em>Identifier</em> and <em>entity filter</em> are used when appending values into graph.
<em>Identifier</em> is a function to get a value used for the identification of graph entity. See <code><a title="pyracmon.graph.Graph" href="#pyracmon.graph.Graph">Graph</a></code> to know how this works.
<em>Entity fliter</em> is a function to determine whether the entity should be appended to a graph or not.
If <code>False</code> is returned for an entity, it is just ignored.</p>
<p>See <code><a title="pyracmon.graph.serialize" href="serialize.html">pyracmon.graph.serialize</a></code> to know the detail of <em>serializer</em>.</p>
<p>Each of them is bound to a <code>type</code> on registration to this and it affects nodes whose property type conforms to the <code>type</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphSpec:
    &#34;&#34;&#34;
    This class contains the specifications of graph which control various behaviors in the lifecycles of graphs.

    3 kinds of functions are the core of graph behaviors: *identifier*, *entity filter* and *serializer* .

    *Identifier* and *entity filter* are used when appending values into graph.
    *Identifier* is a function to get a value used for the identification of graph entity. See `Graph` to know how this works.
    *Entity fliter* is a function to determine whether the entity should be appended to a graph or not.
    If `False` is returned for an entity, it is just ignored.

    See `pyracmon.graph.serialize` to know the detail of *serializer*.

    Each of them is bound to a `type` on registration to this and it affects nodes whose property type conforms to the `type` .
    &#34;&#34;&#34;
    def __init__(
        self,
        identifiers: Optional[list[tuple[type, Identifier]]] = None,
        entity_filters: Optional[list[tuple[type, EntityFilter]]] = None,
        serializers: Optional[list[tuple[type, Serializer]]] = None,
    ):
        #: A list of pairs of type and *identifier*.
        self.identifiers: list[tuple[type, Identifier]] = identifiers or []
        #: A list of pairs of type and *entity_filter*.
        self.entity_filters: list[tuple[type, EntityFilter]] = entity_filters or []
        #: A list of pairs of type and *serializer*.
        self.serializers: list[tuple[type, Serializer]] = serializers or []

    def _get_inherited(self, holder: list[tuple[type, T]], t: type) -&gt; Optional[T]:
        if not isinstance(t, type):
            return None
        return next(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), holder)), None)

    def get_identifier(self, t: type) -&gt; Optional[Callable[[Any], Any]]:
        &#34;&#34;&#34;
        Returns the most appropriate identifier for a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Identifier if exists.
        &#34;&#34;&#34;
        return self._get_inherited(self.identifiers, t)

    def get_entity_filter(self, t: type) -&gt; Optional[Callable[[Any], bool]]:
        &#34;&#34;&#34;
        Returns the most appropriate entity filter for a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Entity filter if exists.
        &#34;&#34;&#34;
        return self._get_inherited(self.entity_filters, t)

    def find_serializers(self, t: type) -&gt; list[Serializer]:
        &#34;&#34;&#34;
        Returns a list of serializers applicable to a type.
        
        Args:
            t: Type of an entity.
        Returns:
            Serializers found.
        &#34;&#34;&#34;
        if not isinstance(t, type):
            return []
        return list(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), self.serializers[::-1])))

    def add_identifier(self, c: type, f: Callable[[Any], Any]) -&gt; Self:
        &#34;&#34;&#34;
        Register an identifier with a type.

        Args:
            c: A type bound to the identifier.
            f: An identifier function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self.identifiers[0:0] = [(c, f)]
        return self

    def add_entity_filter(self, c: type, f: Callable[[Any], bool]) -&gt; Self:
        &#34;&#34;&#34;
        Register an entity filter with a type.

        Args:
            c: A type bound to the identifier.
            f: An entity filter function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self.entity_filters[0:0] = [(c, f)]
        return self

    def add_serializer(self, c: type, f: Union[Serializer, NodeSerializer]) -&gt; Self:
        &#34;&#34;&#34;
        Register a serializer with a type.

        Args:
            c: A type bound to the identifier.
            f: A serializer function.
        Returns:
            This instance.
        &#34;&#34;&#34;
        if isinstance(f, NodeSerializer):
            f = f.serializer
        self.serializers[0:0] = [(c, f)]
        return self

    def _make_policy(self, t: type, f: Union[IdentifyPolicy, Callable[[Any], Any], None]) -&gt; IdentifyPolicy:
        f = f or self.get_identifier(t)

        if isinstance(f, IdentifyPolicy):
            return f
        elif callable(f):
            return HierarchicalPolicy(f)
        else:
            return neverPolicy()

    def _get_property_definition(self, definition: Union[
        TemplateProperty,
        type,
        GraphTemplate,
    ]) -&gt; tuple[TypeDef, IdentifyPolicy, Optional[EntityFilter]]:
        if isinstance(definition, GraphTemplate):
            return definition, neverPolicy(), None
        elif isinstance(definition, type):
            return definition, self._make_policy(definition, None), self.get_entity_filter(definition)
        elif isinstance(definition, tuple):
            # python &lt; 3.10
            if len(definition) == 3:
                kind, identifier, entity_filter = definition
            elif len(definition) == 2:
                kind, identifier, entity_filter = definition + (None,)
            elif len(definition) == 1:
                kind, identifier, entity_filter = definition + (None, None)
            elif len(definition) == 0:
                kind, identifier, entity_filter = (object, None, None)
            else:
                raise ValueError(f&#34;Invalid value was found in keyword arguments of new_template().&#34;)
            # python &gt;= 3.10
            #match definition:
            #    case (k, ident, ef):
            #        kind = k; identifier = ident; entity_filter = ef
            #    case (k, ident):
            #        kind = k; identifier = ident; entity_filter = None
            #    case (k,):
            #        kind = k; identifier = None; entity_filter = None
            #    case ():
            #        kind = object; identifier = None; entity_filter = None
            #    case _:
            #        raise ValueError(f&#34;Invalid value was found in keyword arguments of new_template().&#34;)
            return kind, self._make_policy(kind, identifier), entity_filter or self.get_entity_filter(kind)
        else:
            raise ValueError(f&#34;Invalid value was found in keyword arguments of new_template().&#34;)

    def new_template(self, *bases: GraphTemplate, **properties: Union[TemplateProperty, type, GraphTemplate]) -&gt; GraphTemplate:
        &#34;&#34;&#34;
        Creates a graph template with definitions of template properties.

        Each keyword argument corresponds to a template property where the key is proprety name and value is property definition.

        Property definition can be a `type` object or a tuple of at most 3 values.
        The former is the equivalent to a tuple which contains the `type` object alone.
        Values in the tuple are interpreted into following attributes in order.

        - The kind of property which indicates a type of entity.
        - *Identifier* of the property.
        - *Entity filter* of the property. 

        Omitted values are completed with registered items in this object.

        ```python
        template = GraphSpac().new_template(
            a = int,
            b = (str, lambda x:x),
            c = (str, lambda x:x, lambda x:len(x)&gt;5),
        )
        ```

        Args:
            bases: Base templates whose properties and relations are merged into new template.
            properties: Definitions of template properties.
        Returns:
            Created graph template.
        &#34;&#34;&#34;
        base = sum(bases, GraphTemplate([]))

        return base + GraphTemplate([(n, *self._get_property_definition(d)) for n, d in properties.items()])

    def to_dict(self, graph: GraphView, _params_: dict[str, dict[str, Any]] = {}, **settings: NodeSerializer) -&gt; dict[str, Any]:
        &#34;&#34;&#34;
        Serialize a graph into a `dict` .

        Only nodes whose names appear in keys of `settings` are serialized into the result.
        Each `NodeSerializer` object can be built by factory methods on `pyracmon.graph.serialize.S`.

        ```python
        GraphSpec().to_dict(
            graph,
            a = S.of(),
            b = S.name(&#34;B&#34;),
        )
        ```

        Args:
            graph: A view of the graph.
            _params_: Parameters passed to `SerializationContext` and used by *serializer*s.
            settings: `NodeSerializer` for each property.
        Returns:
            Serialization result.
        &#34;&#34;&#34;
        return SerializationContext(settings, self.find_serializers, _params_).execute(graph)

    def to_schema(self, template: GraphTemplate, **settings: NodeSerializer) -&gt; GraphSchema:
        &#34;&#34;&#34;
        Creates `GraphSchema` representing the structure of serialization result under given settings.

        Args:
            template: Template of a graph.
            settings: `NodeSerializer` for each property.
        Returns:
            Schema of serialization result.
        &#34;&#34;&#34;
        return GraphSchema(self, template, **settings)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.model_graph.ConfigurableSpec" href="../model_graph.html#pyracmon.model_graph.ConfigurableSpec">ConfigurableSpec</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.graph.GraphSpec.entity_filters"><code class="name">var <span class="ident">entity_filters</span></code></dt>
<dd>
<div class="desc"><p>A list of pairs of type and <em>entity_filter</em>.</p></div>
</dd>
<dt id="pyracmon.graph.GraphSpec.identifiers"><code class="name">var <span class="ident">identifiers</span></code></dt>
<dd>
<div class="desc"><p>A list of pairs of type and <em>identifier</em>.</p></div>
</dd>
<dt id="pyracmon.graph.GraphSpec.serializers"><code class="name">var <span class="ident">serializers</span></code></dt>
<dd>
<div class="desc"><p>A list of pairs of type and <em>serializer</em>.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.GraphSpec.add_entity_filter"><code class="name flex">
<span>def <span class="ident">add_entity_filter</span></span>(<span>self, c: type, f: Callable[[Any], bool]) ‑> typing_extensions.Self</span>
</code></dt>
<dd>
<div class="desc"><p>Register an entity filter with a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd>A type bound to the identifier.</dd>
<dt><strong><code>f</code></strong></dt>
<dd>An entity filter function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_entity_filter(self, c: type, f: Callable[[Any], bool]) -&gt; Self:
    &#34;&#34;&#34;
    Register an entity filter with a type.

    Args:
        c: A type bound to the identifier.
        f: An entity filter function.
    Returns:
        This instance.
    &#34;&#34;&#34;
    self.entity_filters[0:0] = [(c, f)]
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.add_identifier"><code class="name flex">
<span>def <span class="ident">add_identifier</span></span>(<span>self, c: type, f: Callable[[Any], Any]) ‑> typing_extensions.Self</span>
</code></dt>
<dd>
<div class="desc"><p>Register an identifier with a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd>A type bound to the identifier.</dd>
<dt><strong><code>f</code></strong></dt>
<dd>An identifier function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_identifier(self, c: type, f: Callable[[Any], Any]) -&gt; Self:
    &#34;&#34;&#34;
    Register an identifier with a type.

    Args:
        c: A type bound to the identifier.
        f: An identifier function.
    Returns:
        This instance.
    &#34;&#34;&#34;
    self.identifiers[0:0] = [(c, f)]
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.add_serializer"><code class="name flex">
<span>def <span class="ident">add_serializer</span></span>(<span>self, c: type, f: Union[Callable[[ForwardRef('NodeContext')], Any], <a title="pyracmon.graph.serialize.NodeSerializer" href="serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>]) ‑> typing_extensions.Self</span>
</code></dt>
<dd>
<div class="desc"><p>Register a serializer with a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong></dt>
<dd>A type bound to the identifier.</dd>
<dt><strong><code>f</code></strong></dt>
<dd>A serializer function.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_serializer(self, c: type, f: Union[Serializer, NodeSerializer]) -&gt; Self:
    &#34;&#34;&#34;
    Register a serializer with a type.

    Args:
        c: A type bound to the identifier.
        f: A serializer function.
    Returns:
        This instance.
    &#34;&#34;&#34;
    if isinstance(f, NodeSerializer):
        f = f.serializer
    self.serializers[0:0] = [(c, f)]
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.find_serializers"><code class="name flex">
<span>def <span class="ident">find_serializers</span></span>(<span>self, t: type) ‑> list[typing.Callable[[<a title="pyracmon.graph.serialize.NodeContext" href="serialize.html#pyracmon.graph.serialize.NodeContext">NodeContext</a>], typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a list of serializers applicable to a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Type of an entity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Serializers found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_serializers(self, t: type) -&gt; list[Serializer]:
    &#34;&#34;&#34;
    Returns a list of serializers applicable to a type.
    
    Args:
        t: Type of an entity.
    Returns:
        Serializers found.
    &#34;&#34;&#34;
    if not isinstance(t, type):
        return []
    return list(map(lambda x:x[1], filter(lambda x:issubtype(t, x[0]), self.serializers[::-1])))</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.get_entity_filter"><code class="name flex">
<span>def <span class="ident">get_entity_filter</span></span>(<span>self, t: type) ‑> Optional[Callable[[Any], bool]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the most appropriate entity filter for a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Type of an entity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Entity filter if exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_entity_filter(self, t: type) -&gt; Optional[Callable[[Any], bool]]:
    &#34;&#34;&#34;
    Returns the most appropriate entity filter for a type.
    
    Args:
        t: Type of an entity.
    Returns:
        Entity filter if exists.
    &#34;&#34;&#34;
    return self._get_inherited(self.entity_filters, t)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.get_identifier"><code class="name flex">
<span>def <span class="ident">get_identifier</span></span>(<span>self, t: type) ‑> Optional[Callable[[Any], Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the most appropriate identifier for a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>Type of an entity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Identifier if exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_identifier(self, t: type) -&gt; Optional[Callable[[Any], Any]]:
    &#34;&#34;&#34;
    Returns the most appropriate identifier for a type.
    
    Args:
        t: Type of an entity.
    Returns:
        Identifier if exists.
    &#34;&#34;&#34;
    return self._get_inherited(self.identifiers, t)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.new_template"><code class="name flex">
<span>def <span class="ident">new_template</span></span>(<span>self, *bases: <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, **properties: Union[type, tuple[()], tuple[type], tuple[type, Optional[Callable[[Any], Any]]], tuple[type, Optional[Callable[[Any], Any]], Optional[Callable[[Any], bool]]], <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>]) ‑> <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a graph template with definitions of template properties.</p>
<p>Each keyword argument corresponds to a template property where the key is proprety name and value is property definition.</p>
<p>Property definition can be a <code>type</code> object or a tuple of at most 3 values.
The former is the equivalent to a tuple which contains the <code>type</code> object alone.
Values in the tuple are interpreted into following attributes in order.</p>
<ul>
<li>The kind of property which indicates a type of entity.</li>
<li><em>Identifier</em> of the property.</li>
<li><em>Entity filter</em> of the property. </li>
</ul>
<p>Omitted values are completed with registered items in this object.</p>
<pre><code class="language-python">template = GraphSpac().new_template(
    a = int,
    b = (str, lambda x:x),
    c = (str, lambda x:x, lambda x:len(x)&gt;5),
)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bases</code></strong></dt>
<dd>Base templates whose properties and relations are merged into new template.</dd>
<dt><strong><code>properties</code></strong></dt>
<dd>Definitions of template properties.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Created graph template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_template(self, *bases: GraphTemplate, **properties: Union[TemplateProperty, type, GraphTemplate]) -&gt; GraphTemplate:
    &#34;&#34;&#34;
    Creates a graph template with definitions of template properties.

    Each keyword argument corresponds to a template property where the key is proprety name and value is property definition.

    Property definition can be a `type` object or a tuple of at most 3 values.
    The former is the equivalent to a tuple which contains the `type` object alone.
    Values in the tuple are interpreted into following attributes in order.

    - The kind of property which indicates a type of entity.
    - *Identifier* of the property.
    - *Entity filter* of the property. 

    Omitted values are completed with registered items in this object.

    ```python
    template = GraphSpac().new_template(
        a = int,
        b = (str, lambda x:x),
        c = (str, lambda x:x, lambda x:len(x)&gt;5),
    )
    ```

    Args:
        bases: Base templates whose properties and relations are merged into new template.
        properties: Definitions of template properties.
    Returns:
        Created graph template.
    &#34;&#34;&#34;
    base = sum(bases, GraphTemplate([]))

    return base + GraphTemplate([(n, *self._get_property_definition(d)) for n, d in properties.items()])</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.to_dict"><code class="name flex">
<span>def <span class="ident">to_dict</span></span>(<span>self, graph: <a title="pyracmon.graph.graph.GraphView" href="graph.html#pyracmon.graph.graph.GraphView">GraphView</a>, **settings: <a title="pyracmon.graph.serialize.NodeSerializer" href="serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize a graph into a <code>dict</code> .</p>
<p>Only nodes whose names appear in keys of <code>settings</code> are serialized into the result.
Each <code>NodeSerializer</code> object can be built by factory methods on <code><a title="pyracmon.graph.serialize.S" href="serialize.html#pyracmon.graph.serialize.S">S</a></code>.</p>
<pre><code class="language-python">GraphSpec().to_dict(
    graph,
    a = S.of(),
    b = S.name(&quot;B&quot;),
)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>A view of the graph.</dd>
<dt><strong><code>_params_</code></strong></dt>
<dd>Parameters passed to <code>SerializationContext</code> and used by <em>serializer</em>s.</dd>
<dt><strong><code>settings</code></strong></dt>
<dd><code>NodeSerializer</code> for each property.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Serialization result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_dict(self, graph: GraphView, _params_: dict[str, dict[str, Any]] = {}, **settings: NodeSerializer) -&gt; dict[str, Any]:
    &#34;&#34;&#34;
    Serialize a graph into a `dict` .

    Only nodes whose names appear in keys of `settings` are serialized into the result.
    Each `NodeSerializer` object can be built by factory methods on `pyracmon.graph.serialize.S`.

    ```python
    GraphSpec().to_dict(
        graph,
        a = S.of(),
        b = S.name(&#34;B&#34;),
    )
    ```

    Args:
        graph: A view of the graph.
        _params_: Parameters passed to `SerializationContext` and used by *serializer*s.
        settings: `NodeSerializer` for each property.
    Returns:
        Serialization result.
    &#34;&#34;&#34;
    return SerializationContext(settings, self.find_serializers, _params_).execute(graph)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.GraphSpec.to_schema"><code class="name flex">
<span>def <span class="ident">to_schema</span></span>(<span>self, template: <a title="pyracmon.graph.template.GraphTemplate" href="template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, **settings: <a title="pyracmon.graph.serialize.NodeSerializer" href="serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>) ‑> <a title="pyracmon.graph.schema.GraphSchema" href="schema.html#pyracmon.graph.schema.GraphSchema">GraphSchema</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates <code>GraphSchema</code> representing the structure of serialization result under given settings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template</code></strong></dt>
<dd>Template of a graph.</dd>
<dt><strong><code>settings</code></strong></dt>
<dd><code>NodeSerializer</code> for each property.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Schema of serialization result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_schema(self, template: GraphTemplate, **settings: NodeSerializer) -&gt; GraphSchema:
    &#34;&#34;&#34;
    Creates `GraphSchema` representing the structure of serialization result under given settings.

    Args:
        template: Template of a graph.
        settings: `NodeSerializer` for each property.
    Returns:
        Schema of serialization result.
    &#34;&#34;&#34;
    return GraphSchema(self, template, **settings)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.graph.GraphTemplate"><code class="flex name class">
<span>class <span class="ident">GraphTemplate</span></span>
<span>(</span><span>definitions: list[tuple[str, typing.Union[type[~T], typing_extensions.Self, <a title="pyracmon.graph.template.GraphTemplate.Property" href="template.html#pyracmon.graph.template.GraphTemplate.Property">GraphTemplate.Property</a>], typing.Optional[<a title="pyracmon.graph.identify.IdentifyPolicy" href="identify.html#pyracmon.graph.identify.IdentifyPolicy">IdentifyPolicy</a>], typing.Optional[typing.Callable[[~T], bool]]]])</span>
</code></dt>
<dd>
<div class="desc"><p>This class specifies the structure of a graph.</p>
<p>The template is composed of template properties each of which corresponds to a node container of a graph.
Each template property can be obtained via an attribute of its name from the template.</p>
<p>Applying shift operator between properties creates the parent-child relationship between them.
In next code, the template is composed of 4 properties where <code>d</code> is a child of <code>c</code>, and <code>b</code> and <code>c</code> are children of <code>a</code>.</p>
<pre><code class="language-python">template = GraphSpec().new_template(a=int, b=str, c=int, d=float)
template.a &lt;&lt; [template.b, template.c]
template.c &lt;&lt; template.d
</code></pre>
<p>Templates are merged when <code>+</code> is applied to them. The result has properties defined in both templates with keeping their relationships.
Merging of templates having properties of the same name fails by raising <code>ValueError</code>.</p>
<p>Use <code><a title="pyracmon.graph.GraphSpec.new_template" href="#pyracmon.graph.GraphSpec.new_template">GraphSpec.new_template()</a></code> or other factory functions to create a template instead of using constructor directly.</p>
<p>Construct template with its properties.
Don't use this constructor directly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>definitions</code></strong></dt>
<dd>Definitions of template properties.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphTemplate:
    &#34;&#34;&#34;
    This class specifies the structure of a graph.

    The template is composed of template properties each of which corresponds to a node container of a graph.
    Each template property can be obtained via an attribute of its name from the template.

    Applying shift operator between properties creates the parent-child relationship between them.
    In next code, the template is composed of 4 properties where `d` is a child of `c`, and `b` and `c` are children of `a`.

    ```python
    template = GraphSpec().new_template(a=int, b=str, c=int, d=float)
    template.a &lt;&lt; [template.b, template.c]
    template.c &lt;&lt; template.d
    ```

    Templates are merged when `+` is applied to them. The result has properties defined in both templates with keeping their relationships.
    Merging of templates having properties of the same name fails by raising `ValueError`.

    Use `GraphSpec.new_template` or other factory functions to create a template instead of using constructor directly.
    &#34;&#34;&#34;
    class Property:
        &#34;&#34;&#34;
        Template property which determines various behaviors of graph nodes.
        &#34;&#34;&#34;
        def __init__(
            self,
            template: &#39;GraphTemplate&#39;,
            name: str,
            kind: Union[type[T], &#39;GraphTemplate&#39;],
            policy: IdentifyPolicy,
            entity_filter: Optional[Callable[[T], bool]],
            origin: Optional[Self] = None,
        ):
            #: Graph template this property belongs to.
            self.template = template
            #: Property name.
            self.name = name
            #: Graph node bound to this property should have entity of this type.
            self.kind = kind
            #: Policy of entity identification.
            self.policy = policy
            #: Entity filter function.
            self.entity_filter = entity_filter
            self._origin = origin

        def _assert_canbe_parent(self, another):
            if another.parent is not None:
                raise ValueError(f&#34;Graph template property can not have multiple parents.&#34;)
            if self.template != another.template:
                raise ValueError(f&#34;Properties can make parent-child relationship only when they are declared in the same template.&#34;)
            if self == another:
                raise ValueError(f&#34;Recursive relationship is not allowed.&#34;)
            if isinstance(self.kind, GraphTemplate):
                raise ValueError(f&#34;Property for graph template can&#39;t have child.&#34;)
            p = self
            while p.parent is not None:
                if p.parent == another:
                    raise ValueError(f&#34;Recursive relationship is not allowed.&#34;)
                p = p.parent

        @property
        def parents(self) -&gt; Iterable[&#39;GraphTemplate.Property&#39;]:
            &#34;&#34;&#34;
            Returns all parent properties.
            &#34;&#34;&#34;
            return map(lambda r: r[1], filter(lambda r: r[0] == self, self.template._relations))

        @property
        def parent(self) -&gt; Optional[&#39;GraphTemplate.Property&#39;]:
            &#34;&#34;&#34;
            Returns parent property if exists.
            &#34;&#34;&#34;
            return next(iter(self.parents), None)

        @property
        def children(self) -&gt; list[&#39;GraphTemplate.Property&#39;]:
            &#34;&#34;&#34;
            Returns child properties.
            &#34;&#34;&#34;
            return [r[0] for r in self.template._relations if r[1] == self]

        @property
        def origin(self) -&gt; &#39;GraphTemplate.Property&#39;:
            &#34;&#34;&#34;
            Returns the original property in the property chain generated by adding templates.
            &#34;&#34;&#34;
            p = self
            while p._origin:
                p = p._origin
            return p

        def is_compatible(self, other):
            return self.origin is other.origin

        def _move_template(self, dest: &#39;GraphTemplate&#39;, new_name=None) -&gt; &#39;GraphTemplate.Property&#39;:
            &#34;&#34;&#34;
            Copy this property and children with setting their templates to `dest` .
            &#34;&#34;&#34;
            new_name = new_name or self.name
            prop = GraphTemplate.Property(dest, new_name, self.kind, self.policy, self.entity_filter, origin=self)
            _set_template_property(dest, prop)
            for c in self.children:
                cc = c._move_template(dest)
                prop &lt;&lt; cc # pyright: ignore [reportUnusedExpression]
            return prop

        @overload
        def __lshift__(self, children: &#39;GraphTemplate.Property&#39;) -&gt; &#39;GraphTemplate.Property&#39;: ...
        @overload
        def __lshift__(self, children: list[&#39;GraphTemplate.Property&#39;]) -&gt; list[&#39;GraphTemplate.Property&#39;]: ...
        def __lshift__(self, children: Union[&#39;GraphTemplate.Property&#39;, list[&#39;GraphTemplate.Property&#39;]]) -&gt; Union[&#39;GraphTemplate.Property&#39;, list[&#39;GraphTemplate.Property&#39;]]:
            &#34;&#34;&#34;
            Makes this property as a parent of given properties.

            Args:
                children: Property or properties to be children of this property.
            Returns:
                The same object as the argument.
            &#34;&#34;&#34;
            targets = [children] if isinstance(children, GraphTemplate.Property) else children
            for c in targets:
                self._assert_canbe_parent(c)
            self.template._relations += [(c, self) for c in targets]
            return children

        def __rshift__(self, parent: &#39;GraphTemplate.Property&#39;) -&gt; &#39;GraphTemplate.Property&#39;:
            &#34;&#34;&#34;
            Makes this property as a child of another property.

            Args:
                parent: A Property to be a parent of this property.
            Returns:
                The same object as the argument.
            &#34;&#34;&#34;
            parent._assert_canbe_parent(self)
            self.template._relations += [(self, parent)]
            return parent

        def __rrshift__(self, children: Union[&#39;GraphTemplate.Property&#39;, list[&#39;GraphTemplate.Property&#39;]]) -&gt; &#39;GraphTemplate.Property&#39;:
            &#34;&#34;&#34;
            Reversed version of `__lshift__()` prepared to locate a list of properties on the left side.

            Args:
                children: Property or properties to be children of this property.
            Returns:
                The same object as the argument.
            &#34;&#34;&#34;
            self.__lshift__(children)
            return self

    def __init__(self, definitions: list[tuple[
        str,
        Union[type[T], Self, Property],
        Optional[IdentifyPolicy],
        Optional[Callable[[T], bool]],
    ]]):
        &#34;&#34;&#34;
        Construct template with its properties.  Don&#39;t use this constructor directly.

        Args:
            definitions: Definitions of template properties.
        &#34;&#34;&#34;
        self._properties: dict[str, GraphTemplate.Property] = {}
        self._relations: list[tuple[GraphTemplate.Property, GraphTemplate.Property]] = []

        for d in definitions:
            name, kind, ident, ef = d

            ident = ident or neverPolicy()

            if isinstance(kind, GraphTemplate):
                prop = GraphTemplate.Property(self, name, kind, ident, None)
                _set_template_property(self, prop)
            elif isinstance(kind, GraphTemplate.Property):
                kind._move_template(self, name)
            else:
                _set_template_property(self, GraphTemplate.Property(self, name, kind, ident, ef))

    def __getattr__(self, key) -&gt; &#39;GraphTemplate.Property&#39;:
        return self._properties[key]

    def __iter__(self) -&gt; Iterator[&#39;GraphTemplate.Property&#39;]:
        &#34;&#34;&#34;
        Iterates properties in parent-to-child order.

        Returns:
            Property iterator.
        &#34;&#34;&#34;
        return _walk_properties(self._properties)

    def __iadd__(self, another: &#39;GraphTemplate&#39;) -&gt; Self:
        &#34;&#34;&#34;
        Adds another template to this template.

        Args:
            another: Another template.
        Returns:
            This instance.
        &#34;&#34;&#34;
        for p in another._properties.values():
            prop = GraphTemplate.Property(self, p.name, p.kind, p.policy, p.entity_filter, origin=p)
            _set_template_property(self, prop)

        for n, p in another._relations:
            getattr(self, n.name) &gt;&gt; getattr(self, p.name) # pyright: ignore [reportUnusedExpression]

        return self

    def __add__(self, another: &#39;GraphTemplate&#39;) -&gt; &#39;GraphTemplate&#39;:
        &#34;&#34;&#34;
        Creates new template by merging this template and another one.

        Args:
            another: Another template.
        Returns:
            New template.
        &#34;&#34;&#34;
        template = GraphTemplate([])
        template += self
        template += another

        return template</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyracmon.graph.GraphTemplate.Property"><code class="name">var <span class="ident">Property</span></code></dt>
<dd>
<div class="desc"><p>Template property which determines various behaviors of graph nodes.</p></div>
</dd>
</dl>
</dd>
<dt id="pyracmon.graph.IdentifyPolicy"><code class="flex name class">
<span>class <span class="ident">IdentifyPolicy</span></span>
<span>(</span><span>identifier: Optional[Callable[[Any], Any]])</span>
</code></dt>
<dd>
<div class="desc"><p>Provides entity identification functionalities used during appending entities to a graph.</p>
<p>Identification mechanism is based on the equality of identification keys extracted by entities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IdentifyPolicy:
    &#34;&#34;&#34;
    Provides entity identification functionalities used during appending entities to a graph.

    Identification mechanism is based on the equality of identification keys extracted by entities.
    &#34;&#34;&#34;
    def __init__(self, identifier: Optional[Callable[[Any], Any]]):
        #: A function to extract the identification key from an entity.
        self.identifier = identifier

    def get_identifier(self, value: Any) -&gt; Any:
        &#34;&#34;&#34;
        Returns identification key from an entity.

        Args:
            value: An entity.
        Returns:
            Identification key.
        &#34;&#34;&#34;
        return self.identifier(value) if self.identifier else None

    def identify(
        self,
        prop: NodePropType,
        candidates: Iterable[MN],
        ancestors: Mapping[str, Iterable[MapNodeType[MapNodeType[MN, str], str]]],
    ) -&gt; tuple[list[Optional[MN]], list[MN]]:
        &#34;&#34;&#34;
        Select parent nodes and identical nodes of a new entity.

        This method is called during appending an entity to a graph.

        Args:
            prop: Template property for new entity.
            candidates: Nodes having the same identification key as the key of new entity.
            ancestors: Parent nodes mapped by property names.
        Returns
            The first item is a list of Parent nodes to which the node of new entity should be appended newly.
            `None` means to append a new node without parent. The second item is a list of identical nodes,
            which will be merged into ancestors and used in subsequent identifications of child entities.
        &#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.graph.identify.AlwaysPolicy" href="identify.html#pyracmon.graph.identify.AlwaysPolicy">AlwaysPolicy</a></li>
<li><a title="pyracmon.graph.identify.HierarchicalPolicy" href="identify.html#pyracmon.graph.identify.HierarchicalPolicy">HierarchicalPolicy</a></li>
<li><a title="pyracmon.graph.identify.NeverPolicy" href="identify.html#pyracmon.graph.identify.NeverPolicy">NeverPolicy</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.graph.IdentifyPolicy.identifier"><code class="name">var <span class="ident">identifier</span></code></dt>
<dd>
<div class="desc"><p>A function to extract the identification key from an entity.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.IdentifyPolicy.get_identifier"><code class="name flex">
<span>def <span class="ident">get_identifier</span></span>(<span>self, value: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Returns identification key from an entity.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>An entity.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Identification key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_identifier(self, value: Any) -&gt; Any:
    &#34;&#34;&#34;
    Returns identification key from an entity.

    Args:
        value: An entity.
    Returns:
        Identification key.
    &#34;&#34;&#34;
    return self.identifier(value) if self.identifier else None</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.IdentifyPolicy.identify"><code class="name flex">
<span>def <span class="ident">identify</span></span>(<span>self, prop: <a title="pyracmon.graph.protocol.NodePropType" href="protocol.html#pyracmon.graph.protocol.NodePropType">NodePropType</a>, candidates: collections.abc.Iterable[+MN], ancestors: collections.abc.Mapping[str, collections.abc.Iterable[<a title="pyracmon.graph.protocol.MapNodeType" href="protocol.html#pyracmon.graph.protocol.MapNodeType">MapNodeType</a>[<a title="pyracmon.graph.protocol.MapNodeType" href="protocol.html#pyracmon.graph.protocol.MapNodeType">MapNodeType</a>[+MN, str], str]]]) ‑> tuple[list[typing.Optional[+MN]], list[+MN]]</span>
</code></dt>
<dd>
<div class="desc"><p>Select parent nodes and identical nodes of a new entity.</p>
<p>This method is called during appending an entity to a graph.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>prop</code></strong></dt>
<dd>Template property for new entity.</dd>
<dt><strong><code>candidates</code></strong></dt>
<dd>Nodes having the same identification key as the key of new entity.</dd>
<dt><strong><code>ancestors</code></strong></dt>
<dd>Parent nodes mapped by property names.</dd>
</dl>
<p>Returns
The first item is a list of Parent nodes to which the node of new entity should be appended newly.
<code>None</code> means to append a new node without parent. The second item is a list of identical nodes,
which will be merged into ancestors and used in subsequent identifications of child entities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identify(
    self,
    prop: NodePropType,
    candidates: Iterable[MN],
    ancestors: Mapping[str, Iterable[MapNodeType[MapNodeType[MN, str], str]]],
) -&gt; tuple[list[Optional[MN]], list[MN]]:
    &#34;&#34;&#34;
    Select parent nodes and identical nodes of a new entity.

    This method is called during appending an entity to a graph.

    Args:
        prop: Template property for new entity.
        candidates: Nodes having the same identification key as the key of new entity.
        ancestors: Parent nodes mapped by property names.
    Returns
        The first item is a list of Parent nodes to which the node of new entity should be appended newly.
        `None` means to append a new node without parent. The second item is a list of identical nodes,
        which will be merged into ancestors and used in subsequent identifications of child entities.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.graph.S"><code class="flex name class">
<span>class <span class="ident">S</span></span>
</code></dt>
<dd>
<div class="desc"><p>An utility class to build <code>NodeSerializer</code> .</p>
<p>This class provides factory class methods to create <code>NodeSerializer</code>
each of which works in the same way as the method of the same name declared on <code>NodeSerializer</code> .</p>
<p>Use them to supply <code>NodeSerializer</code>s to functions to serialize a graph or to create a graph schema
such as <code>graph_dict</code> or <code>graph_schema</code> .</p>
<pre><code class="language-python">graph_dict(
    graph,
    a = S.of(),
    b = S.head(),
)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class S(metaclass=SerializerMeta):
    &#34;&#34;&#34;
    An utility class to build `NodeSerializer` .

    This class provides factory class methods to create `NodeSerializer`
    each of which works in the same way as the method of the same name declared on `NodeSerializer` .

    Use them to supply `NodeSerializer`s to functions to serialize a graph or to create a graph schema
    such as `graph_dict` or `graph_schema` .

    ```python
    graph_dict(
        graph,
        a = S.of(),
        b = S.head(),
    )
    ```
    &#34;&#34;&#34;
    @classmethod
    def of(
        cls,
        namer: Optional[Union[str, Callable[[str], str]]] = None,
        aggregator: Optional[Union[Callable[[list[Node]], Node], Callable[[list[Node]], list[Node]]]] = None,
        *serializers: Serializer,
    ) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Create an instance of `NodeSerializer`.

        Args:
            namer: A string or naming function.
            aggregator: An aggregation function or an index of node to select in node container.
            serializer: A list of *serializer* s.
        Returns:
            Created `NodeSerializer` .
        &#34;&#34;&#34;
        return NodeSerializer(namer, aggregator, *serializers)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.graph.S.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>namer: Union[str, Callable[[str], str], ForwardRef(None)] = None, aggregator: Union[Callable[[list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]], <a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>], Callable[[list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]], list[<a title="pyracmon.graph.graph.Node" href="graph.html#pyracmon.graph.graph.Node">Node</a>]], ForwardRef(None)] = None, *serializers: Callable[[ForwardRef('NodeContext')], Any]) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create an instance of <code>NodeSerializer</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>namer</code></strong></dt>
<dd>A string or naming function.</dd>
<dt><strong><code>aggregator</code></strong></dt>
<dd>An aggregation function or an index of node to select in node container.</dd>
<dt><strong><code>serializer</code></strong></dt>
<dd>A list of <em>serializer</em> s.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Created <code>NodeSerializer</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def of(
    cls,
    namer: Optional[Union[str, Callable[[str], str]]] = None,
    aggregator: Optional[Union[Callable[[list[Node]], Node], Callable[[list[Node]], list[Node]]]] = None,
    *serializers: Serializer,
) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Create an instance of `NodeSerializer`.

    Args:
        namer: A string or naming function.
        aggregator: An aggregation function or an index of node to select in node container.
        serializer: A list of *serializer* s.
    Returns:
        Created `NodeSerializer` .
    &#34;&#34;&#34;
    return NodeSerializer(namer, aggregator, *serializers)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.graph.S.alter"><code class="name flex">
<span>def <span class="ident">alter</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.doc"><code class="name flex">
<span>def <span class="ident">doc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.each"><code class="name flex">
<span>def <span class="ident">each</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.last"><code class="name flex">
<span>def <span class="ident">last</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.name"><code class="name flex">
<span>def <span class="ident">name</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph.S.sub"><code class="name flex">
<span>def <span class="ident">sub</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyracmon" href="../index.html">pyracmon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyracmon.graph.graph" href="graph.html">pyracmon.graph.graph</a></code></li>
<li><code><a title="pyracmon.graph.identify" href="identify.html">pyracmon.graph.identify</a></code></li>
<li><code><a title="pyracmon.graph.protocol" href="protocol.html">pyracmon.graph.protocol</a></code></li>
<li><code><a title="pyracmon.graph.schema" href="schema.html">pyracmon.graph.schema</a></code></li>
<li><code><a title="pyracmon.graph.serialize" href="serialize.html">pyracmon.graph.serialize</a></code></li>
<li><code><a title="pyracmon.graph.spec" href="spec.html">pyracmon.graph.spec</a></code></li>
<li><code><a title="pyracmon.graph.stub" href="stub.html">pyracmon.graph.stub</a></code></li>
<li><code><a title="pyracmon.graph.template" href="template.html">pyracmon.graph.template</a></code></li>
<li><code><a title="pyracmon.graph.typing" href="typing.html">pyracmon.graph.typing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyracmon.graph.new_graph" href="#pyracmon.graph.new_graph">new_graph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyracmon.graph.Graph" href="#pyracmon.graph.Graph">Graph</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.graph.Graph.append" href="#pyracmon.graph.Graph.append">append</a></code></li>
<li><code><a title="pyracmon.graph.Graph.containers" href="#pyracmon.graph.Graph.containers">containers</a></code></li>
<li><code><a title="pyracmon.graph.Graph.replace" href="#pyracmon.graph.Graph.replace">replace</a></code></li>
<li><code><a title="pyracmon.graph.Graph.roots" href="#pyracmon.graph.Graph.roots">roots</a></code></li>
<li><code><a title="pyracmon.graph.Graph.template" href="#pyracmon.graph.Graph.template">template</a></code></li>
<li><code><a title="pyracmon.graph.Graph.view" href="#pyracmon.graph.Graph.view">view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.GraphSpec" href="#pyracmon.graph.GraphSpec">GraphSpec</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.graph.GraphSpec.add_entity_filter" href="#pyracmon.graph.GraphSpec.add_entity_filter">add_entity_filter</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.add_identifier" href="#pyracmon.graph.GraphSpec.add_identifier">add_identifier</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.add_serializer" href="#pyracmon.graph.GraphSpec.add_serializer">add_serializer</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.entity_filters" href="#pyracmon.graph.GraphSpec.entity_filters">entity_filters</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.find_serializers" href="#pyracmon.graph.GraphSpec.find_serializers">find_serializers</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.get_entity_filter" href="#pyracmon.graph.GraphSpec.get_entity_filter">get_entity_filter</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.get_identifier" href="#pyracmon.graph.GraphSpec.get_identifier">get_identifier</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.identifiers" href="#pyracmon.graph.GraphSpec.identifiers">identifiers</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.new_template" href="#pyracmon.graph.GraphSpec.new_template">new_template</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.serializers" href="#pyracmon.graph.GraphSpec.serializers">serializers</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.to_dict" href="#pyracmon.graph.GraphSpec.to_dict">to_dict</a></code></li>
<li><code><a title="pyracmon.graph.GraphSpec.to_schema" href="#pyracmon.graph.GraphSpec.to_schema">to_schema</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.GraphTemplate" href="#pyracmon.graph.GraphTemplate">GraphTemplate</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.graph.GraphTemplate.Property" href="#pyracmon.graph.GraphTemplate.Property">Property</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.IdentifyPolicy" href="#pyracmon.graph.IdentifyPolicy">IdentifyPolicy</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.graph.IdentifyPolicy.get_identifier" href="#pyracmon.graph.IdentifyPolicy.get_identifier">get_identifier</a></code></li>
<li><code><a title="pyracmon.graph.IdentifyPolicy.identifier" href="#pyracmon.graph.IdentifyPolicy.identifier">identifier</a></code></li>
<li><code><a title="pyracmon.graph.IdentifyPolicy.identify" href="#pyracmon.graph.IdentifyPolicy.identify">identify</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.graph.S" href="#pyracmon.graph.S">S</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.graph.S.alter" href="#pyracmon.graph.S.alter">alter</a></code></li>
<li><code><a title="pyracmon.graph.S.at" href="#pyracmon.graph.S.at">at</a></code></li>
<li><code><a title="pyracmon.graph.S.doc" href="#pyracmon.graph.S.doc">doc</a></code></li>
<li><code><a title="pyracmon.graph.S.each" href="#pyracmon.graph.S.each">each</a></code></li>
<li><code><a title="pyracmon.graph.S.fold" href="#pyracmon.graph.S.fold">fold</a></code></li>
<li><code><a title="pyracmon.graph.S.head" href="#pyracmon.graph.S.head">head</a></code></li>
<li><code><a title="pyracmon.graph.S.last" href="#pyracmon.graph.S.last">last</a></code></li>
<li><code><a title="pyracmon.graph.S.merge" href="#pyracmon.graph.S.merge">merge</a></code></li>
<li><code><a title="pyracmon.graph.S.name" href="#pyracmon.graph.S.name">name</a></code></li>
<li><code><a title="pyracmon.graph.S.of" href="#pyracmon.graph.S.of">of</a></code></li>
<li><code><a title="pyracmon.graph.S.select" href="#pyracmon.graph.S.select">select</a></code></li>
<li><code><a title="pyracmon.graph.S.sub" href="#pyracmon.graph.S.sub">sub</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>