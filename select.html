<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyracmon.select API documentation</title>
<meta name="description" content="This module exports types and functions used for `SELECT` queries â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyracmon.select</code></h1>
</header>
<section id="section-intro">
<p>This module exports types and functions used for <code>SELECT</code> queries.</p>
<p>Main purpose is providing a type which contains information of selecting columns,
i.e. which columns are selected and how they are rendered in the query.
Using the same instance of the type in both of query genration and reading results enables consistent reconstruction of model objects.</p>
<p>In most cases, classes of this module should not be used directly.
The use of <code><a title="pyracmon.select.SelectMixin.select" href="#pyracmon.select.SelectMixin.select">SelectMixin.select()</a></code> and <code><a title="pyracmon.select.read_row" href="#pyracmon.select.read_row">read_row()</a></code> is sufficient way to benefit from this module.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module exports types and functions used for `SELECT` queries.

Main purpose is providing a type which contains information of selecting columns,
i.e. which columns are selected and how they are rendered in the query.
Using the same instance of the type in both of query genration and reading results enables consistent reconstruction of model objects.

In most cases, classes of this module should not be used directly.
The use of `SelectMixin.select` and `read_row` is sufficient way to benefit from this module.
&#34;&#34;&#34;
from collections.abc import Iterator
from typing import Any, Union, TypeVar, Generic, Optional, Literal, Protocol, cast, overload
from typing_extensions import Self
from .model import Model, Column
from .query import Q, Queryable


S = TypeVar(&#39;S&#39;)
M = TypeVar(&#39;M&#39;, bound=Model)


class AliasedColumn(Queryable[Any]): # type: ignore
    &#34;&#34;&#34;
    The representation of column and the alias of its belonging table.

    The instance of this class works as `Q` &#39;s attribute as well.
    i.e. Condition on the column can be generated similarly to &#39;Q&#39; via methods like `eq` .

    ```python
    &gt;&gt;&gt; c = AliasedColumn(&#34;t&#34;, &#34;col&#34;)
    &gt;&gt;&gt; c.eq(3)
    Condition: &#39;t.col = $_&#39; -- [3]
    ```
    &#34;&#34;&#34;
    def __init__(self, alias: str, column: Union[Column, str]) -&gt; None:
        #: Alias string.
        self.alias = alias
        #: Column name or schema.
        self.column = column

    def __hash__(self) -&gt; int:
        return hash(self.alias) + hash(self.column)

    def __eq__(self, other: object) -&gt; bool:
        return isinstance(other, AliasedColumn) and self.alias == other.alias and self.column is other.column

    def __str__(self) -&gt; str:
        return self.name

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
        Aliased column name. If alias is empty, column name is returns as it is.
        &#34;&#34;&#34;
        if isinstance(self.column, Column):
            return f&#34;{self.alias}.{self.column.name}&#34; if self.alias else self.column.name
        else:
            return f&#34;{self.alias}.{self.column}&#34; if self.alias else self.column

    def __getattr__(self, key):
        method = getattr(Q, key)
        def invoke(value, *args, **kwargs):
            kwargs.update({self.name: value})
            return method(*args, **kwargs)
        return invoke


class Aliased(Generic[M]):
    &#34;&#34;&#34;
    A wrapper of a model type with an alias for it.
    &#34;&#34;&#34;
    def __init__(self, alias: str, model: type[M]) -&gt; None:
        #: Alias string.
        self.alias = alias
        #: Model type.
        self.model = model

    def __getattr__(self, key: str) -&gt; AliasedColumn:
        try:
            col = next(filter(lambda c: c.name == key, self.model.columns))
            return AliasedColumn(self.alias, col)
        except StopIteration:
            raise KeyError(f&#34;{key} is not a valid column name of {self.model.name}.&#34;)

    def select(self, includes: list[str] = [], excludes: list[str] = []) -&gt; &#39;Selection[M]&#39;:
        &#34;&#34;&#34;
        Creates a selection object containing selected columns in the model.

        Args:
            includes: Column names to select. All columns except specified in `excludes` are selected if empty.
            excludes: Column names not to select.
        Returns:
            Selection object.
        &#34;&#34;&#34;
        columns = [c for c in self.model.columns if c.name not in excludes] \
            if not bool(includes) else \
                [c for c in self.model.columns if c.name not in excludes and c.name in includes]
        return cast(Selection[M], Selection(self.model, self.alias, columns))


class Consumable:
    @staticmethod
    def to_consumable(value: Any) -&gt; &#39;Consumable&#39;:
        if isinstance(value, Consumable):
            return value
        elif isinstance(value, str):
            return StrConsumable(value)
        else:
            return EmptyConsumable()

    def __len__(self) -&gt; int: ...
    @property
    def name(self) -&gt; Optional[str]: ...
    def consume(self, values: list[Any]) -&gt; Any: ...


class StrConsumable(Consumable):
    def __init__(self, key: str) -&gt; None:
        self.key = key

    def __eq__(self, other: object) -&gt; bool:
        return isinstance(other, StrConsumable) and self.key == other.key

    def __len__(self) -&gt; int:
        return 1

    @property
    def name(self) -&gt; Optional[str]:
        return self.key

    def consume(self, values: list[Any]) -&gt; Any:
        return values[0]


class EmptyConsumable(Consumable):
    def __eq__(self, other: object) -&gt; bool:
        return isinstance(other, EmptyConsumable)

    def __len__(self) -&gt; int:
        return 1

    @property
    def name(self) -&gt; Optional[str]:
        return None

    def consume(self, values: list[Any]) -&gt; Any:
        return values[0]


class Selection(Consumable, Generic[S]):
    &#34;&#34;&#34;
    A representation of table and its columns used in query.

    This class is designed to be a bridge from query generation to reading results.
    String expression of the instance is comma-separated column names prepended with alias, which can be embedded in the select query.

    Due to `SelectMixin`, factory method is available on every model type.

    ```python
    &gt;&gt;&gt; s1 = table1.select(&#34;t1&#34;, includes = [&#34;col11&#34;, &#34;col12&#34;])
    &gt;&gt;&gt; s2 = table2.select(&#34;t2&#34;)
    &gt;&gt;&gt; str(s1)
    &#39;t1.col11, t1.col12&#39;
    &gt;&gt;&gt; str(s2)
    &#39;t2.col21, t2.col22, t2.col23&#39;
    ```

    The instances of this class are also used in `read_row` to reconstruct model objects from each obtained row.

    ```python
    &gt;&gt;&gt; c.execute(f&#34;SELECT {s1}, {s2} FROM table1 AS t1 INNER JOIN table2 AS t2 ON ...&#34;)
    &gt;&gt;&gt; for row in c.fetchall():
    &gt;&gt;&gt;     r = read_row(row, s1, s2)
    &gt;&gt;&gt;     assert isinstance(r.t1, table1)
    &gt;&gt;&gt;     assert isinstance(r.t2, table2)
    ```
    &#34;&#34;&#34;
    def __init__(self, table: type[S], alias: str, columns: list[Column]):
        #: Model type.
        self.table = table
        #: An alias.
        self.alias = alias
        #: Columns to select.
        self.columns = columns

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
        Returns alias or name of the table.
        &#34;&#34;&#34;
        return self.alias if self.alias else cast(type[Model], self.table).name

    def __len__(self) -&gt; int:
        return len(self.columns)

    def __repr__(self) -&gt; str:
        a = f&#34;{self.alias}.&#34; if self.alias else &#34;&#34;
        return &#39;, &#39;.join([f&#34;{a}{c.name}&#34; for c in self.columns])

    def __add__(self, other) -&gt; &#39;FieldExpressions&#39;:
        return FieldExpressions() + self + other

    def __iter__(self):
        return iter([self])

    def __getattr__(self, key) -&gt; AliasedColumn:
        try:
            return AliasedColumn(self.alias, next(filter(lambda c: c.name == key, self.columns)))
        except StopIteration:
            raise KeyError(f&#34;{key} is not found from selected columns.&#34;)

    def consume(self, values: list[Any]) -&gt; S:
        &#34;&#34;&#34;
        Construct a model object from a row.

        Args:
            values: Values of row. The length must be equal to the number of columns in this.
        Returns:
            Model object where column values obtained from the row are set. 
        &#34;&#34;&#34;
        return self.table(**dict([(c.name, v) for c, v in zip(self.columns, values)]))


class FieldExpressions:
    &#34;&#34;&#34;
    The instance of this class works as the composition of selections.

    `+` operation on `Selection` s creates an instance of `FieldExpressions`. Each selection can be accessed via attributes of its name.
    Also, `FieldExpression` can be extended by `+=`.

    ```python
    &gt;&gt;&gt; exp = table1.select(&#34;t1&#34;, includes=[&#34;col11&#34;, &#34;col12&#34;]) + table2.select(&#34;t2&#34;)
    &gt;&gt;&gt; c.execute(f&#34;SELECT {exp} FROM table1 AS t1 INNER JOIN table2 AS t2 ON ...&#34;)
    &gt;&gt;&gt; for row in c.fetchall():
    &gt;&gt;&gt;     r = read_row(row, *exp)
    &gt;&gt;&gt;     assert isinstance(r.t1, table1)
    &gt;&gt;&gt;     assert isinstance(r.t2, table2)
    ```

    Here, empty tuple and string are also available instead of `Selection` instance.
    They are replaced with index arguments (tuple) or keywords arguments (string) respectively by the invocation of the instance.

    ```python
    &gt;&gt;&gt; exp = table1.select(&#34;t1&#34;, includes=[&#34;col11&#34;, &#34;col12&#34;]) + () + &#34;a&#34; + () + &#34;b&#34;
    &gt;&gt;&gt; f&#34;{exp(&#34;t2.col21&#34;, &#34;t2.col23&#34;, a=&#34;t2.col22&#34;, b=&#34;t2.col24&#34;)}&#34;
    t1.col11, t1.col12, t2.col21, t2.col22, t2.col23, t2.col24
    ```
    &#34;&#34;&#34;
    def __init__(self):
        self.__selections: list[Consumable] = []
        self.__keys = {}

    def __add__(self, other) -&gt; Self:
        exp = FieldExpressions()
        exp += self
        exp += other
        return exp

    def __iadd__(self, other) -&gt; Self:
        if isinstance(other, Selection):
            self.__selections.append(other)
            self.__keys[other.name] = other
        elif isinstance(other, FieldExpressions):
            self.__selections += other.__selections
            self.__keys.update(other.__keys)
        elif isinstance(other, str):
            cons = StrConsumable(other)
            self.__selections.append(cons)
            self.__keys[other] = cons
        elif other == ():
            self.__selections.append(EmptyConsumable())
        else:
            raise ValueError(f&#34;Operand of + for FieldExpressions must be a Selection or FieldExpressions but {type(other)} is given.&#34;)
        return self

    def __getitem__(self, index: int) -&gt; Consumable:
        return self.__selections[index]

    def __getattr__(self, key: str) -&gt; Consumable:
        return self.__keys[key]

    def __iter__(self) -&gt; Iterator[Consumable]:
        return iter(self.__selections)

    class Instance:
        def __init__(self, exp: &#39;FieldExpressions&#39;, *args, **kwargs):
            self.exp = exp
            self.args = args
            self.kwargs = kwargs

        def __repr__(self):
            args = list(self.args)
            def _repr(s: Consumable) -&gt; str:
                if isinstance(s, Selection):
                    return s.__repr__()
                elif isinstance(s, StrConsumable):
                    return self.kwargs.get(s.key, s.key)
                elif isinstance(s, EmptyConsumable):
                    return args.pop(0)
                else:
                    raise ValueError(f&#34;Unexpected expression type: {s}&#34;)
            return &#39;, &#39;.join(map(_repr, self.exp))

    def __call__(self, *args, **kwargs):
        return FieldExpressions.Instance(self, *args, **kwargs)

    def __repr__(self):
        return self().__repr__()


class RowValues:
    &#34;&#34;&#34;
    This class provides attribute access to each row in query result.

    Each instance returned by `read_row` behaves as if it is a list of consumed values of containing `Selection` s.
    Index access returns the value at the index and iteration yields values in order.

    ```python
    &gt;&gt;&gt; exp = table1.select(&#34;t1&#34;), table2.select()
    &gt;&gt;&gt; r = read_row(row, *exp)
    &gt;&gt;&gt; r[0]
    ...
    &gt;&gt;&gt; [v for v in r]
    ...
    ```

    It also exposes attributes returns a `Selection` by its alias or table name.

    ```python
    &gt;&gt;&gt; r.t1
    ...
    &gt;&gt;&gt; r.table2
    ...
    ```

    Args:
        selections: List of selections which assign each value in row to a column.
    &#34;&#34;&#34;
    def __init__(self, selections: list[Consumable]):
        self._key_map = dict([(s.name, i) for i, s in enumerate(selections) if s.name is not None])
        self._values = []

    def __len__(self):
        return len(self._values)

    def __iter__(self):
        return iter(self._values)

    def __getitem__(self, index):
        return self._values[index]

    def __getattr__(self, key) -&gt; Any:
        index = self._key_map.get(key, None)
        if index is None:
            raise AttributeError(f&#34;No selection is found whose table name or alias is &#39;{key}&#39;&#34;)
        return self._values[index]

    def append(self, value: Any):
        &#34;&#34;&#34;
        Appends a value in the row.

        Args:
            value: A value in the row.
        &#34;&#34;&#34;
        self._values.append(value)


def read_row(row, *selections: Union[Consumable, str, tuple], allow_redundancy: bool = False) -&gt; RowValues:
    &#34;&#34;&#34;
    Read values in a row according to given selections.

    This function returns `RowValues` where each value is created by each selection respectively.
    The type of the selection determines how values in the row are handled:

    - `Selection` consumes as many values as the number of columns in it and creates a model instance.
    - Empty tuple or a string consumes a value, which is stored in `RowValues` as it is.

    Args:
        selections: List of selections or their equivalents.
        allow_redundancy: If `False`, `ValueError` is thrown when not all values in a row are consumed.
    Returns:
        Values read from the row accoding to the selections.
    &#34;&#34;&#34;
    consumables = [Consumable.to_consumable(s) for s in selections]

    result = RowValues(consumables)

    for s in consumables:
        result.append(s.consume(row))
        row = row[len(s):]

    if not allow_redundancy and len(row) &gt; 0:
        raise ValueError(&#34;Not all elements in row is consumed.&#34;)

    return result


class SelectMixin:
    @overload
    @classmethod
    def select(cls, alias: str = &#34;&#34;, includes: list[str] = [], excludes: list[str] = [], single: Literal[False] = False) -&gt; FieldExpressions: ...
    @overload
    @classmethod
    def select(cls, alias: str = &#34;&#34;, includes: list[str] = [], excludes: list[str] = [], single: Literal[True] = True) -&gt; Selection[Self]: ...
    @classmethod
    def select(cls, alias: str = &#34;&#34;, includes: list[str] = [], excludes: list[str] = [], single: bool = False):
        &#34;&#34;&#34;
        Default mixin class of every model type providing method to generate `Selection` by Selecting columns with alias.

        Args:
            alias: An alias string of this table.
            includes: Column names to select. All columns except specified in `excludes` are selected if empty.
            excludes: Column names not to select.
        Returns:
            Selection object.
        &#34;&#34;&#34;
        if single:
            return Aliased(alias, cast(type, cls)).select(includes, excludes)
        else:
            return FieldExpressions() + Aliased(alias, cast(type, cls)).select(includes, excludes)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyracmon.select.read_row"><code class="name flex">
<span>def <span class="ident">read_row</span></span>(<span>row, *selections:Â Union[<a title="pyracmon.select.Consumable" href="#pyracmon.select.Consumable">Consumable</a>,Â str,Â tuple], allow_redundancy:Â boolÂ =Â False) â€‘>Â <a title="pyracmon.select.RowValues" href="#pyracmon.select.RowValues">RowValues</a></span>
</code></dt>
<dd>
<div class="desc"><p>Read values in a row according to given selections.</p>
<p>This function returns <code><a title="pyracmon.select.RowValues" href="#pyracmon.select.RowValues">RowValues</a></code> where each value is created by each selection respectively.
The type of the selection determines how values in the row are handled:</p>
<ul>
<li><code><a title="pyracmon.select.Selection" href="#pyracmon.select.Selection">Selection</a></code> consumes as many values as the number of columns in it and creates a model instance.</li>
<li>Empty tuple or a string consumes a value, which is stored in <code><a title="pyracmon.select.RowValues" href="#pyracmon.select.RowValues">RowValues</a></code> as it is.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>selections</code></strong></dt>
<dd>List of selections or their equivalents.</dd>
<dt><strong><code>allow_redundancy</code></strong></dt>
<dd>If <code>False</code>, <code>ValueError</code> is thrown when not all values in a row are consumed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Values read from the row accoding to the selections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_row(row, *selections: Union[Consumable, str, tuple], allow_redundancy: bool = False) -&gt; RowValues:
    &#34;&#34;&#34;
    Read values in a row according to given selections.

    This function returns `RowValues` where each value is created by each selection respectively.
    The type of the selection determines how values in the row are handled:

    - `Selection` consumes as many values as the number of columns in it and creates a model instance.
    - Empty tuple or a string consumes a value, which is stored in `RowValues` as it is.

    Args:
        selections: List of selections or their equivalents.
        allow_redundancy: If `False`, `ValueError` is thrown when not all values in a row are consumed.
    Returns:
        Values read from the row accoding to the selections.
    &#34;&#34;&#34;
    consumables = [Consumable.to_consumable(s) for s in selections]

    result = RowValues(consumables)

    for s in consumables:
        result.append(s.consume(row))
        row = row[len(s):]

    if not allow_redundancy and len(row) &gt; 0:
        raise ValueError(&#34;Not all elements in row is consumed.&#34;)

    return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyracmon.select.Aliased"><code class="flex name class">
<span>class <span class="ident">Aliased</span></span>
<span>(</span><span>alias:Â str, model:Â type[~M])</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper of a model type with an alias for it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Aliased(Generic[M]):
    &#34;&#34;&#34;
    A wrapper of a model type with an alias for it.
    &#34;&#34;&#34;
    def __init__(self, alias: str, model: type[M]) -&gt; None:
        #: Alias string.
        self.alias = alias
        #: Model type.
        self.model = model

    def __getattr__(self, key: str) -&gt; AliasedColumn:
        try:
            col = next(filter(lambda c: c.name == key, self.model.columns))
            return AliasedColumn(self.alias, col)
        except StopIteration:
            raise KeyError(f&#34;{key} is not a valid column name of {self.model.name}.&#34;)

    def select(self, includes: list[str] = [], excludes: list[str] = []) -&gt; &#39;Selection[M]&#39;:
        &#34;&#34;&#34;
        Creates a selection object containing selected columns in the model.

        Args:
            includes: Column names to select. All columns except specified in `excludes` are selected if empty.
            excludes: Column names not to select.
        Returns:
            Selection object.
        &#34;&#34;&#34;
        columns = [c for c in self.model.columns if c.name not in excludes] \
            if not bool(includes) else \
                [c for c in self.model.columns if c.name not in excludes and c.name in includes]
        return cast(Selection[M], Selection(self.model, self.alias, columns))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.select.Aliased.alias"><code class="name">var <span class="ident">alias</span></code></dt>
<dd>
<div class="desc"><p>Alias string.</p></div>
</dd>
<dt id="pyracmon.select.Aliased.model"><code class="name">var <span class="ident">model</span></code></dt>
<dd>
<div class="desc"><p>Model type.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.select.Aliased.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, includes:Â list[str]Â =Â [], excludes:Â list[str]Â =Â []) â€‘>Â <a title="pyracmon.select.Selection" href="#pyracmon.select.Selection">Selection</a>[~M]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a selection object containing selected columns in the model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>includes</code></strong></dt>
<dd>Column names to select. All columns except specified in <code>excludes</code> are selected if empty.</dd>
<dt><strong><code>excludes</code></strong></dt>
<dd>Column names not to select.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Selection object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self, includes: list[str] = [], excludes: list[str] = []) -&gt; &#39;Selection[M]&#39;:
    &#34;&#34;&#34;
    Creates a selection object containing selected columns in the model.

    Args:
        includes: Column names to select. All columns except specified in `excludes` are selected if empty.
        excludes: Column names not to select.
    Returns:
        Selection object.
    &#34;&#34;&#34;
    columns = [c for c in self.model.columns if c.name not in excludes] \
        if not bool(includes) else \
            [c for c in self.model.columns if c.name not in excludes and c.name in includes]
    return cast(Selection[M], Selection(self.model, self.alias, columns))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.select.AliasedColumn"><code class="flex name class">
<span>class <span class="ident">AliasedColumn</span></span>
<span>(</span><span>alias:Â str, column:Â Union[<a title="pyracmon.model.Column" href="model.html#pyracmon.model.Column">Column</a>,Â str])</span>
</code></dt>
<dd>
<div class="desc"><p>The representation of column and the alias of its belonging table.</p>
<p>The instance of this class works as <code>Q</code> 's attribute as well.
i.e. Condition on the column can be generated similarly to 'Q' via methods like <code>eq</code> .</p>
<pre><code class="language-python">&gt;&gt;&gt; c = AliasedColumn(&quot;t&quot;, &quot;col&quot;)
&gt;&gt;&gt; c.eq(3)
Condition: 't.col = $_' -- [3]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AliasedColumn(Queryable[Any]): # type: ignore
    &#34;&#34;&#34;
    The representation of column and the alias of its belonging table.

    The instance of this class works as `Q` &#39;s attribute as well.
    i.e. Condition on the column can be generated similarly to &#39;Q&#39; via methods like `eq` .

    ```python
    &gt;&gt;&gt; c = AliasedColumn(&#34;t&#34;, &#34;col&#34;)
    &gt;&gt;&gt; c.eq(3)
    Condition: &#39;t.col = $_&#39; -- [3]
    ```
    &#34;&#34;&#34;
    def __init__(self, alias: str, column: Union[Column, str]) -&gt; None:
        #: Alias string.
        self.alias = alias
        #: Column name or schema.
        self.column = column

    def __hash__(self) -&gt; int:
        return hash(self.alias) + hash(self.column)

    def __eq__(self, other: object) -&gt; bool:
        return isinstance(other, AliasedColumn) and self.alias == other.alias and self.column is other.column

    def __str__(self) -&gt; str:
        return self.name

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
        Aliased column name. If alias is empty, column name is returns as it is.
        &#34;&#34;&#34;
        if isinstance(self.column, Column):
            return f&#34;{self.alias}.{self.column.name}&#34; if self.alias else self.column.name
        else:
            return f&#34;{self.alias}.{self.column}&#34; if self.alias else self.column

    def __getattr__(self, key):
        method = getattr(Q, key)
        def invoke(value, *args, **kwargs):
            kwargs.update({self.name: value})
            return method(*args, **kwargs)
        return invoke</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.query.Queryable" href="query.html#pyracmon.query.Queryable">Queryable</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.select.AliasedColumn.alias"><code class="name">var <span class="ident">alias</span></code></dt>
<dd>
<div class="desc"><p>Alias string.</p></div>
</dd>
<dt id="pyracmon.select.AliasedColumn.column"><code class="name">var <span class="ident">column</span></code></dt>
<dd>
<div class="desc"><p>Column name or schema.</p></div>
</dd>
<dt id="pyracmon.select.AliasedColumn.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Aliased column name. If alias is empty, column name is returns as it is.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
    Aliased column name. If alias is empty, column name is returns as it is.
    &#34;&#34;&#34;
    if isinstance(self.column, Column):
        return f&#34;{self.alias}.{self.column.name}&#34; if self.alias else self.column.name
    else:
        return f&#34;{self.alias}.{self.column}&#34; if self.alias else self.column</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.select.Consumable"><code class="flex name class">
<span>class <span class="ident">Consumable</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Consumable:
    @staticmethod
    def to_consumable(value: Any) -&gt; &#39;Consumable&#39;:
        if isinstance(value, Consumable):
            return value
        elif isinstance(value, str):
            return StrConsumable(value)
        else:
            return EmptyConsumable()

    def __len__(self) -&gt; int: ...
    @property
    def name(self) -&gt; Optional[str]: ...
    def consume(self, values: list[Any]) -&gt; Any: ...</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.select.EmptyConsumable" href="#pyracmon.select.EmptyConsumable">EmptyConsumable</a></li>
<li><a title="pyracmon.select.Selection" href="#pyracmon.select.Selection">Selection</a></li>
<li><a title="pyracmon.select.StrConsumable" href="#pyracmon.select.StrConsumable">StrConsumable</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.select.Consumable.to_consumable"><code class="name flex">
<span>def <span class="ident">to_consumable</span></span>(<span>value:Â Any) â€‘>Â <a title="pyracmon.select.Consumable" href="#pyracmon.select.Consumable">Consumable</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_consumable(value: Any) -&gt; &#39;Consumable&#39;:
    if isinstance(value, Consumable):
        return value
    elif isinstance(value, str):
        return StrConsumable(value)
    else:
        return EmptyConsumable()</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.select.Consumable.name"><code class="name">var <span class="ident">name</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; Optional[str]: ...</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.select.Consumable.consume"><code class="name flex">
<span>def <span class="ident">consume</span></span>(<span>self, values:Â list[typing.Any]) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consume(self, values: list[Any]) -&gt; Any: ...</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.select.EmptyConsumable"><code class="flex name class">
<span>class <span class="ident">EmptyConsumable</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EmptyConsumable(Consumable):
    def __eq__(self, other: object) -&gt; bool:
        return isinstance(other, EmptyConsumable)

    def __len__(self) -&gt; int:
        return 1

    @property
    def name(self) -&gt; Optional[str]:
        return None

    def consume(self, values: list[Any]) -&gt; Any:
        return values[0]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.select.Consumable" href="#pyracmon.select.Consumable">Consumable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.select.EmptyConsumable.name"><code class="name">var <span class="ident">name</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; Optional[str]:
    return None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.select.EmptyConsumable.consume"><code class="name flex">
<span>def <span class="ident">consume</span></span>(<span>self, values:Â list[typing.Any]) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consume(self, values: list[Any]) -&gt; Any:
    return values[0]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.select.FieldExpressions"><code class="flex name class">
<span>class <span class="ident">FieldExpressions</span></span>
</code></dt>
<dd>
<div class="desc"><p>The instance of this class works as the composition of selections.</p>
<p><code>+</code> operation on <code><a title="pyracmon.select.Selection" href="#pyracmon.select.Selection">Selection</a></code> s creates an instance of <code><a title="pyracmon.select.FieldExpressions" href="#pyracmon.select.FieldExpressions">FieldExpressions</a></code>. Each selection can be accessed via attributes of its name.
Also, <code>FieldExpression</code> can be extended by <code>+=</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; exp = table1.select(&quot;t1&quot;, includes=[&quot;col11&quot;, &quot;col12&quot;]) + table2.select(&quot;t2&quot;)
&gt;&gt;&gt; c.execute(f&quot;SELECT {exp} FROM table1 AS t1 INNER JOIN table2 AS t2 ON ...&quot;)
&gt;&gt;&gt; for row in c.fetchall():
&gt;&gt;&gt;     r = read_row(row, *exp)
&gt;&gt;&gt;     assert isinstance(r.t1, table1)
&gt;&gt;&gt;     assert isinstance(r.t2, table2)
</code></pre>
<p>Here, empty tuple and string are also available instead of <code><a title="pyracmon.select.Selection" href="#pyracmon.select.Selection">Selection</a></code> instance.
They are replaced with index arguments (tuple) or keywords arguments (string) respectively by the invocation of the instance.</p>
<pre><code class="language-python">&gt;&gt;&gt; exp = table1.select(&quot;t1&quot;, includes=[&quot;col11&quot;, &quot;col12&quot;]) + () + &quot;a&quot; + () + &quot;b&quot;
&gt;&gt;&gt; f&quot;{exp(&quot;t2.col21&quot;, &quot;t2.col23&quot;, a=&quot;t2.col22&quot;, b=&quot;t2.col24&quot;)}&quot;
t1.col11, t1.col12, t2.col21, t2.col22, t2.col23, t2.col24
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FieldExpressions:
    &#34;&#34;&#34;
    The instance of this class works as the composition of selections.

    `+` operation on `Selection` s creates an instance of `FieldExpressions`. Each selection can be accessed via attributes of its name.
    Also, `FieldExpression` can be extended by `+=`.

    ```python
    &gt;&gt;&gt; exp = table1.select(&#34;t1&#34;, includes=[&#34;col11&#34;, &#34;col12&#34;]) + table2.select(&#34;t2&#34;)
    &gt;&gt;&gt; c.execute(f&#34;SELECT {exp} FROM table1 AS t1 INNER JOIN table2 AS t2 ON ...&#34;)
    &gt;&gt;&gt; for row in c.fetchall():
    &gt;&gt;&gt;     r = read_row(row, *exp)
    &gt;&gt;&gt;     assert isinstance(r.t1, table1)
    &gt;&gt;&gt;     assert isinstance(r.t2, table2)
    ```

    Here, empty tuple and string are also available instead of `Selection` instance.
    They are replaced with index arguments (tuple) or keywords arguments (string) respectively by the invocation of the instance.

    ```python
    &gt;&gt;&gt; exp = table1.select(&#34;t1&#34;, includes=[&#34;col11&#34;, &#34;col12&#34;]) + () + &#34;a&#34; + () + &#34;b&#34;
    &gt;&gt;&gt; f&#34;{exp(&#34;t2.col21&#34;, &#34;t2.col23&#34;, a=&#34;t2.col22&#34;, b=&#34;t2.col24&#34;)}&#34;
    t1.col11, t1.col12, t2.col21, t2.col22, t2.col23, t2.col24
    ```
    &#34;&#34;&#34;
    def __init__(self):
        self.__selections: list[Consumable] = []
        self.__keys = {}

    def __add__(self, other) -&gt; Self:
        exp = FieldExpressions()
        exp += self
        exp += other
        return exp

    def __iadd__(self, other) -&gt; Self:
        if isinstance(other, Selection):
            self.__selections.append(other)
            self.__keys[other.name] = other
        elif isinstance(other, FieldExpressions):
            self.__selections += other.__selections
            self.__keys.update(other.__keys)
        elif isinstance(other, str):
            cons = StrConsumable(other)
            self.__selections.append(cons)
            self.__keys[other] = cons
        elif other == ():
            self.__selections.append(EmptyConsumable())
        else:
            raise ValueError(f&#34;Operand of + for FieldExpressions must be a Selection or FieldExpressions but {type(other)} is given.&#34;)
        return self

    def __getitem__(self, index: int) -&gt; Consumable:
        return self.__selections[index]

    def __getattr__(self, key: str) -&gt; Consumable:
        return self.__keys[key]

    def __iter__(self) -&gt; Iterator[Consumable]:
        return iter(self.__selections)

    class Instance:
        def __init__(self, exp: &#39;FieldExpressions&#39;, *args, **kwargs):
            self.exp = exp
            self.args = args
            self.kwargs = kwargs

        def __repr__(self):
            args = list(self.args)
            def _repr(s: Consumable) -&gt; str:
                if isinstance(s, Selection):
                    return s.__repr__()
                elif isinstance(s, StrConsumable):
                    return self.kwargs.get(s.key, s.key)
                elif isinstance(s, EmptyConsumable):
                    return args.pop(0)
                else:
                    raise ValueError(f&#34;Unexpected expression type: {s}&#34;)
            return &#39;, &#39;.join(map(_repr, self.exp))

    def __call__(self, *args, **kwargs):
        return FieldExpressions.Instance(self, *args, **kwargs)

    def __repr__(self):
        return self().__repr__()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyracmon.select.FieldExpressions.Instance"><code class="name">var <span class="ident">Instance</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="pyracmon.select.RowValues"><code class="flex name class">
<span>class <span class="ident">RowValues</span></span>
<span>(</span><span>selections:Â list[<a title="pyracmon.select.Consumable" href="#pyracmon.select.Consumable">Consumable</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>This class provides attribute access to each row in query result.</p>
<p>Each instance returned by <code><a title="pyracmon.select.read_row" href="#pyracmon.select.read_row">read_row()</a></code> behaves as if it is a list of consumed values of containing <code><a title="pyracmon.select.Selection" href="#pyracmon.select.Selection">Selection</a></code> s.
Index access returns the value at the index and iteration yields values in order.</p>
<pre><code class="language-python">&gt;&gt;&gt; exp = table1.select(&quot;t1&quot;), table2.select()
&gt;&gt;&gt; r = read_row(row, *exp)
&gt;&gt;&gt; r[0]
...
&gt;&gt;&gt; [v for v in r]
...
</code></pre>
<p>It also exposes attributes returns a <code><a title="pyracmon.select.Selection" href="#pyracmon.select.Selection">Selection</a></code> by its alias or table name.</p>
<pre><code class="language-python">&gt;&gt;&gt; r.t1
...
&gt;&gt;&gt; r.table2
...
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>selections</code></strong></dt>
<dd>List of selections which assign each value in row to a column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RowValues:
    &#34;&#34;&#34;
    This class provides attribute access to each row in query result.

    Each instance returned by `read_row` behaves as if it is a list of consumed values of containing `Selection` s.
    Index access returns the value at the index and iteration yields values in order.

    ```python
    &gt;&gt;&gt; exp = table1.select(&#34;t1&#34;), table2.select()
    &gt;&gt;&gt; r = read_row(row, *exp)
    &gt;&gt;&gt; r[0]
    ...
    &gt;&gt;&gt; [v for v in r]
    ...
    ```

    It also exposes attributes returns a `Selection` by its alias or table name.

    ```python
    &gt;&gt;&gt; r.t1
    ...
    &gt;&gt;&gt; r.table2
    ...
    ```

    Args:
        selections: List of selections which assign each value in row to a column.
    &#34;&#34;&#34;
    def __init__(self, selections: list[Consumable]):
        self._key_map = dict([(s.name, i) for i, s in enumerate(selections) if s.name is not None])
        self._values = []

    def __len__(self):
        return len(self._values)

    def __iter__(self):
        return iter(self._values)

    def __getitem__(self, index):
        return self._values[index]

    def __getattr__(self, key) -&gt; Any:
        index = self._key_map.get(key, None)
        if index is None:
            raise AttributeError(f&#34;No selection is found whose table name or alias is &#39;{key}&#39;&#34;)
        return self._values[index]

    def append(self, value: Any):
        &#34;&#34;&#34;
        Appends a value in the row.

        Args:
            value: A value in the row.
        &#34;&#34;&#34;
        self._values.append(value)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.select.RowValues.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, value:Â Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Appends a value in the row.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>A value in the row.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, value: Any):
    &#34;&#34;&#34;
    Appends a value in the row.

    Args:
        value: A value in the row.
    &#34;&#34;&#34;
    self._values.append(value)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.select.SelectMixin"><code class="flex name class">
<span>class <span class="ident">SelectMixin</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SelectMixin:
    @overload
    @classmethod
    def select(cls, alias: str = &#34;&#34;, includes: list[str] = [], excludes: list[str] = [], single: Literal[False] = False) -&gt; FieldExpressions: ...
    @overload
    @classmethod
    def select(cls, alias: str = &#34;&#34;, includes: list[str] = [], excludes: list[str] = [], single: Literal[True] = True) -&gt; Selection[Self]: ...
    @classmethod
    def select(cls, alias: str = &#34;&#34;, includes: list[str] = [], excludes: list[str] = [], single: bool = False):
        &#34;&#34;&#34;
        Default mixin class of every model type providing method to generate `Selection` by Selecting columns with alias.

        Args:
            alias: An alias string of this table.
            includes: Column names to select. All columns except specified in `excludes` are selected if empty.
            excludes: Column names not to select.
        Returns:
            Selection object.
        &#34;&#34;&#34;
        if single:
            return Aliased(alias, cast(type, cls)).select(includes, excludes)
        else:
            return FieldExpressions() + Aliased(alias, cast(type, cls)).select(includes, excludes)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.mixin.CRUDMixin" href="mixin.html#pyracmon.mixin.CRUDMixin">CRUDMixin</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.select.SelectMixin.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>alias:Â strÂ =Â '', includes:Â list[str]Â =Â [], excludes:Â list[str]Â =Â [], single:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Default mixin class of every model type providing method to generate <code><a title="pyracmon.select.Selection" href="#pyracmon.select.Selection">Selection</a></code> by Selecting columns with alias.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>alias</code></strong></dt>
<dd>An alias string of this table.</dd>
<dt><strong><code>includes</code></strong></dt>
<dd>Column names to select. All columns except specified in <code>excludes</code> are selected if empty.</dd>
<dt><strong><code>excludes</code></strong></dt>
<dd>Column names not to select.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Selection object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def select(cls, alias: str = &#34;&#34;, includes: list[str] = [], excludes: list[str] = [], single: bool = False):
    &#34;&#34;&#34;
    Default mixin class of every model type providing method to generate `Selection` by Selecting columns with alias.

    Args:
        alias: An alias string of this table.
        includes: Column names to select. All columns except specified in `excludes` are selected if empty.
        excludes: Column names not to select.
    Returns:
        Selection object.
    &#34;&#34;&#34;
    if single:
        return Aliased(alias, cast(type, cls)).select(includes, excludes)
    else:
        return FieldExpressions() + Aliased(alias, cast(type, cls)).select(includes, excludes)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.select.Selection"><code class="flex name class">
<span>class <span class="ident">Selection</span></span>
<span>(</span><span>table:Â type[~S], alias:Â str, columns:Â list[<a title="pyracmon.model.Column" href="model.html#pyracmon.model.Column">Column</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>A representation of table and its columns used in query.</p>
<p>This class is designed to be a bridge from query generation to reading results.
String expression of the instance is comma-separated column names prepended with alias, which can be embedded in the select query.</p>
<p>Due to <code><a title="pyracmon.select.SelectMixin" href="#pyracmon.select.SelectMixin">SelectMixin</a></code>, factory method is available on every model type.</p>
<pre><code class="language-python">&gt;&gt;&gt; s1 = table1.select(&quot;t1&quot;, includes = [&quot;col11&quot;, &quot;col12&quot;])
&gt;&gt;&gt; s2 = table2.select(&quot;t2&quot;)
&gt;&gt;&gt; str(s1)
't1.col11, t1.col12'
&gt;&gt;&gt; str(s2)
't2.col21, t2.col22, t2.col23'
</code></pre>
<p>The instances of this class are also used in <code><a title="pyracmon.select.read_row" href="#pyracmon.select.read_row">read_row()</a></code> to reconstruct model objects from each obtained row.</p>
<pre><code class="language-python">&gt;&gt;&gt; c.execute(f&quot;SELECT {s1}, {s2} FROM table1 AS t1 INNER JOIN table2 AS t2 ON ...&quot;)
&gt;&gt;&gt; for row in c.fetchall():
&gt;&gt;&gt;     r = read_row(row, s1, s2)
&gt;&gt;&gt;     assert isinstance(r.t1, table1)
&gt;&gt;&gt;     assert isinstance(r.t2, table2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Selection(Consumable, Generic[S]):
    &#34;&#34;&#34;
    A representation of table and its columns used in query.

    This class is designed to be a bridge from query generation to reading results.
    String expression of the instance is comma-separated column names prepended with alias, which can be embedded in the select query.

    Due to `SelectMixin`, factory method is available on every model type.

    ```python
    &gt;&gt;&gt; s1 = table1.select(&#34;t1&#34;, includes = [&#34;col11&#34;, &#34;col12&#34;])
    &gt;&gt;&gt; s2 = table2.select(&#34;t2&#34;)
    &gt;&gt;&gt; str(s1)
    &#39;t1.col11, t1.col12&#39;
    &gt;&gt;&gt; str(s2)
    &#39;t2.col21, t2.col22, t2.col23&#39;
    ```

    The instances of this class are also used in `read_row` to reconstruct model objects from each obtained row.

    ```python
    &gt;&gt;&gt; c.execute(f&#34;SELECT {s1}, {s2} FROM table1 AS t1 INNER JOIN table2 AS t2 ON ...&#34;)
    &gt;&gt;&gt; for row in c.fetchall():
    &gt;&gt;&gt;     r = read_row(row, s1, s2)
    &gt;&gt;&gt;     assert isinstance(r.t1, table1)
    &gt;&gt;&gt;     assert isinstance(r.t2, table2)
    ```
    &#34;&#34;&#34;
    def __init__(self, table: type[S], alias: str, columns: list[Column]):
        #: Model type.
        self.table = table
        #: An alias.
        self.alias = alias
        #: Columns to select.
        self.columns = columns

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
        Returns alias or name of the table.
        &#34;&#34;&#34;
        return self.alias if self.alias else cast(type[Model], self.table).name

    def __len__(self) -&gt; int:
        return len(self.columns)

    def __repr__(self) -&gt; str:
        a = f&#34;{self.alias}.&#34; if self.alias else &#34;&#34;
        return &#39;, &#39;.join([f&#34;{a}{c.name}&#34; for c in self.columns])

    def __add__(self, other) -&gt; &#39;FieldExpressions&#39;:
        return FieldExpressions() + self + other

    def __iter__(self):
        return iter([self])

    def __getattr__(self, key) -&gt; AliasedColumn:
        try:
            return AliasedColumn(self.alias, next(filter(lambda c: c.name == key, self.columns)))
        except StopIteration:
            raise KeyError(f&#34;{key} is not found from selected columns.&#34;)

    def consume(self, values: list[Any]) -&gt; S:
        &#34;&#34;&#34;
        Construct a model object from a row.

        Args:
            values: Values of row. The length must be equal to the number of columns in this.
        Returns:
            Model object where column values obtained from the row are set. 
        &#34;&#34;&#34;
        return self.table(**dict([(c.name, v) for c, v in zip(self.columns, values)]))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.select.Consumable" href="#pyracmon.select.Consumable">Consumable</a></li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.select.Selection.alias"><code class="name">var <span class="ident">alias</span></code></dt>
<dd>
<div class="desc"><p>An alias.</p></div>
</dd>
<dt id="pyracmon.select.Selection.columns"><code class="name">var <span class="ident">columns</span></code></dt>
<dd>
<div class="desc"><p>Columns to select.</p></div>
</dd>
<dt id="pyracmon.select.Selection.name"><code class="name">var <span class="ident">name</span> :Â str</code></dt>
<dd>
<div class="desc"><p>Returns alias or name of the table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
    Returns alias or name of the table.
    &#34;&#34;&#34;
    return self.alias if self.alias else cast(type[Model], self.table).name</code></pre>
</details>
</dd>
<dt id="pyracmon.select.Selection.table"><code class="name">var <span class="ident">table</span></code></dt>
<dd>
<div class="desc"><p>Model type.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.select.Selection.consume"><code class="name flex">
<span>def <span class="ident">consume</span></span>(<span>self, values:Â list[typing.Any]) â€‘>Â ~S</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a model object from a row.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd>Values of row. The length must be equal to the number of columns in this.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model object where column values obtained from the row are set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consume(self, values: list[Any]) -&gt; S:
    &#34;&#34;&#34;
    Construct a model object from a row.

    Args:
        values: Values of row. The length must be equal to the number of columns in this.
    Returns:
        Model object where column values obtained from the row are set. 
    &#34;&#34;&#34;
    return self.table(**dict([(c.name, v) for c, v in zip(self.columns, values)]))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.select.StrConsumable"><code class="flex name class">
<span>class <span class="ident">StrConsumable</span></span>
<span>(</span><span>key:Â str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StrConsumable(Consumable):
    def __init__(self, key: str) -&gt; None:
        self.key = key

    def __eq__(self, other: object) -&gt; bool:
        return isinstance(other, StrConsumable) and self.key == other.key

    def __len__(self) -&gt; int:
        return 1

    @property
    def name(self) -&gt; Optional[str]:
        return self.key

    def consume(self, values: list[Any]) -&gt; Any:
        return values[0]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.select.Consumable" href="#pyracmon.select.Consumable">Consumable</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.select.StrConsumable.name"><code class="name">var <span class="ident">name</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; Optional[str]:
    return self.key</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.select.StrConsumable.consume"><code class="name flex">
<span>def <span class="ident">consume</span></span>(<span>self, values:Â list[typing.Any]) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def consume(self, values: list[Any]) -&gt; Any:
    return values[0]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyracmon" href="index.html">pyracmon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyracmon.select.read_row" href="#pyracmon.select.read_row">read_row</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyracmon.select.Aliased" href="#pyracmon.select.Aliased">Aliased</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.select.Aliased.alias" href="#pyracmon.select.Aliased.alias">alias</a></code></li>
<li><code><a title="pyracmon.select.Aliased.model" href="#pyracmon.select.Aliased.model">model</a></code></li>
<li><code><a title="pyracmon.select.Aliased.select" href="#pyracmon.select.Aliased.select">select</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.select.AliasedColumn" href="#pyracmon.select.AliasedColumn">AliasedColumn</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.select.AliasedColumn.alias" href="#pyracmon.select.AliasedColumn.alias">alias</a></code></li>
<li><code><a title="pyracmon.select.AliasedColumn.column" href="#pyracmon.select.AliasedColumn.column">column</a></code></li>
<li><code><a title="pyracmon.select.AliasedColumn.name" href="#pyracmon.select.AliasedColumn.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.select.Consumable" href="#pyracmon.select.Consumable">Consumable</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.select.Consumable.consume" href="#pyracmon.select.Consumable.consume">consume</a></code></li>
<li><code><a title="pyracmon.select.Consumable.name" href="#pyracmon.select.Consumable.name">name</a></code></li>
<li><code><a title="pyracmon.select.Consumable.to_consumable" href="#pyracmon.select.Consumable.to_consumable">to_consumable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.select.EmptyConsumable" href="#pyracmon.select.EmptyConsumable">EmptyConsumable</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.select.EmptyConsumable.consume" href="#pyracmon.select.EmptyConsumable.consume">consume</a></code></li>
<li><code><a title="pyracmon.select.EmptyConsumable.name" href="#pyracmon.select.EmptyConsumable.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.select.FieldExpressions" href="#pyracmon.select.FieldExpressions">FieldExpressions</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.select.FieldExpressions.Instance" href="#pyracmon.select.FieldExpressions.Instance">Instance</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.select.RowValues" href="#pyracmon.select.RowValues">RowValues</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.select.RowValues.append" href="#pyracmon.select.RowValues.append">append</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.select.SelectMixin" href="#pyracmon.select.SelectMixin">SelectMixin</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.select.SelectMixin.select" href="#pyracmon.select.SelectMixin.select">select</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.select.Selection" href="#pyracmon.select.Selection">Selection</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.select.Selection.alias" href="#pyracmon.select.Selection.alias">alias</a></code></li>
<li><code><a title="pyracmon.select.Selection.columns" href="#pyracmon.select.Selection.columns">columns</a></code></li>
<li><code><a title="pyracmon.select.Selection.consume" href="#pyracmon.select.Selection.consume">consume</a></code></li>
<li><code><a title="pyracmon.select.Selection.name" href="#pyracmon.select.Selection.name">name</a></code></li>
<li><code><a title="pyracmon.select.Selection.table" href="#pyracmon.select.Selection.table">table</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.select.StrConsumable" href="#pyracmon.select.StrConsumable">StrConsumable</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.select.StrConsumable.consume" href="#pyracmon.select.StrConsumable.consume">consume</a></code></li>
<li><code><a title="pyracmon.select.StrConsumable.name" href="#pyracmon.select.StrConsumable.name">name</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>