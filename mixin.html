<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyracmon.mixin API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyracmon.mixin</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from functools import reduce
from typing import *
from .connection import Connection
from .model import *
from .select import *
from .query import *
from .util import key_to_index, Qualifier


class CRUDMixin(SelectMixin):
    &#34;&#34;&#34;
    Default mixin providing class methods available on all model types.

    Every method takes the DB connection object as its first argument.

    Following arguments are shared in some methods. Some of them have variations in their forms which are available commonly in every method.

    **pks**

    - `Dict[str, Any]`
        - Values of multiple primary keys. Key of `dict` corresponds to column name.
    - `Any`
        - A value of primary key. 

    **record**
    
    - `Model`
        - A model object representing a record. Only existing columns affects the operation.
    - `Dict[str, Any]`
        - A `dict` where column name is mapped to its value. Only existing columns affects the operation.

    **condition**

    - `Conditional`
        - Query condition to select rows to fetch, update or delete.

    **qualifier**

    - `Dict[str, Callable[[str], str]]`
        - Functions to convert query expressions for columns. Each function takes default expression and should return actual expression.

    **lock**

    - `Any`
        - This is reserved argument for locking statement but works just as the postfix of the query currently.
        - The usage will be changed in future version.

    Qualifier is used typically to convert or replace placeholder marker in insert/update query.
    By default, those queries contain markers like `insert into t (c1, c2) values (?, ?)` (`Q` parameter style).
    We need sometimes qualify markers to apply DB function, calculation, type cast and so on. This feature enables them like below.

    &gt;&gt;&gt; t.insert(db, dict(c1=1, c2=None), dict(c1=lambda x: f&#34;{x}+1&#34;, c2=lambda x: &#34;now()&#34;))
    &gt;&gt;&gt; # SQL: INSERT INTO t (c1, c2) VALUES (?+1, now())

    Be aware that when model object is used for the second argument, its column values may differ from actual values in DB after query.
    &#34;&#34;&#34;
    @classmethod
    def count(cls, db: Connection, condition: Conditional = Q.of()) -&gt; int:
        &#34;&#34;&#34;
        Count rows which satisfies the condition.

        &gt;&gt;&gt; t.count(db, Q.eq(c1=1))
        &gt;&gt;&gt; # SQL: SELECT COUNT(*) FROM t WHERE c1 = 1

        Args:
            db: DB connection.
            condition: Query condition.
        Returns:
            The number of rows.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        c = db.stmt().execute(f&#34;SELECT COUNT(*) FROM {cls.name}{_spacer(wc)}&#34;, *wp)
        return c.fetchone()[0]

    @classmethod
    def fetch(cls, db: Connection, pks: PKS, lock: Optional[Any] = None) -&gt; Optional[Model]:
        &#34;&#34;&#34;
        Fetch a record by primary key(s).

        &gt;&gt;&gt; t.fetch(db, 1)
        &gt;&gt;&gt; # SQL: SELECT * FROM t WHERE id = 1

        Args:
            db: DB connection.
            pks: Primary key value(s).
            lock: Locking statement.
        Returns:
            A model object if exists, otherwise `None`.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)
        cond = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
        wc, wp = where(cond)
        s = cls.select()
        c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}&#34;, *wp)
        row = c.fetchone()
        return read_row(row, s)[0] if row else None

    @classmethod
    def fetch_where(
        cls,
        db: Connection,
        condition: Conditional = Q.of(),
        orders: Dict[str, bool] = {},
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        lock: Optional[Any] = None,
    ) -&gt; List[Model]:
        &#34;&#34;&#34;
        Fetch records which satisfy the condition.

        &gt;&gt;&gt; t.fetch_where(db, Q.eq(c1=1), dict(c2=True), 10, 5)
        &gt;&gt;&gt; # SQL: SELECT * FROM t WHERE c1 = 1 ORDER BY c2 ASC LIMIT 10 OFFSET 5

        Args:
            db: DB connection.
            condition: Query condition.
            orders: Ordering specification where key is column name and value denotes whether the order is ascending or not.
            limit: Maximum nuber of rows to fetch. If `None`, all rows are returned.
            offset: The number of rows to skip.
            lock: Locking statement.
        Returns:
            Model objects.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        rc, rp = ranged_by(limit, offset)
        s = cls.select()
        c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(order_by(orders))}{_spacer(rc)}{_spacer(lock)}&#34;, *(wp + rp))
        return [read_row(row, s)[0] for row in c.fetchall()]

    @classmethod
    def fetch_one(
        cls,
        db: Connection,
        condition: Conditional = Q.of(),
        lock: Optional[Any] = None,
    ) -&gt; Optional[Model]:
        &#34;&#34;&#34;
        Fetch a record which satisfies the condition.

        `ValueError` raises When multiple records are found.
        Use this method for queries which certainly returns a single row, such as search by unique key.

        &gt;&gt;&gt; t.fetch_one(db, Q.eq(c1=1)), 5)
        &gt;&gt;&gt; # SQL: SELECT * FROM t WHERE c1 = 1

        Args:
            db: DB connection.
            condition: Query condition.
            lock: Locking statement.
        Returns:
            Model objects If exists, otherwise `None`.
        &#34;&#34;&#34;
        rs = cls.fetch_where(db, condition, lock=lock)

        if not rs:
            return None
        elif len(rs) == 1:
            return rs[0]
        else:
            raise ValueError(f&#34;{len(rs)} records are found on the invocation of fetch_one().&#34;)

    @classmethod
    def insert(cls, db: Connection, record: Record, qualifier: Qualifier = {}) -&gt; Model:
        &#34;&#34;&#34;
        Insert a record.

        Returned model object contains auto incremental column even if they are not set beforehand.
        On the contrary, default value generated in database side is not set.

        &gt;&gt;&gt; t.insert(db, dict(c1=1, c2=2))
        &gt;&gt;&gt; # SQL: INSERT INTO t (c1, c2) VALUES (1, 2)

        Args:
            db: DB connection.
            record: Object contains column values.
            qualifier: Functions qualifying placeholder markers.
        Returns:
            Model of inserted record.
        &#34;&#34;&#34;
        record = record if isinstance(record, cls) else cls(**record)
        value_dict = model_values(cls, record)
        check_columns(cls, value_dict)
        cols, vals = list(value_dict.keys()), list(value_dict.values())
        qualifier = key_to_index(qualifier, cols)

        db.stmt().execute(f&#34;INSERT INTO {cls.name} ({&#39;, &#39;.join(cols)}) VALUES {values(len(cols), 1, qualifier)}&#34;, *vals)

        for c, v in cls.last_sequences(db, 1):
            setattr(record, c.name, v)

        return record

    @classmethod
    def update(cls, db: Connection, pks: PKS, record: Record, qualifier: Qualifier = {}) -&gt; bool:
        &#34;&#34;&#34;
        Update a record by primary key(s).

        This method only updates columns which are found in `record` except for primary key(s).

        &gt;&gt;&gt; t.update(db, 1, dict(c1=1, c2=2))
        &gt;&gt;&gt; # SQL: UPDATE t SET c1 = 1, c2 = 2 WHERE id = 1

        Args:
            db: DB connection.
            pks: Primary key value(s).
            record: Object contains column values.
            qualifier: Functions qualifying placeholder markers.
        Returns:
            Whether the record exists and updated.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)
        return cls.update_where(db, record, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)]), qualifier) == 1

    @classmethod
    def update_where(
        cls,
        db: Connection,
        record: Record,
        condition: Conditional,
        qualifier: Qualifier = {},
        allow_all: bool = True,
    ) -&gt; int:
        &#34;&#34;&#34;
        Update records which satisfy the condition.

        &gt;&gt;&gt; t.update(db, dict(c2=2), Q.eq(c1=1))
        &gt;&gt;&gt; # SQL: UPDATE t SET c2 = 2 WHERE c1 = 1

        Args:
            db: DB connection.
            record: Object contains column values.
            condition: Query condition.
            qualifier: Functions qualifying placeholder markers.
            allow_all: If `False`, empty condition raises `ValueError`.
        Returns:
            The number of affected rows.
        &#34;&#34;&#34;
        value_dict = model_values(cls, record, excludes_pk=True)
        check_columns(cls, value_dict)
        cols, vals = list(value_dict.keys()), list(value_dict.values())
        qualifier = key_to_index(qualifier, cols)

        def set_col(acc, icv):
            i, (c, v) = icv
            if isinstance(v, Expression):
                clause = f&#34;{c} = {qualifier.get(i, lambda x:x)(v.expression)}&#34;
                params = v.params
            else:
                clause = f&#34;{c} = {qualifier.get(i, lambda x:x)(&#39;$_&#39;)}&#34;
                params = [v]
            acc[0].append(clause)
            acc[1].extend(params)
            return acc

        setters, params = reduce(set_col, enumerate(zip(cols, vals)), ([], []))

        wc, wp = where(condition)
        if wc == &#34;&#34; and not allow_all:
            raise ValueError(&#34;Update query to update all records is not allowed.&#34;)

        c = db.stmt().execute(f&#34;UPDATE {cls.name} SET {&#39;, &#39;.join(setters)}{_spacer(wc)}&#34;, *(params + wp))

        return getattr(c, &#34;rowcount&#34;, None)

    @classmethod
    def delete(cls, db: Connection, pks: PKS) -&gt; bool:
        &#34;&#34;&#34;
        Delete a record by primary key(s).

        &gt;&gt;&gt; t.delete(db, 1)
        &gt;&gt;&gt; # SQL: DELETE FROM t WHERE id = 1

        Args:
            db: DB connection.
            pks: Primary key value(s).
        Returns:
            Whether the record exists and deleted.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)
        return cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])) == 1

    @classmethod
    def delete_where(cls, db: Connection, condition: Conditional, allow_all: bool = True) -&gt; int:
        &#34;&#34;&#34;
        Delete records which satisfy the condition.

        &gt;&gt;&gt; t.delete(db, Q.eq(c1=1))
        &gt;&gt;&gt; # SQL: DELETE FROM t WHERE c1 = 1

        Args:
            db: DB connection.
            condition: Query condition.
            allow_all: If `False`, empty condition raises `ValueError`.
        Returns:
            The number of affected rows.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        if wc == &#34;&#34; and not allow_all:
            raise ValueError(&#34;Delete query to delete all records is not allowed.&#34;)

        c = db.stmt().execute(f&#34;DELETE FROM {cls.name}{_spacer(wc)}&#34;, *wp)

        return getattr(c, &#34;rowcount&#34;, None)

    @classmethod
    def last_sequences(cls, db: Connection, num: int) -&gt; List[Tuple[Column, int]]:
        &#34;&#34;&#34;
        Returns the sequential (auto incremental) values of a table generated by the latest insertion.

        Result contains every sequential columns and their values.
        When the latest query inserts multiple rows, only the last (= biggest) value is returned.

        This method should be overridden by another mixin class defined in dialect module.

        Args:
            db: DB connection.
            num: The number of records inserted by the latest query.
        Returns:
            List of pairs of column and its values.
        &#34;&#34;&#34;
        return []


def _spacer(s):
    return (&#34; &#34; + str(s)) if s else &#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyracmon.mixin.CRUDMixin"><code class="flex name class">
<span>class <span class="ident">CRUDMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Default mixin providing class methods available on all model types.</p>
<p>Every method takes the DB connection object as its first argument.</p>
<p>Following arguments are shared in some methods. Some of them have variations in their forms which are available commonly in every method.</p>
<p><strong>pks</strong></p>
<ul>
<li><code>Dict[str, Any]</code><ul>
<li>Values of multiple primary keys. Key of <code>dict</code> corresponds to column name.</li>
</ul>
</li>
<li><code>Any</code><ul>
<li>A value of primary key. </li>
</ul>
</li>
</ul>
<p><strong>record</strong></p>
<ul>
<li><code>Model</code><ul>
<li>A model object representing a record. Only existing columns affects the operation.</li>
</ul>
</li>
<li><code>Dict[str, Any]</code><ul>
<li>A <code>dict</code> where column name is mapped to its value. Only existing columns affects the operation.</li>
</ul>
</li>
</ul>
<p><strong>condition</strong></p>
<ul>
<li><code>Conditional</code><ul>
<li>Query condition to select rows to fetch, update or delete.</li>
</ul>
</li>
</ul>
<p><strong>qualifier</strong></p>
<ul>
<li><code>Dict[str, Callable[[str], str]]</code><ul>
<li>Functions to convert query expressions for columns. Each function takes default expression and should return actual expression.</li>
</ul>
</li>
</ul>
<p><strong>lock</strong></p>
<ul>
<li><code>Any</code><ul>
<li>This is reserved argument for locking statement but works just as the postfix of the query currently.</li>
<li>The usage will be changed in future version.</li>
</ul>
</li>
</ul>
<p>Qualifier is used typically to convert or replace placeholder marker in insert/update query.
By default, those queries contain markers like <code>insert into t (c1, c2) values (?, ?)</code> (<code>Q</code> parameter style).
We need sometimes qualify markers to apply DB function, calculation, type cast and so on. This feature enables them like below.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.insert(db, dict(c1=1, c2=None), dict(c1=lambda x: f&quot;{x}+1&quot;, c2=lambda x: &quot;now()&quot;))
&gt;&gt;&gt; # SQL: INSERT INTO t (c1, c2) VALUES (?+1, now())
</code></pre>
<p>Be aware that when model object is used for the second argument, its column values may differ from actual values in DB after query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CRUDMixin(SelectMixin):
    &#34;&#34;&#34;
    Default mixin providing class methods available on all model types.

    Every method takes the DB connection object as its first argument.

    Following arguments are shared in some methods. Some of them have variations in their forms which are available commonly in every method.

    **pks**

    - `Dict[str, Any]`
        - Values of multiple primary keys. Key of `dict` corresponds to column name.
    - `Any`
        - A value of primary key. 

    **record**
    
    - `Model`
        - A model object representing a record. Only existing columns affects the operation.
    - `Dict[str, Any]`
        - A `dict` where column name is mapped to its value. Only existing columns affects the operation.

    **condition**

    - `Conditional`
        - Query condition to select rows to fetch, update or delete.

    **qualifier**

    - `Dict[str, Callable[[str], str]]`
        - Functions to convert query expressions for columns. Each function takes default expression and should return actual expression.

    **lock**

    - `Any`
        - This is reserved argument for locking statement but works just as the postfix of the query currently.
        - The usage will be changed in future version.

    Qualifier is used typically to convert or replace placeholder marker in insert/update query.
    By default, those queries contain markers like `insert into t (c1, c2) values (?, ?)` (`Q` parameter style).
    We need sometimes qualify markers to apply DB function, calculation, type cast and so on. This feature enables them like below.

    &gt;&gt;&gt; t.insert(db, dict(c1=1, c2=None), dict(c1=lambda x: f&#34;{x}+1&#34;, c2=lambda x: &#34;now()&#34;))
    &gt;&gt;&gt; # SQL: INSERT INTO t (c1, c2) VALUES (?+1, now())

    Be aware that when model object is used for the second argument, its column values may differ from actual values in DB after query.
    &#34;&#34;&#34;
    @classmethod
    def count(cls, db: Connection, condition: Conditional = Q.of()) -&gt; int:
        &#34;&#34;&#34;
        Count rows which satisfies the condition.

        &gt;&gt;&gt; t.count(db, Q.eq(c1=1))
        &gt;&gt;&gt; # SQL: SELECT COUNT(*) FROM t WHERE c1 = 1

        Args:
            db: DB connection.
            condition: Query condition.
        Returns:
            The number of rows.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        c = db.stmt().execute(f&#34;SELECT COUNT(*) FROM {cls.name}{_spacer(wc)}&#34;, *wp)
        return c.fetchone()[0]

    @classmethod
    def fetch(cls, db: Connection, pks: PKS, lock: Optional[Any] = None) -&gt; Optional[Model]:
        &#34;&#34;&#34;
        Fetch a record by primary key(s).

        &gt;&gt;&gt; t.fetch(db, 1)
        &gt;&gt;&gt; # SQL: SELECT * FROM t WHERE id = 1

        Args:
            db: DB connection.
            pks: Primary key value(s).
            lock: Locking statement.
        Returns:
            A model object if exists, otherwise `None`.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)
        cond = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
        wc, wp = where(cond)
        s = cls.select()
        c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}&#34;, *wp)
        row = c.fetchone()
        return read_row(row, s)[0] if row else None

    @classmethod
    def fetch_where(
        cls,
        db: Connection,
        condition: Conditional = Q.of(),
        orders: Dict[str, bool] = {},
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        lock: Optional[Any] = None,
    ) -&gt; List[Model]:
        &#34;&#34;&#34;
        Fetch records which satisfy the condition.

        &gt;&gt;&gt; t.fetch_where(db, Q.eq(c1=1), dict(c2=True), 10, 5)
        &gt;&gt;&gt; # SQL: SELECT * FROM t WHERE c1 = 1 ORDER BY c2 ASC LIMIT 10 OFFSET 5

        Args:
            db: DB connection.
            condition: Query condition.
            orders: Ordering specification where key is column name and value denotes whether the order is ascending or not.
            limit: Maximum nuber of rows to fetch. If `None`, all rows are returned.
            offset: The number of rows to skip.
            lock: Locking statement.
        Returns:
            Model objects.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        rc, rp = ranged_by(limit, offset)
        s = cls.select()
        c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(order_by(orders))}{_spacer(rc)}{_spacer(lock)}&#34;, *(wp + rp))
        return [read_row(row, s)[0] for row in c.fetchall()]

    @classmethod
    def fetch_one(
        cls,
        db: Connection,
        condition: Conditional = Q.of(),
        lock: Optional[Any] = None,
    ) -&gt; Optional[Model]:
        &#34;&#34;&#34;
        Fetch a record which satisfies the condition.

        `ValueError` raises When multiple records are found.
        Use this method for queries which certainly returns a single row, such as search by unique key.

        &gt;&gt;&gt; t.fetch_one(db, Q.eq(c1=1)), 5)
        &gt;&gt;&gt; # SQL: SELECT * FROM t WHERE c1 = 1

        Args:
            db: DB connection.
            condition: Query condition.
            lock: Locking statement.
        Returns:
            Model objects If exists, otherwise `None`.
        &#34;&#34;&#34;
        rs = cls.fetch_where(db, condition, lock=lock)

        if not rs:
            return None
        elif len(rs) == 1:
            return rs[0]
        else:
            raise ValueError(f&#34;{len(rs)} records are found on the invocation of fetch_one().&#34;)

    @classmethod
    def insert(cls, db: Connection, record: Record, qualifier: Qualifier = {}) -&gt; Model:
        &#34;&#34;&#34;
        Insert a record.

        Returned model object contains auto incremental column even if they are not set beforehand.
        On the contrary, default value generated in database side is not set.

        &gt;&gt;&gt; t.insert(db, dict(c1=1, c2=2))
        &gt;&gt;&gt; # SQL: INSERT INTO t (c1, c2) VALUES (1, 2)

        Args:
            db: DB connection.
            record: Object contains column values.
            qualifier: Functions qualifying placeholder markers.
        Returns:
            Model of inserted record.
        &#34;&#34;&#34;
        record = record if isinstance(record, cls) else cls(**record)
        value_dict = model_values(cls, record)
        check_columns(cls, value_dict)
        cols, vals = list(value_dict.keys()), list(value_dict.values())
        qualifier = key_to_index(qualifier, cols)

        db.stmt().execute(f&#34;INSERT INTO {cls.name} ({&#39;, &#39;.join(cols)}) VALUES {values(len(cols), 1, qualifier)}&#34;, *vals)

        for c, v in cls.last_sequences(db, 1):
            setattr(record, c.name, v)

        return record

    @classmethod
    def update(cls, db: Connection, pks: PKS, record: Record, qualifier: Qualifier = {}) -&gt; bool:
        &#34;&#34;&#34;
        Update a record by primary key(s).

        This method only updates columns which are found in `record` except for primary key(s).

        &gt;&gt;&gt; t.update(db, 1, dict(c1=1, c2=2))
        &gt;&gt;&gt; # SQL: UPDATE t SET c1 = 1, c2 = 2 WHERE id = 1

        Args:
            db: DB connection.
            pks: Primary key value(s).
            record: Object contains column values.
            qualifier: Functions qualifying placeholder markers.
        Returns:
            Whether the record exists and updated.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)
        return cls.update_where(db, record, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)]), qualifier) == 1

    @classmethod
    def update_where(
        cls,
        db: Connection,
        record: Record,
        condition: Conditional,
        qualifier: Qualifier = {},
        allow_all: bool = True,
    ) -&gt; int:
        &#34;&#34;&#34;
        Update records which satisfy the condition.

        &gt;&gt;&gt; t.update(db, dict(c2=2), Q.eq(c1=1))
        &gt;&gt;&gt; # SQL: UPDATE t SET c2 = 2 WHERE c1 = 1

        Args:
            db: DB connection.
            record: Object contains column values.
            condition: Query condition.
            qualifier: Functions qualifying placeholder markers.
            allow_all: If `False`, empty condition raises `ValueError`.
        Returns:
            The number of affected rows.
        &#34;&#34;&#34;
        value_dict = model_values(cls, record, excludes_pk=True)
        check_columns(cls, value_dict)
        cols, vals = list(value_dict.keys()), list(value_dict.values())
        qualifier = key_to_index(qualifier, cols)

        def set_col(acc, icv):
            i, (c, v) = icv
            if isinstance(v, Expression):
                clause = f&#34;{c} = {qualifier.get(i, lambda x:x)(v.expression)}&#34;
                params = v.params
            else:
                clause = f&#34;{c} = {qualifier.get(i, lambda x:x)(&#39;$_&#39;)}&#34;
                params = [v]
            acc[0].append(clause)
            acc[1].extend(params)
            return acc

        setters, params = reduce(set_col, enumerate(zip(cols, vals)), ([], []))

        wc, wp = where(condition)
        if wc == &#34;&#34; and not allow_all:
            raise ValueError(&#34;Update query to update all records is not allowed.&#34;)

        c = db.stmt().execute(f&#34;UPDATE {cls.name} SET {&#39;, &#39;.join(setters)}{_spacer(wc)}&#34;, *(params + wp))

        return getattr(c, &#34;rowcount&#34;, None)

    @classmethod
    def delete(cls, db: Connection, pks: PKS) -&gt; bool:
        &#34;&#34;&#34;
        Delete a record by primary key(s).

        &gt;&gt;&gt; t.delete(db, 1)
        &gt;&gt;&gt; # SQL: DELETE FROM t WHERE id = 1

        Args:
            db: DB connection.
            pks: Primary key value(s).
        Returns:
            Whether the record exists and deleted.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)
        return cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])) == 1

    @classmethod
    def delete_where(cls, db: Connection, condition: Conditional, allow_all: bool = True) -&gt; int:
        &#34;&#34;&#34;
        Delete records which satisfy the condition.

        &gt;&gt;&gt; t.delete(db, Q.eq(c1=1))
        &gt;&gt;&gt; # SQL: DELETE FROM t WHERE c1 = 1

        Args:
            db: DB connection.
            condition: Query condition.
            allow_all: If `False`, empty condition raises `ValueError`.
        Returns:
            The number of affected rows.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        if wc == &#34;&#34; and not allow_all:
            raise ValueError(&#34;Delete query to delete all records is not allowed.&#34;)

        c = db.stmt().execute(f&#34;DELETE FROM {cls.name}{_spacer(wc)}&#34;, *wp)

        return getattr(c, &#34;rowcount&#34;, None)

    @classmethod
    def last_sequences(cls, db: Connection, num: int) -&gt; List[Tuple[Column, int]]:
        &#34;&#34;&#34;
        Returns the sequential (auto incremental) values of a table generated by the latest insertion.

        Result contains every sequential columns and their values.
        When the latest query inserts multiple rows, only the last (= biggest) value is returned.

        This method should be overridden by another mixin class defined in dialect module.

        Args:
            db: DB connection.
            num: The number of records inserted by the latest query.
        Returns:
            List of pairs of column and its values.
        &#34;&#34;&#34;
        return []</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.select.SelectMixin" href="select.html#pyracmon.select.SelectMixin">SelectMixin</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.mixin.CRUDMixin.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition: <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a> = Condition: '' -- []) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Count rows which satisfies the condition.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.count(db, Q.eq(c1=1))
&gt;&gt;&gt; # SQL: SELECT COUNT(*) FROM t WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of rows.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def count(cls, db: Connection, condition: Conditional = Q.of()) -&gt; int:
    &#34;&#34;&#34;
    Count rows which satisfies the condition.

    &gt;&gt;&gt; t.count(db, Q.eq(c1=1))
    &gt;&gt;&gt; # SQL: SELECT COUNT(*) FROM t WHERE c1 = 1

    Args:
        db: DB connection.
        condition: Query condition.
    Returns:
        The number of rows.
    &#34;&#34;&#34;
    wc, wp = where(condition)
    c = db.stmt().execute(f&#34;SELECT COUNT(*) FROM {cls.name}{_spacer(wc)}&#34;, *wp)
    return c.fetchone()[0]</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, pks: Union[Any, Dict[str, Any]]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a record by primary key(s).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.delete(db, 1)
&gt;&gt;&gt; # SQL: DELETE FROM t WHERE id = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>pks</code></strong></dt>
<dd>Primary key value(s).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the record exists and deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete(cls, db: Connection, pks: PKS) -&gt; bool:
    &#34;&#34;&#34;
    Delete a record by primary key(s).

    &gt;&gt;&gt; t.delete(db, 1)
    &gt;&gt;&gt; # SQL: DELETE FROM t WHERE id = 1

    Args:
        db: DB connection.
        pks: Primary key value(s).
    Returns:
        Whether the record exists and deleted.
    &#34;&#34;&#34;
    cols, vals = parse_pks(cls, pks)
    return cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])) == 1</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.delete_where"><code class="name flex">
<span>def <span class="ident">delete_where</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition: <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a>, allow_all: bool = True) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Delete records which satisfy the condition.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.delete(db, Q.eq(c1=1))
&gt;&gt;&gt; # SQL: DELETE FROM t WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>allow_all</code></strong></dt>
<dd>If <code>False</code>, empty condition raises <code>ValueError</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of affected rows.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete_where(cls, db: Connection, condition: Conditional, allow_all: bool = True) -&gt; int:
    &#34;&#34;&#34;
    Delete records which satisfy the condition.

    &gt;&gt;&gt; t.delete(db, Q.eq(c1=1))
    &gt;&gt;&gt; # SQL: DELETE FROM t WHERE c1 = 1

    Args:
        db: DB connection.
        condition: Query condition.
        allow_all: If `False`, empty condition raises `ValueError`.
    Returns:
        The number of affected rows.
    &#34;&#34;&#34;
    wc, wp = where(condition)
    if wc == &#34;&#34; and not allow_all:
        raise ValueError(&#34;Delete query to delete all records is not allowed.&#34;)

    c = db.stmt().execute(f&#34;DELETE FROM {cls.name}{_spacer(wc)}&#34;, *wp)

    return getattr(c, &#34;rowcount&#34;, None)</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, pks: Union[Any, Dict[str, Any]], lock: Optional[Any] = None) ‑> Optional[<a title="pyracmon.model.Model" href="model.html#pyracmon.model.Model">Model</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a record by primary key(s).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.fetch(db, 1)
&gt;&gt;&gt; # SQL: SELECT * FROM t WHERE id = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>pks</code></strong></dt>
<dd>Primary key value(s).</dd>
<dt><strong><code>lock</code></strong></dt>
<dd>Locking statement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A model object if exists, otherwise <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fetch(cls, db: Connection, pks: PKS, lock: Optional[Any] = None) -&gt; Optional[Model]:
    &#34;&#34;&#34;
    Fetch a record by primary key(s).

    &gt;&gt;&gt; t.fetch(db, 1)
    &gt;&gt;&gt; # SQL: SELECT * FROM t WHERE id = 1

    Args:
        db: DB connection.
        pks: Primary key value(s).
        lock: Locking statement.
    Returns:
        A model object if exists, otherwise `None`.
    &#34;&#34;&#34;
    cols, vals = parse_pks(cls, pks)
    cond = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
    wc, wp = where(cond)
    s = cls.select()
    c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}&#34;, *wp)
    row = c.fetchone()
    return read_row(row, s)[0] if row else None</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.fetch_one"><code class="name flex">
<span>def <span class="ident">fetch_one</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition: <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a> = Condition: '' -- [], lock: Optional[Any] = None) ‑> Optional[<a title="pyracmon.model.Model" href="model.html#pyracmon.model.Model">Model</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a record which satisfies the condition.</p>
<p><code>ValueError</code> raises When multiple records are found.
Use this method for queries which certainly returns a single row, such as search by unique key.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.fetch_one(db, Q.eq(c1=1)), 5)
&gt;&gt;&gt; # SQL: SELECT * FROM t WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>lock</code></strong></dt>
<dd>Locking statement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model objects If exists, otherwise <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fetch_one(
    cls,
    db: Connection,
    condition: Conditional = Q.of(),
    lock: Optional[Any] = None,
) -&gt; Optional[Model]:
    &#34;&#34;&#34;
    Fetch a record which satisfies the condition.

    `ValueError` raises When multiple records are found.
    Use this method for queries which certainly returns a single row, such as search by unique key.

    &gt;&gt;&gt; t.fetch_one(db, Q.eq(c1=1)), 5)
    &gt;&gt;&gt; # SQL: SELECT * FROM t WHERE c1 = 1

    Args:
        db: DB connection.
        condition: Query condition.
        lock: Locking statement.
    Returns:
        Model objects If exists, otherwise `None`.
    &#34;&#34;&#34;
    rs = cls.fetch_where(db, condition, lock=lock)

    if not rs:
        return None
    elif len(rs) == 1:
        return rs[0]
    else:
        raise ValueError(f&#34;{len(rs)} records are found on the invocation of fetch_one().&#34;)</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.fetch_where"><code class="name flex">
<span>def <span class="ident">fetch_where</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition: <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a> = Condition: '' -- [], orders: Dict[str, bool] = {}, limit: Optional[int] = None, offset: Optional[int] = None, lock: Optional[Any] = None) ‑> List[<a title="pyracmon.model.Model" href="model.html#pyracmon.model.Model">Model</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch records which satisfy the condition.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.fetch_where(db, Q.eq(c1=1), dict(c2=True), 10, 5)
&gt;&gt;&gt; # SQL: SELECT * FROM t WHERE c1 = 1 ORDER BY c2 ASC LIMIT 10 OFFSET 5
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>orders</code></strong></dt>
<dd>Ordering specification where key is column name and value denotes whether the order is ascending or not.</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>Maximum nuber of rows to fetch. If <code>None</code>, all rows are returned.</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>The number of rows to skip.</dd>
<dt><strong><code>lock</code></strong></dt>
<dd>Locking statement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fetch_where(
    cls,
    db: Connection,
    condition: Conditional = Q.of(),
    orders: Dict[str, bool] = {},
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    lock: Optional[Any] = None,
) -&gt; List[Model]:
    &#34;&#34;&#34;
    Fetch records which satisfy the condition.

    &gt;&gt;&gt; t.fetch_where(db, Q.eq(c1=1), dict(c2=True), 10, 5)
    &gt;&gt;&gt; # SQL: SELECT * FROM t WHERE c1 = 1 ORDER BY c2 ASC LIMIT 10 OFFSET 5

    Args:
        db: DB connection.
        condition: Query condition.
        orders: Ordering specification where key is column name and value denotes whether the order is ascending or not.
        limit: Maximum nuber of rows to fetch. If `None`, all rows are returned.
        offset: The number of rows to skip.
        lock: Locking statement.
    Returns:
        Model objects.
    &#34;&#34;&#34;
    wc, wp = where(condition)
    rc, rp = ranged_by(limit, offset)
    s = cls.select()
    c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(order_by(orders))}{_spacer(rc)}{_spacer(lock)}&#34;, *(wp + rp))
    return [read_row(row, s)[0] for row in c.fetchall()]</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, record: Union[<a title="pyracmon.model.Model" href="model.html#pyracmon.model.Model">Model</a>, Dict[str, Any]], qualifier: Dict[str, Callable[[str], str]] = {}) ‑> <a title="pyracmon.model.Model" href="model.html#pyracmon.model.Model">Model</a></span>
</code></dt>
<dd>
<div class="desc"><p>Insert a record.</p>
<p>Returned model object contains auto incremental column even if they are not set beforehand.
On the contrary, default value generated in database side is not set.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.insert(db, dict(c1=1, c2=2))
&gt;&gt;&gt; # SQL: INSERT INTO t (c1, c2) VALUES (1, 2)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Object contains column values.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model of inserted record.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def insert(cls, db: Connection, record: Record, qualifier: Qualifier = {}) -&gt; Model:
    &#34;&#34;&#34;
    Insert a record.

    Returned model object contains auto incremental column even if they are not set beforehand.
    On the contrary, default value generated in database side is not set.

    &gt;&gt;&gt; t.insert(db, dict(c1=1, c2=2))
    &gt;&gt;&gt; # SQL: INSERT INTO t (c1, c2) VALUES (1, 2)

    Args:
        db: DB connection.
        record: Object contains column values.
        qualifier: Functions qualifying placeholder markers.
    Returns:
        Model of inserted record.
    &#34;&#34;&#34;
    record = record if isinstance(record, cls) else cls(**record)
    value_dict = model_values(cls, record)
    check_columns(cls, value_dict)
    cols, vals = list(value_dict.keys()), list(value_dict.values())
    qualifier = key_to_index(qualifier, cols)

    db.stmt().execute(f&#34;INSERT INTO {cls.name} ({&#39;, &#39;.join(cols)}) VALUES {values(len(cols), 1, qualifier)}&#34;, *vals)

    for c, v in cls.last_sequences(db, 1):
        setattr(record, c.name, v)

    return record</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.last_sequences"><code class="name flex">
<span>def <span class="ident">last_sequences</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, num: int) ‑> List[Tuple[<a title="pyracmon.model.Column" href="model.html#pyracmon.model.Column">Column</a>, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sequential (auto incremental) values of a table generated by the latest insertion.</p>
<p>Result contains every sequential columns and their values.
When the latest query inserts multiple rows, only the last (= biggest) value is returned.</p>
<p>This method should be overridden by another mixin class defined in dialect module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>num</code></strong></dt>
<dd>The number of records inserted by the latest query.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of pairs of column and its values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def last_sequences(cls, db: Connection, num: int) -&gt; List[Tuple[Column, int]]:
    &#34;&#34;&#34;
    Returns the sequential (auto incremental) values of a table generated by the latest insertion.

    Result contains every sequential columns and their values.
    When the latest query inserts multiple rows, only the last (= biggest) value is returned.

    This method should be overridden by another mixin class defined in dialect module.

    Args:
        db: DB connection.
        num: The number of records inserted by the latest query.
    Returns:
        List of pairs of column and its values.
    &#34;&#34;&#34;
    return []</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, pks: Union[Any, Dict[str, Any]], record: Union[<a title="pyracmon.model.Model" href="model.html#pyracmon.model.Model">Model</a>, Dict[str, Any]], qualifier: Dict[str, Callable[[str], str]] = {}) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Update a record by primary key(s).</p>
<p>This method only updates columns which are found in <code>record</code> except for primary key(s).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.update(db, 1, dict(c1=1, c2=2))
&gt;&gt;&gt; # SQL: UPDATE t SET c1 = 1, c2 = 2 WHERE id = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>pks</code></strong></dt>
<dd>Primary key value(s).</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Object contains column values.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the record exists and updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def update(cls, db: Connection, pks: PKS, record: Record, qualifier: Qualifier = {}) -&gt; bool:
    &#34;&#34;&#34;
    Update a record by primary key(s).

    This method only updates columns which are found in `record` except for primary key(s).

    &gt;&gt;&gt; t.update(db, 1, dict(c1=1, c2=2))
    &gt;&gt;&gt; # SQL: UPDATE t SET c1 = 1, c2 = 2 WHERE id = 1

    Args:
        db: DB connection.
        pks: Primary key value(s).
        record: Object contains column values.
        qualifier: Functions qualifying placeholder markers.
    Returns:
        Whether the record exists and updated.
    &#34;&#34;&#34;
    cols, vals = parse_pks(cls, pks)
    return cls.update_where(db, record, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)]), qualifier) == 1</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.update_where"><code class="name flex">
<span>def <span class="ident">update_where</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, record: Union[<a title="pyracmon.model.Model" href="model.html#pyracmon.model.Model">Model</a>, Dict[str, Any]], condition: <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a>, qualifier: Dict[str, Callable[[str], str]] = {}, allow_all: bool = True) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Update records which satisfy the condition.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.update(db, dict(c2=2), Q.eq(c1=1))
&gt;&gt;&gt; # SQL: UPDATE t SET c2 = 2 WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Object contains column values.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
<dt><strong><code>allow_all</code></strong></dt>
<dd>If <code>False</code>, empty condition raises <code>ValueError</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of affected rows.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def update_where(
    cls,
    db: Connection,
    record: Record,
    condition: Conditional,
    qualifier: Qualifier = {},
    allow_all: bool = True,
) -&gt; int:
    &#34;&#34;&#34;
    Update records which satisfy the condition.

    &gt;&gt;&gt; t.update(db, dict(c2=2), Q.eq(c1=1))
    &gt;&gt;&gt; # SQL: UPDATE t SET c2 = 2 WHERE c1 = 1

    Args:
        db: DB connection.
        record: Object contains column values.
        condition: Query condition.
        qualifier: Functions qualifying placeholder markers.
        allow_all: If `False`, empty condition raises `ValueError`.
    Returns:
        The number of affected rows.
    &#34;&#34;&#34;
    value_dict = model_values(cls, record, excludes_pk=True)
    check_columns(cls, value_dict)
    cols, vals = list(value_dict.keys()), list(value_dict.values())
    qualifier = key_to_index(qualifier, cols)

    def set_col(acc, icv):
        i, (c, v) = icv
        if isinstance(v, Expression):
            clause = f&#34;{c} = {qualifier.get(i, lambda x:x)(v.expression)}&#34;
            params = v.params
        else:
            clause = f&#34;{c} = {qualifier.get(i, lambda x:x)(&#39;$_&#39;)}&#34;
            params = [v]
        acc[0].append(clause)
        acc[1].extend(params)
        return acc

    setters, params = reduce(set_col, enumerate(zip(cols, vals)), ([], []))

    wc, wp = where(condition)
    if wc == &#34;&#34; and not allow_all:
        raise ValueError(&#34;Update query to update all records is not allowed.&#34;)

    c = db.stmt().execute(f&#34;UPDATE {cls.name} SET {&#39;, &#39;.join(setters)}{_spacer(wc)}&#34;, *(params + wp))

    return getattr(c, &#34;rowcount&#34;, None)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyracmon.select.SelectMixin" href="select.html#pyracmon.select.SelectMixin">SelectMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyracmon.select.SelectMixin.select" href="select.html#pyracmon.select.SelectMixin.select">select</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyracmon" href="index.html">pyracmon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyracmon.mixin.CRUDMixin" href="#pyracmon.mixin.CRUDMixin">CRUDMixin</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.mixin.CRUDMixin.count" href="#pyracmon.mixin.CRUDMixin.count">count</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.delete" href="#pyracmon.mixin.CRUDMixin.delete">delete</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.delete_where" href="#pyracmon.mixin.CRUDMixin.delete_where">delete_where</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.fetch" href="#pyracmon.mixin.CRUDMixin.fetch">fetch</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.fetch_one" href="#pyracmon.mixin.CRUDMixin.fetch_one">fetch_one</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.fetch_where" href="#pyracmon.mixin.CRUDMixin.fetch_where">fetch_where</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.insert" href="#pyracmon.mixin.CRUDMixin.insert">insert</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.last_sequences" href="#pyracmon.mixin.CRUDMixin.last_sequences">last_sequences</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.update" href="#pyracmon.mixin.CRUDMixin.update">update</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.update_where" href="#pyracmon.mixin.CRUDMixin.update_where">update_where</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>