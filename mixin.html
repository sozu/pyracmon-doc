<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyracmon.mixin API documentation</title>
<meta name="description" content="This module provides mixin type which supplies each model type various DB operations as class methods." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyracmon.mixin</code></h1>
</header>
<section id="section-intro">
<p>This module provides mixin type which supplies each model type various DB operations as class methods.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides mixin type which supplies each model type various DB operations as class methods.
&#34;&#34;&#34;
from collections.abc import Mapping, Sequence, Callable
from functools import reduce
from typing import Any, Optional, Union, Literal, cast, overload, Protocol, TYPE_CHECKING
from typing_extensions import Self
from .connection import Connection
from .dbapi import Cursor
from .model import Meta, Column, Record, parse_pks, check_columns, model_values, extract_pks
from .select import SelectMixin, AliasedColumn, read_row
from .query import Q, Expression, Conditional, where
from .clause import ORDER, ranged_by, order_by, values
from .util import key_to_index, Qualifier, PKS


if TYPE_CHECKING:
    class CRUDInternalMeta(Meta):
        @classmethod
        def last_sequences(cls, db: Connection, num: int) -&gt; list[tuple[Column, int]]: ...

        @classmethod
        def support_returning(cls, db: Connection) -&gt; bool: ...
else:
    class CRUDInternalMeta:
        pass


class CRUDMixin(SelectMixin, CRUDInternalMeta):
    &#34;&#34;&#34;
    Default mixin providing class methods available on all model types.

    Every method takes the DB connection object as its first argument.
    Following arguments are defined in several methods commonly.

    - `pks`
        - Names and values of all primary key columns in form of `dict` .
        - A primary key value. This form is allowed when the table has just one primary key column.
        - e.g. If the table has a single primary key `id` of int, `1` is available to spcecify the row of `id = 1` .
        - e.g. If the table has multiple primary keys `intid` and `strid`, `dict(intid=1, strid=&#34;abc&#34;)` is a valid argument.
    - `record`
        - A model object or a mapping from column name to its value, which corresponds to a table row.
        - Only columns contained in the record is affected by the operation.
        - e.g. When `dict(c1=1, c2=&#34;abc&#34;)` is passed for insertion, only `c1` and `c2` are set in INSERT query.
        - e.g. For update, only the columns will be updated. Other columns are not affected.
    - `condition`
        - Query condition which will compose WHERE clause.
        - `pyracmon.query.Q` is a factory class to create condition object.
        - When `None` is passed, all rows are subject to the operation.
    - `qualifier`
        - A mapping from column name to a function which qualifies a placeholder passed by an argument.
        - Detail of qualifier function is described below.
    - `lock`
        - This is reserved argument for locking statement but works just as the postfix of the query currently.
        - The usage will be changed in future version.

    Qualifier function is used typically to convert or replace placeholder marker in insert/update query.
    By default, those queries contain markers like `insert into t (c1, c2) values (?, ?)` (`Q` parameter style).
    We need sometimes qualify markers to apply DB function, calculation, type cast and so on. This feature enables them like below.

    ```python
    t.insert(db, dict(c1=1, c2=None), dict(c1=lambda x: f&#34;{x}+1&#34;, c2=lambda x: &#34;now()&#34;))
    # SQL: INSERT INTO t (c1, c2) VALUES (?+1, now())
    ```

    Be aware that when model object is passed, its column values may differ from actual values in DB after query.
    &#34;&#34;&#34;
    @classmethod
    def count(cls, db: Connection, condition: Conditional = Q.of()) -&gt; int:
        &#34;&#34;&#34;
        Count rows which satisfies the condition.

        ```python
        t.count(db, Q.eq(c1=1))
        # SQL: SELECT COUNT(*) FROM t WHERE c1 = 1
        ```

        Args:
            db: DB connection.
            condition: Query condition.
        Returns:
            The number of rows.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        c = db.stmt().execute(f&#34;SELECT COUNT(*) FROM {cls.name}{_spacer(wc)}&#34;, *wp)
        return c.fetchone()[0] # type: ignore

    @classmethod
    def fetch(cls, db: Connection, pks: PKS, lock: Optional[Any] = None) -&gt; Optional[Self]:
        &#34;&#34;&#34;
        Fetch a record by primary key(s).

        ```python
        t.fetch(db, 1)
        # SQL: SELECT * FROM t WHERE id = 1
        ```

        Args:
            db: DB connection.
            pks: Primary key value(s).
            lock: Locking statement.
        Returns:
            A model object if exists, otherwise `None`.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)
        cond = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
        wc, wp = where(cond)
        s = cls.select()
        c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}&#34;, *wp)
        row = c.fetchone()
        return read_row(row, *s)[0] if row else None

    @classmethod
    def fetch_many(cls, db: Connection, seq_pks: Sequence[PKS], lock: Optional[Any] = None, /, per_page: int = 1000) -&gt; list[Self]:
        &#34;&#34;&#34;
        Fetch a record by sequence of primary key(s).

        This method simply concatenates equality conditions on primary key by OR operator.

        ```python
        t.fetch_many(db, [1, 2, 3])
        # SQL: SELECT * FROM t WHERE id = 1 OR id = 2 OR id = 3
        ```

        Args:
            db: DB connection.
            seq_pks: Sequence of primary key value.
            lock: Locking statement.
            per_page: Maximum number of keys for an execution of query.
        Returns:
            Model objects in the same order as passed sequence.
        &#34;&#34;&#34;
        res = []
        index = 0
        while index &lt; len(seq_pks):
            ordered_pks = []
            cond = Q.of()
            for pks in seq_pks[index:index+per_page]:
                cols, vals = parse_pks(cls, pks)
                ordered_pks.append(tuple(v for v in vals))
                cond |= Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
            wc, wp = where(cond)
            s = cls.select()
            c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}&#34;, *wp)

            record_map = {}
            for r in [read_row(row, *s)[0] for row in c.fetchall()]:
                pk_values = {c.name:v for c, v in r if c.pk}
                record_map[tuple([v for _, v in check_columns(cls, pk_values, lambda c: c.pk, True)])] = r

            res.extend([record_map[k] for k in ordered_pks if k in record_map])
            index += per_page

        return res

    @classmethod
    def fetch_where(
        cls,
        db: Connection,
        condition: Conditional = Q.of(),
        orders: Mapping[Union[str, AliasedColumn], ORDER] = {},
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        lock: Optional[Any] = None,
    ) -&gt; list[Self]:
        &#34;&#34;&#34;
        Fetch records which satisfy the condition.

        ```python
        t.fetch_where(db, Q.eq(c1=1), dict(c2=True), 10, 5)
        # SQL: SELECT * FROM t WHERE c1 = 1 ORDER BY c2 ASC LIMIT 10 OFFSET 5
        ```

        Args:
            db: DB connection.
            condition: Query condition.
            orders: Ordering specification where key is column name and value denotes whether the order is ascending or not.
            limit: Maximum nuber of rows to fetch. If `None`, all rows are returned.
            offset: The number of rows to skip.
            lock: Locking statement.
        Returns:
            Model objects.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        rc, rp = ranged_by(limit, offset)
        s = cls.select()
        c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(order_by(orders))}{_spacer(rc)}{_spacer(lock)}&#34;, *(wp + rp))
        return [read_row(row, *s)[0] for row in c.fetchall()]

    @classmethod
    def fetch_one(
        cls,
        db: Connection,
        condition: Conditional = Q.of(),
        lock: Optional[Any] = None,
    ) -&gt; Optional[Self]:
        &#34;&#34;&#34;
        Fetch a record which satisfies the condition.

        `ValueError` raises When multiple records are found.
        Use this method for queries which certainly returns a single row, such as search by unique key.

        ```python
        t.fetch_one(db, Q.eq(c1=1))
        # SQL: SELECT * FROM t WHERE c1 = 1
        ```

        Args:
            db: DB connection.
            condition: Query condition.
            lock: Locking statement.
        Returns:
            Model objects If exists, otherwise `None`.
        &#34;&#34;&#34;
        rs = cls.fetch_where(db, condition, lock=lock)

        if not rs:
            return None
        elif len(rs) == 1:
            return rs[0]
        else:
            raise ValueError(f&#34;{len(rs)} records are found on the invocation of fetch_one().&#34;)

    @classmethod
    def _insert_sql(cls, record: Union[Self, dict[str, Any]], qualifier: Mapping[str, Qualifier] = {}) -&gt; tuple[str, list[str], list[Any]]:
        model: Self = cast(Self, record) if isinstance(record, cls) else cls(**cast(dict, record))
        value_dict = model_values(cls, model)
        check_columns(cls, value_dict)
        cols, vals = list(value_dict.keys()), list(value_dict.values())
        ordered_qs = key_to_index(qualifier, cols)

        def exp(v):
            return lambda i: v

        if any(isinstance(v, Expression) for v in vals):
            key_gen = []
            org_vals = vals
            vals = []
            for v in org_vals:
                if isinstance(v, Expression):
                    key_gen.append(exp(v))
                    vals.extend(v.params)
                else:
                    key_gen.append(lambda i: None)
                    vals.append(v)
            values_clause = values(key_gen, 1, ordered_qs)
        else:
            values_clause = values(len(cols), 1, ordered_qs)

        return f&#34;INSERT INTO {cls.name} ({&#39;, &#39;.join(cols)}) VALUES {values_clause}&#34;, cols, vals

    @classmethod
    def insert(
        cls,
        db: Connection,
        record: Union[Self, dict[str, Any]],
        qualifier: Mapping[str, Qualifier] = {},
        /,
        returning: bool = False,
    ) -&gt; Self:
        &#34;&#34;&#34;
        Insert a record.

        If `returning` is `True` and the DBMS supports **RETURNING** clause,
        returned model object contains comple and correct column values.
        Otherwise, auto incremental value is set to the returned model object
        but other column values generated inside DBMS such as default value are not set.

        ```python
        t.insert(db, dict(c1=1, c2=2))
        # SQL: INSERT INTO t (c1, c2) VALUES (1, 2)
        ```

        Args:
            db: DB connection.
            record: Object contains column values.
            qualifier: Functions qualifying placeholder markers.
            returning: Flag to return inserted record with complete and correct column values.
        Returns:
            Model of inserted record.
        &#34;&#34;&#34;
        model: Self = cast(Self, record) if isinstance(record, cls) else cls(**cast(dict, record))
        sql, _, vals = cls._insert_sql(record, qualifier)

        if returning:
            if cls.support_returning(db):
                c = db.stmt().execute(f&#34;{sql} RETURNING *&#34;, *vals)
                s = cls.select()
                return read_row(c.fetchone(), *s)[0]
            else:
                # REVIEW
                # Inserted row can&#39;t be specified from the table where no primary keys are defined .
                pass

        db.stmt().execute(sql, *vals)
        for c, v in cls.last_sequences(db, 1):
            setattr(model, c.name, v)
        return model

    @classmethod
    @overload
    def insert_many(cls, db: Connection, records: list[Union[Self, dict[str, Any]]], qualifier: Mapping[str, Qualifier] = {},
                    /, returning: Literal[False] = False) -&gt; list[Self]: ...
    @classmethod
    @overload
    def insert_many(cls, db: Connection, records: list[Union[Self, dict[str, Any]]], qualifier: Mapping[str, Qualifier] = {},
                    /, returning: Literal[True] = True) -&gt; list[Self]: ...
    @classmethod
    def insert_many(
        cls,
        db: Connection,
        records: list[Union[Self, dict[str, Any]]],
        qualifier: Mapping[str, Qualifier] = {},
        /,
        returning: bool = False,
    ):
        &#34;&#34;&#34;
        Insert records.

        If `returning` is `True` and the DBMS supports **RETURNING** clause,
        returned model object contains comple and correct column values.
        Otherwise, auto incremental value is set to the returned model object
        but other column values generated inside DBMS such as default value are not set.

        Args:
            db: DB connection.
            record: Object contains column values.
            qualifier: Functions qualifying placeholder markers.
            returning: Flag to return inserted records with complete and correct column values.
        Returns:
            Models of inserted records or cursor.
        &#34;&#34;&#34;
        if len(records) == 0:
            return []

        models: list[Self] = [cast(Self, r) if isinstance(r, cls) else cls(**cast(dict, r)) for r in records]

        seq_of_params = []

        sql, cols, params = cls._insert_sql(models[0], qualifier)

        cols = set(cols)
        seq_of_params.append(params)

        for m in models[1:]:
            value_dict = model_values(cls, m)
            check_columns(cls, value_dict, lambda c: c.name in cols, requires_all=True)
            # REVIEW:
            # The consistency among columns where expression is set is not checked.
            _, _, params = cls._insert_sql(m, qualifier)
            seq_of_params.append(params)

        db.stmt().executemany(sql, seq_of_params)
        num = len(records)
        for c, v in cls.last_sequences(db, num):
            for i, m in enumerate(models):
                setattr(m, c.name, v - (num - i - 1))

        if returning:
            seq_pks = [extract_pks(cls, m) for m in models]
            return cls.fetch_many(db, seq_pks)
        else:
            return models

    @classmethod
    def _update_sql(cls, record: Record, condition: Conditional, qualifier: Mapping[str, Qualifier] = {}, allow_all: bool = True) -&gt; tuple[str, list[str], list[Any]]:
        value_dict = model_values(cls, record, excludes_pk=True)
        check_columns(cls, value_dict)
        cols, vals = list(value_dict.keys()), list(value_dict.values())
        ordered_qs = key_to_index(qualifier, cols)

        def set_col(acc, icv):
            i, (c, v) = icv
            if isinstance(v, Expression):
                clause = f&#34;{c} = {ordered_qs.get(i, lambda x:x)(v.expression)}&#34;
                params = v.params
            else:
                clause = f&#34;{c} = {ordered_qs.get(i, lambda x:x)(&#39;$_&#39;)}&#34;
                params = [v]
            acc[0].append(clause)
            acc[1].extend(params)
            return acc

        setters, params = reduce(set_col, enumerate(zip(cols, vals)), ([], []))

        wc, wp = where(condition)
        if wc == &#34;&#34; and not allow_all:
            raise ValueError(&#34;Update query to update all records is not allowed.&#34;)

        return f&#34;UPDATE {cls.name} SET {&#39;, &#39;.join(setters)}{_spacer(wc)}&#34;, cols, params + wp

    @classmethod
    @overload
    def update(cls, db: Connection, pks: PKS, record: Record, qualifier: Mapping[str, Qualifier] = {},
               /, returning: Literal[False] = False) -&gt; bool: ...
    @classmethod
    @overload
    def update(cls, db: Connection, pks: PKS, record: Record, qualifier: Mapping[str, Qualifier] = {},
               /, returning: Literal[True] = True) -&gt; Optional[Self]: ...
    @classmethod
    def update(
        cls,
        db: Connection,
        pks: PKS,
        record: Record,
        qualifier: Mapping[str, Qualifier] = {},
        /,
        returning: bool = False,
    ):
        &#34;&#34;&#34;
        Update a record by primary key(s).

        This method only updates columns which are found in `record` except for primary key(s).

        ```python
        t.update(db, 1, dict(c1=1, c2=2))
        # SQL: UPDATE t SET c1 = 1, c2 = 2 WHERE id = 1
        ```

        Args:
            db: DB connection.
            pks: Primary key value(s).
            record: Object contains column values.
            qualifier: Functions qualifying placeholder markers.
            returning: Flag to return updated records with complete and correct column values.
        Returns:
            Whether the record exists and updated or updated record model.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)
        condition = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
        if returning:
            if cls.support_returning(db):
                models = cls.update_where(db, record, condition, qualifier, returning=True)
                return models[0] if models else None
            else:
                models = cls.update_where(db, record, condition, qualifier, returning=False)
                return cls.fetch(db, pks)
        else:
            return cls.update_where(db, record, condition, qualifier, returning=False) == 1

    @classmethod
    @overload
    def update_many(cls, db: Connection, records: Sequence[Record], qualifier: Mapping[str, Qualifier] = {},
               /, returning: Literal[False] = False) -&gt; int: ...
    @classmethod
    @overload
    def update_many(cls, db: Connection, records: Sequence[Record], qualifier: Mapping[str, Qualifier] = {},
               /, returning: Literal[True] = True) -&gt; list[Self]: ...
    @classmethod
    def update_many(
        cls,
        db: Connection,
        records: Sequence[Record],
        qualifier: Mapping[str, Qualifier] = {},
        /,
        returning: bool = False,
    ):
        &#34;&#34;&#34;
        Update records by set of primary key(s).

        This method invokes on `executemany` defined in DB-API 2.0.
        Whether it is optimized compared to `execute` depends on DB driver.

        Args:
            db: DB connection.
            record: Sequence of objects contains column values.
            qualifier: Functions qualifying placeholder markers.
            returning: Flag to return updated records with complete and correct column values.
        Returns:
            The number of affected rows or updated records.
        &#34;&#34;&#34;
        if len(records) == 0:
            return [] if returning else 0

        keys = {c.name for c in cls.columns if c.pk}
        if len(keys) == 0:
            raise ValueError(f&#34;update_many is not available because {cls} does not have primary key columns.&#34;)

        def classify(acc: tuple[dict[str, Any], dict[str, Any]], cv: tuple[str, Any]):
            if cv[0] in keys:
                acc[0][cv[0]] = cv[1]
            else:
                acc[1][cv[0]] = cv[1]
            return acc

        seq_of_values: list[tuple[dict[str, Any], dict[str, Any]]] = []
        target_columns: Optional[set[str]] = None

        for vs in [model_values(cls, r, excludes_pk=False) for r in records]:
            if not keys &lt; vs.keys():
                raise ValueError(f&#34;Every row must contain values of all primary keys and at least one update column value.&#34;)
            pks, rec = reduce(classify, vs.items(), ({}, {}))
            if target_columns is None:
                check_columns(cls, rec)
                target_columns = set(rec.keys())
            else:
                check_columns(cls, rec, lambda c: c.name in target_columns, True) # type: ignore
            seq_of_values.append((pks, rec))

        sql_first = &#34;&#34;
        seq_of_params: list[list[Any]] = []

        for pks, rec in seq_of_values:
            cols, vals = parse_pks(cls, pks)
            condition = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])

            sql, _, params = cls._update_sql(rec, condition, qualifier)
            if not sql_first:
                sql_first = sql
            seq_of_params.append(params)

        if returning:
            db.stmt().executemany(f&#34;{sql_first}&#34;, seq_of_params)
            return cls.fetch_many(db, [pks for pks, _ in seq_of_values])
        else:
            return db.stmt().executemany(sql_first, seq_of_params).rowcount

    @classmethod
    @overload
    def update_where(cls, db: Connection, record: Record, condition: Conditional, qualifier: Mapping[str, Qualifier] = {},
                     /, returning: Literal[False] = False, allow_all: bool = False) -&gt; int: ...
    @classmethod
    @overload
    def update_where(cls, db: Connection, record: Record, condition: Conditional, qualifier: Mapping[str, Qualifier] = {},
                     /, returning: Literal[True] = True, allow_all: bool = False) -&gt; list[Self]: ...
    @classmethod
    def update_where(
        cls,
        db: Connection,
        record: Record,
        condition: Conditional,
        qualifier: Mapping[str, Qualifier] = {},
        /,
        returning: bool = False,
        allow_all: bool = True,
    ):
        &#34;&#34;&#34;
        Update records which satisfy the condition.

        ```python
        t.update(db, dict(c2=2), Q.eq(c1=1))
        # SQL: UPDATE t SET c2 = 2 WHERE c1 = 1
        ```

        Args:
            db: DB connection.
            record: Object contains column values.
            condition: Query condition.
            qualifier: Functions qualifying placeholder markers.
            returning: Flag to return updated records with complete and correct column values.
            allow_all: If `False`, empty condition raises `ValueError`.
        Returns:
            The number of affected rows or updated records.
        &#34;&#34;&#34;
        sql, _, params = cls._update_sql(record, condition, qualifier, allow_all)

        if returning:
            if cls.support_returning(db):
                c = db.stmt().execute(f&#34;{sql} RETURNING *&#34;, *params)
                s = cls.select()
                return [read_row(row, *s)[0] for row in c.fetchall()]
            else:
                raise NotImplementedError(f&#34;RETURNING is not supported and there is no way to fetch updated rows exactly.&#34;)
        else:
            c = db.stmt().execute(sql, *params)

            return c.rowcount

    @classmethod
    @overload
    def delete(cls, db: Connection, pks: PKS, /, returning: Literal[False] = False) -&gt; bool: ...
    @classmethod
    @overload
    def delete(cls, db: Connection, pks: PKS, /, returning: Literal[True] = True) -&gt; Optional[Self]: ...
    @classmethod
    def delete(cls, db: Connection, pks: PKS, /, returning: bool = False):
        &#34;&#34;&#34;
        Delete a record by primary key(s).

        ```python
        t.delete(db, 1)
        # SQL: DELETE FROM t WHERE id = 1
        ```

        Args:
            db: DB connection.
            pks: Primary key value(s).
            returning: Flag to return deleted record if any.
        Returns:
            Whether the record exists and deleted or delete record if any.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)

        if returning:
            models = cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)]), returning=True)
            return models[0] if models else None
        else:
            return cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])) == 1

    @classmethod
    @overload
    def delete_many(cls, db: Connection, pks: Union[Sequence[PKS], Sequence[Record]], /, returning: Literal[False] = False) -&gt; int: ...
    @overload
    @classmethod
    def delete_many(cls, db: Connection, pks: Union[Sequence[PKS], Sequence[Record]], /, returning: Literal[True] = True) -&gt; list[Self]: ...
    @classmethod
    def delete_many(cls, db: Connection, pks: Union[Sequence[PKS], Sequence[Record]], /, returning: bool = False):
        &#34;&#34;&#34;
        Delete a records by set of primary key(s).

        This method invokes on `executemany` defined in DB-API 2.0.
        Whether it is optimized compared to `execute` depends on DB driver.

        Args:
            db: DB connection.
            pks: Primary keys or objects each of which contains values of all primary keys.
            returning: Flag to return deleted records.
        Returns:
            The number of affected rows or deleted records.
        &#34;&#34;&#34;
        if len(pks) == 0:
            return None

        seq_of_pks: list[dict[str, Any]] = []
        for rec in pks:
            if isinstance(rec, (dict, cls)):
                seq_of_pks.append(extract_pks(cls, rec))
            else:
                cols, vals = parse_pks(cls, rec)
                seq_of_pks.append(dict(zip(cols, vals)))

        condition = Conditional.all([Q.eq(**{c: v}) for c, v in seq_of_pks[0].items()])
        wc, wp = where(condition)

        sql = f&#34;DELETE FROM {cls.name}{_spacer(wc)}&#34;
        seq_of_params: list[list[Any]] = [wp]

        for v in seq_of_pks[1:]:
            condition = Conditional.all([Q.eq(**{c: v}) for c, v in v.items()])
            _, wp = where(condition)
            seq_of_params.append(wp)

        if returning:
            models = cls.fetch_many(db, seq_of_pks)
            db.stmt().executemany(sql, seq_of_params)
            return models
        else:
            return db.stmt().executemany(sql, seq_of_params).rowcount

    @classmethod
    @overload
    def delete_where(cls, db: Connection, condition: Conditional, /, returning: Literal[False] = False, allow_all: bool = True) -&gt; int: ...
    @classmethod
    @overload
    def delete_where(cls, db: Connection, condition: Conditional, /, returning: Literal[True] = True, allow_all: bool = True) -&gt; list[Self]: ...
    @classmethod
    def delete_where(cls, db: Connection, condition: Conditional, /, returning: bool = False, allow_all: bool = True):
        &#34;&#34;&#34;
        Delete records which satisfy the condition.

        ```python
        t.delete(db, Q.eq(c1=1))
        # SQL: DELETE FROM t WHERE c1 = 1
        ```

        Args:
            db: DB connection.
            condition: Query condition.
            returning: Flag to return deleted records.
            allow_all: If `False`, empty condition raises `ValueError`.
        Returns:
            The number of affected rows or deleted records.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        if wc == &#34;&#34; and not allow_all:
            raise ValueError(&#34;Delete query to delete all records is not allowed.&#34;)

        sql = f&#34;DELETE FROM {cls.name}{_spacer(wc)}&#34;

        if returning:
            if cls.support_returning(db):
                c = db.stmt().execute(f&#34;{sql} RETURNING *&#34;, *wp)
                return [read_row(row, *cls.select())[0] for row in c.fetchall()]
            else:
                current = cls.fetch_where(db, condition)
                c = db.stmt().execute(sql, *wp)
                return current
        else:
            return db.stmt().execute(sql, *wp).rowcount

    @classmethod
    def last_sequences(cls, db: Connection, num: int) -&gt; list[tuple[Column, int]]:
        &#34;&#34;&#34;
        Returns the sequential (auto incremental) values of a table generated by the latest insertion.

        Result contains every sequential columns and their values.
        When the latest query inserts multiple rows, only the last (= biggest) value is returned.

        This method should be overridden by another mixin class defined in dialect module.

        Args:
            db: DB connection.
            num: The number of records inserted by the latest query.
        Returns:
            List of pairs of column and its values.
        &#34;&#34;&#34;
        return []

    @classmethod
    def support_returning(cls, db: Connection) -&gt; bool:
        &#34;&#34;&#34;
        Checks whehter this DBMS support **RETURNING** clause or not.

        Args:
            db: DB connection.
        Returns:
            Whehter this DBMS support **RETURNING** clause or not.
        &#34;&#34;&#34;
        return False


def _spacer(s):
    return (&#34; &#34; + str(s)) if s else &#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyracmon.mixin.CRUDInternalMeta"><code class="flex name class">
<span>class <span class="ident">CRUDInternalMeta</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CRUDInternalMeta(Meta):
    @classmethod
    def last_sequences(cls, db: Connection, num: int) -&gt; list[tuple[Column, int]]: ...

    @classmethod
    def support_returning(cls, db: Connection) -&gt; bool: ...</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.dialect.shared.MultiInsertMixin" href="dialect/shared.html#pyracmon.dialect.shared.MultiInsertMixin">MultiInsertMixin</a></li>
<li><a title="pyracmon.mixin.CRUDMixin" href="#pyracmon.mixin.CRUDMixin">CRUDMixin</a></li>
</ul>
</dd>
<dt id="pyracmon.mixin.CRUDMixin"><code class="flex name class">
<span>class <span class="ident">CRUDMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Default mixin providing class methods available on all model types.</p>
<p>Every method takes the DB connection object as its first argument.
Following arguments are defined in several methods commonly.</p>
<ul>
<li><code>pks</code><ul>
<li>Names and values of all primary key columns in form of <code>dict</code> .</li>
<li>A primary key value. This form is allowed when the table has just one primary key column.</li>
<li>e.g. If the table has a single primary key <code>id</code> of int, <code>1</code> is available to spcecify the row of <code>id = 1</code> .</li>
<li>e.g. If the table has multiple primary keys <code>intid</code> and <code>strid</code>, <code>dict(intid=1, strid="abc")</code> is a valid argument.</li>
</ul>
</li>
<li><code>record</code><ul>
<li>A model object or a mapping from column name to its value, which corresponds to a table row.</li>
<li>Only columns contained in the record is affected by the operation.</li>
<li>e.g. When <code>dict(c1=1, c2="abc")</code> is passed for insertion, only <code>c1</code> and <code>c2</code> are set in INSERT query.</li>
<li>e.g. For update, only the columns will be updated. Other columns are not affected.</li>
</ul>
</li>
<li><code>condition</code><ul>
<li>Query condition which will compose WHERE clause.</li>
<li><code><a title="pyracmon.query.Q" href="query.html#pyracmon.query.Q">Q</a></code> is a factory class to create condition object.</li>
<li>When <code>None</code> is passed, all rows are subject to the operation.</li>
</ul>
</li>
<li><code>qualifier</code><ul>
<li>A mapping from column name to a function which qualifies a placeholder passed by an argument.</li>
<li>Detail of qualifier function is described below.</li>
</ul>
</li>
<li><code>lock</code><ul>
<li>This is reserved argument for locking statement but works just as the postfix of the query currently.</li>
<li>The usage will be changed in future version.</li>
</ul>
</li>
</ul>
<p>Qualifier function is used typically to convert or replace placeholder marker in insert/update query.
By default, those queries contain markers like <code>insert into t (c1, c2) values (?, ?)</code> (<code>Q</code> parameter style).
We need sometimes qualify markers to apply DB function, calculation, type cast and so on. This feature enables them like below.</p>
<pre><code class="language-python">t.insert(db, dict(c1=1, c2=None), dict(c1=lambda x: f&quot;{x}+1&quot;, c2=lambda x: &quot;now()&quot;))
# SQL: INSERT INTO t (c1, c2) VALUES (?+1, now())
</code></pre>
<p>Be aware that when model object is passed, its column values may differ from actual values in DB after query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CRUDMixin(SelectMixin, CRUDInternalMeta):
    &#34;&#34;&#34;
    Default mixin providing class methods available on all model types.

    Every method takes the DB connection object as its first argument.
    Following arguments are defined in several methods commonly.

    - `pks`
        - Names and values of all primary key columns in form of `dict` .
        - A primary key value. This form is allowed when the table has just one primary key column.
        - e.g. If the table has a single primary key `id` of int, `1` is available to spcecify the row of `id = 1` .
        - e.g. If the table has multiple primary keys `intid` and `strid`, `dict(intid=1, strid=&#34;abc&#34;)` is a valid argument.
    - `record`
        - A model object or a mapping from column name to its value, which corresponds to a table row.
        - Only columns contained in the record is affected by the operation.
        - e.g. When `dict(c1=1, c2=&#34;abc&#34;)` is passed for insertion, only `c1` and `c2` are set in INSERT query.
        - e.g. For update, only the columns will be updated. Other columns are not affected.
    - `condition`
        - Query condition which will compose WHERE clause.
        - `pyracmon.query.Q` is a factory class to create condition object.
        - When `None` is passed, all rows are subject to the operation.
    - `qualifier`
        - A mapping from column name to a function which qualifies a placeholder passed by an argument.
        - Detail of qualifier function is described below.
    - `lock`
        - This is reserved argument for locking statement but works just as the postfix of the query currently.
        - The usage will be changed in future version.

    Qualifier function is used typically to convert or replace placeholder marker in insert/update query.
    By default, those queries contain markers like `insert into t (c1, c2) values (?, ?)` (`Q` parameter style).
    We need sometimes qualify markers to apply DB function, calculation, type cast and so on. This feature enables them like below.

    ```python
    t.insert(db, dict(c1=1, c2=None), dict(c1=lambda x: f&#34;{x}+1&#34;, c2=lambda x: &#34;now()&#34;))
    # SQL: INSERT INTO t (c1, c2) VALUES (?+1, now())
    ```

    Be aware that when model object is passed, its column values may differ from actual values in DB after query.
    &#34;&#34;&#34;
    @classmethod
    def count(cls, db: Connection, condition: Conditional = Q.of()) -&gt; int:
        &#34;&#34;&#34;
        Count rows which satisfies the condition.

        ```python
        t.count(db, Q.eq(c1=1))
        # SQL: SELECT COUNT(*) FROM t WHERE c1 = 1
        ```

        Args:
            db: DB connection.
            condition: Query condition.
        Returns:
            The number of rows.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        c = db.stmt().execute(f&#34;SELECT COUNT(*) FROM {cls.name}{_spacer(wc)}&#34;, *wp)
        return c.fetchone()[0] # type: ignore

    @classmethod
    def fetch(cls, db: Connection, pks: PKS, lock: Optional[Any] = None) -&gt; Optional[Self]:
        &#34;&#34;&#34;
        Fetch a record by primary key(s).

        ```python
        t.fetch(db, 1)
        # SQL: SELECT * FROM t WHERE id = 1
        ```

        Args:
            db: DB connection.
            pks: Primary key value(s).
            lock: Locking statement.
        Returns:
            A model object if exists, otherwise `None`.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)
        cond = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
        wc, wp = where(cond)
        s = cls.select()
        c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}&#34;, *wp)
        row = c.fetchone()
        return read_row(row, *s)[0] if row else None

    @classmethod
    def fetch_many(cls, db: Connection, seq_pks: Sequence[PKS], lock: Optional[Any] = None, /, per_page: int = 1000) -&gt; list[Self]:
        &#34;&#34;&#34;
        Fetch a record by sequence of primary key(s).

        This method simply concatenates equality conditions on primary key by OR operator.

        ```python
        t.fetch_many(db, [1, 2, 3])
        # SQL: SELECT * FROM t WHERE id = 1 OR id = 2 OR id = 3
        ```

        Args:
            db: DB connection.
            seq_pks: Sequence of primary key value.
            lock: Locking statement.
            per_page: Maximum number of keys for an execution of query.
        Returns:
            Model objects in the same order as passed sequence.
        &#34;&#34;&#34;
        res = []
        index = 0
        while index &lt; len(seq_pks):
            ordered_pks = []
            cond = Q.of()
            for pks in seq_pks[index:index+per_page]:
                cols, vals = parse_pks(cls, pks)
                ordered_pks.append(tuple(v for v in vals))
                cond |= Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
            wc, wp = where(cond)
            s = cls.select()
            c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}&#34;, *wp)

            record_map = {}
            for r in [read_row(row, *s)[0] for row in c.fetchall()]:
                pk_values = {c.name:v for c, v in r if c.pk}
                record_map[tuple([v for _, v in check_columns(cls, pk_values, lambda c: c.pk, True)])] = r

            res.extend([record_map[k] for k in ordered_pks if k in record_map])
            index += per_page

        return res

    @classmethod
    def fetch_where(
        cls,
        db: Connection,
        condition: Conditional = Q.of(),
        orders: Mapping[Union[str, AliasedColumn], ORDER] = {},
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        lock: Optional[Any] = None,
    ) -&gt; list[Self]:
        &#34;&#34;&#34;
        Fetch records which satisfy the condition.

        ```python
        t.fetch_where(db, Q.eq(c1=1), dict(c2=True), 10, 5)
        # SQL: SELECT * FROM t WHERE c1 = 1 ORDER BY c2 ASC LIMIT 10 OFFSET 5
        ```

        Args:
            db: DB connection.
            condition: Query condition.
            orders: Ordering specification where key is column name and value denotes whether the order is ascending or not.
            limit: Maximum nuber of rows to fetch. If `None`, all rows are returned.
            offset: The number of rows to skip.
            lock: Locking statement.
        Returns:
            Model objects.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        rc, rp = ranged_by(limit, offset)
        s = cls.select()
        c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(order_by(orders))}{_spacer(rc)}{_spacer(lock)}&#34;, *(wp + rp))
        return [read_row(row, *s)[0] for row in c.fetchall()]

    @classmethod
    def fetch_one(
        cls,
        db: Connection,
        condition: Conditional = Q.of(),
        lock: Optional[Any] = None,
    ) -&gt; Optional[Self]:
        &#34;&#34;&#34;
        Fetch a record which satisfies the condition.

        `ValueError` raises When multiple records are found.
        Use this method for queries which certainly returns a single row, such as search by unique key.

        ```python
        t.fetch_one(db, Q.eq(c1=1))
        # SQL: SELECT * FROM t WHERE c1 = 1
        ```

        Args:
            db: DB connection.
            condition: Query condition.
            lock: Locking statement.
        Returns:
            Model objects If exists, otherwise `None`.
        &#34;&#34;&#34;
        rs = cls.fetch_where(db, condition, lock=lock)

        if not rs:
            return None
        elif len(rs) == 1:
            return rs[0]
        else:
            raise ValueError(f&#34;{len(rs)} records are found on the invocation of fetch_one().&#34;)

    @classmethod
    def _insert_sql(cls, record: Union[Self, dict[str, Any]], qualifier: Mapping[str, Qualifier] = {}) -&gt; tuple[str, list[str], list[Any]]:
        model: Self = cast(Self, record) if isinstance(record, cls) else cls(**cast(dict, record))
        value_dict = model_values(cls, model)
        check_columns(cls, value_dict)
        cols, vals = list(value_dict.keys()), list(value_dict.values())
        ordered_qs = key_to_index(qualifier, cols)

        def exp(v):
            return lambda i: v

        if any(isinstance(v, Expression) for v in vals):
            key_gen = []
            org_vals = vals
            vals = []
            for v in org_vals:
                if isinstance(v, Expression):
                    key_gen.append(exp(v))
                    vals.extend(v.params)
                else:
                    key_gen.append(lambda i: None)
                    vals.append(v)
            values_clause = values(key_gen, 1, ordered_qs)
        else:
            values_clause = values(len(cols), 1, ordered_qs)

        return f&#34;INSERT INTO {cls.name} ({&#39;, &#39;.join(cols)}) VALUES {values_clause}&#34;, cols, vals

    @classmethod
    def insert(
        cls,
        db: Connection,
        record: Union[Self, dict[str, Any]],
        qualifier: Mapping[str, Qualifier] = {},
        /,
        returning: bool = False,
    ) -&gt; Self:
        &#34;&#34;&#34;
        Insert a record.

        If `returning` is `True` and the DBMS supports **RETURNING** clause,
        returned model object contains comple and correct column values.
        Otherwise, auto incremental value is set to the returned model object
        but other column values generated inside DBMS such as default value are not set.

        ```python
        t.insert(db, dict(c1=1, c2=2))
        # SQL: INSERT INTO t (c1, c2) VALUES (1, 2)
        ```

        Args:
            db: DB connection.
            record: Object contains column values.
            qualifier: Functions qualifying placeholder markers.
            returning: Flag to return inserted record with complete and correct column values.
        Returns:
            Model of inserted record.
        &#34;&#34;&#34;
        model: Self = cast(Self, record) if isinstance(record, cls) else cls(**cast(dict, record))
        sql, _, vals = cls._insert_sql(record, qualifier)

        if returning:
            if cls.support_returning(db):
                c = db.stmt().execute(f&#34;{sql} RETURNING *&#34;, *vals)
                s = cls.select()
                return read_row(c.fetchone(), *s)[0]
            else:
                # REVIEW
                # Inserted row can&#39;t be specified from the table where no primary keys are defined .
                pass

        db.stmt().execute(sql, *vals)
        for c, v in cls.last_sequences(db, 1):
            setattr(model, c.name, v)
        return model

    @classmethod
    @overload
    def insert_many(cls, db: Connection, records: list[Union[Self, dict[str, Any]]], qualifier: Mapping[str, Qualifier] = {},
                    /, returning: Literal[False] = False) -&gt; list[Self]: ...
    @classmethod
    @overload
    def insert_many(cls, db: Connection, records: list[Union[Self, dict[str, Any]]], qualifier: Mapping[str, Qualifier] = {},
                    /, returning: Literal[True] = True) -&gt; list[Self]: ...
    @classmethod
    def insert_many(
        cls,
        db: Connection,
        records: list[Union[Self, dict[str, Any]]],
        qualifier: Mapping[str, Qualifier] = {},
        /,
        returning: bool = False,
    ):
        &#34;&#34;&#34;
        Insert records.

        If `returning` is `True` and the DBMS supports **RETURNING** clause,
        returned model object contains comple and correct column values.
        Otherwise, auto incremental value is set to the returned model object
        but other column values generated inside DBMS such as default value are not set.

        Args:
            db: DB connection.
            record: Object contains column values.
            qualifier: Functions qualifying placeholder markers.
            returning: Flag to return inserted records with complete and correct column values.
        Returns:
            Models of inserted records or cursor.
        &#34;&#34;&#34;
        if len(records) == 0:
            return []

        models: list[Self] = [cast(Self, r) if isinstance(r, cls) else cls(**cast(dict, r)) for r in records]

        seq_of_params = []

        sql, cols, params = cls._insert_sql(models[0], qualifier)

        cols = set(cols)
        seq_of_params.append(params)

        for m in models[1:]:
            value_dict = model_values(cls, m)
            check_columns(cls, value_dict, lambda c: c.name in cols, requires_all=True)
            # REVIEW:
            # The consistency among columns where expression is set is not checked.
            _, _, params = cls._insert_sql(m, qualifier)
            seq_of_params.append(params)

        db.stmt().executemany(sql, seq_of_params)
        num = len(records)
        for c, v in cls.last_sequences(db, num):
            for i, m in enumerate(models):
                setattr(m, c.name, v - (num - i - 1))

        if returning:
            seq_pks = [extract_pks(cls, m) for m in models]
            return cls.fetch_many(db, seq_pks)
        else:
            return models

    @classmethod
    def _update_sql(cls, record: Record, condition: Conditional, qualifier: Mapping[str, Qualifier] = {}, allow_all: bool = True) -&gt; tuple[str, list[str], list[Any]]:
        value_dict = model_values(cls, record, excludes_pk=True)
        check_columns(cls, value_dict)
        cols, vals = list(value_dict.keys()), list(value_dict.values())
        ordered_qs = key_to_index(qualifier, cols)

        def set_col(acc, icv):
            i, (c, v) = icv
            if isinstance(v, Expression):
                clause = f&#34;{c} = {ordered_qs.get(i, lambda x:x)(v.expression)}&#34;
                params = v.params
            else:
                clause = f&#34;{c} = {ordered_qs.get(i, lambda x:x)(&#39;$_&#39;)}&#34;
                params = [v]
            acc[0].append(clause)
            acc[1].extend(params)
            return acc

        setters, params = reduce(set_col, enumerate(zip(cols, vals)), ([], []))

        wc, wp = where(condition)
        if wc == &#34;&#34; and not allow_all:
            raise ValueError(&#34;Update query to update all records is not allowed.&#34;)

        return f&#34;UPDATE {cls.name} SET {&#39;, &#39;.join(setters)}{_spacer(wc)}&#34;, cols, params + wp

    @classmethod
    @overload
    def update(cls, db: Connection, pks: PKS, record: Record, qualifier: Mapping[str, Qualifier] = {},
               /, returning: Literal[False] = False) -&gt; bool: ...
    @classmethod
    @overload
    def update(cls, db: Connection, pks: PKS, record: Record, qualifier: Mapping[str, Qualifier] = {},
               /, returning: Literal[True] = True) -&gt; Optional[Self]: ...
    @classmethod
    def update(
        cls,
        db: Connection,
        pks: PKS,
        record: Record,
        qualifier: Mapping[str, Qualifier] = {},
        /,
        returning: bool = False,
    ):
        &#34;&#34;&#34;
        Update a record by primary key(s).

        This method only updates columns which are found in `record` except for primary key(s).

        ```python
        t.update(db, 1, dict(c1=1, c2=2))
        # SQL: UPDATE t SET c1 = 1, c2 = 2 WHERE id = 1
        ```

        Args:
            db: DB connection.
            pks: Primary key value(s).
            record: Object contains column values.
            qualifier: Functions qualifying placeholder markers.
            returning: Flag to return updated records with complete and correct column values.
        Returns:
            Whether the record exists and updated or updated record model.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)
        condition = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
        if returning:
            if cls.support_returning(db):
                models = cls.update_where(db, record, condition, qualifier, returning=True)
                return models[0] if models else None
            else:
                models = cls.update_where(db, record, condition, qualifier, returning=False)
                return cls.fetch(db, pks)
        else:
            return cls.update_where(db, record, condition, qualifier, returning=False) == 1

    @classmethod
    @overload
    def update_many(cls, db: Connection, records: Sequence[Record], qualifier: Mapping[str, Qualifier] = {},
               /, returning: Literal[False] = False) -&gt; int: ...
    @classmethod
    @overload
    def update_many(cls, db: Connection, records: Sequence[Record], qualifier: Mapping[str, Qualifier] = {},
               /, returning: Literal[True] = True) -&gt; list[Self]: ...
    @classmethod
    def update_many(
        cls,
        db: Connection,
        records: Sequence[Record],
        qualifier: Mapping[str, Qualifier] = {},
        /,
        returning: bool = False,
    ):
        &#34;&#34;&#34;
        Update records by set of primary key(s).

        This method invokes on `executemany` defined in DB-API 2.0.
        Whether it is optimized compared to `execute` depends on DB driver.

        Args:
            db: DB connection.
            record: Sequence of objects contains column values.
            qualifier: Functions qualifying placeholder markers.
            returning: Flag to return updated records with complete and correct column values.
        Returns:
            The number of affected rows or updated records.
        &#34;&#34;&#34;
        if len(records) == 0:
            return [] if returning else 0

        keys = {c.name for c in cls.columns if c.pk}
        if len(keys) == 0:
            raise ValueError(f&#34;update_many is not available because {cls} does not have primary key columns.&#34;)

        def classify(acc: tuple[dict[str, Any], dict[str, Any]], cv: tuple[str, Any]):
            if cv[0] in keys:
                acc[0][cv[0]] = cv[1]
            else:
                acc[1][cv[0]] = cv[1]
            return acc

        seq_of_values: list[tuple[dict[str, Any], dict[str, Any]]] = []
        target_columns: Optional[set[str]] = None

        for vs in [model_values(cls, r, excludes_pk=False) for r in records]:
            if not keys &lt; vs.keys():
                raise ValueError(f&#34;Every row must contain values of all primary keys and at least one update column value.&#34;)
            pks, rec = reduce(classify, vs.items(), ({}, {}))
            if target_columns is None:
                check_columns(cls, rec)
                target_columns = set(rec.keys())
            else:
                check_columns(cls, rec, lambda c: c.name in target_columns, True) # type: ignore
            seq_of_values.append((pks, rec))

        sql_first = &#34;&#34;
        seq_of_params: list[list[Any]] = []

        for pks, rec in seq_of_values:
            cols, vals = parse_pks(cls, pks)
            condition = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])

            sql, _, params = cls._update_sql(rec, condition, qualifier)
            if not sql_first:
                sql_first = sql
            seq_of_params.append(params)

        if returning:
            db.stmt().executemany(f&#34;{sql_first}&#34;, seq_of_params)
            return cls.fetch_many(db, [pks for pks, _ in seq_of_values])
        else:
            return db.stmt().executemany(sql_first, seq_of_params).rowcount

    @classmethod
    @overload
    def update_where(cls, db: Connection, record: Record, condition: Conditional, qualifier: Mapping[str, Qualifier] = {},
                     /, returning: Literal[False] = False, allow_all: bool = False) -&gt; int: ...
    @classmethod
    @overload
    def update_where(cls, db: Connection, record: Record, condition: Conditional, qualifier: Mapping[str, Qualifier] = {},
                     /, returning: Literal[True] = True, allow_all: bool = False) -&gt; list[Self]: ...
    @classmethod
    def update_where(
        cls,
        db: Connection,
        record: Record,
        condition: Conditional,
        qualifier: Mapping[str, Qualifier] = {},
        /,
        returning: bool = False,
        allow_all: bool = True,
    ):
        &#34;&#34;&#34;
        Update records which satisfy the condition.

        ```python
        t.update(db, dict(c2=2), Q.eq(c1=1))
        # SQL: UPDATE t SET c2 = 2 WHERE c1 = 1
        ```

        Args:
            db: DB connection.
            record: Object contains column values.
            condition: Query condition.
            qualifier: Functions qualifying placeholder markers.
            returning: Flag to return updated records with complete and correct column values.
            allow_all: If `False`, empty condition raises `ValueError`.
        Returns:
            The number of affected rows or updated records.
        &#34;&#34;&#34;
        sql, _, params = cls._update_sql(record, condition, qualifier, allow_all)

        if returning:
            if cls.support_returning(db):
                c = db.stmt().execute(f&#34;{sql} RETURNING *&#34;, *params)
                s = cls.select()
                return [read_row(row, *s)[0] for row in c.fetchall()]
            else:
                raise NotImplementedError(f&#34;RETURNING is not supported and there is no way to fetch updated rows exactly.&#34;)
        else:
            c = db.stmt().execute(sql, *params)

            return c.rowcount

    @classmethod
    @overload
    def delete(cls, db: Connection, pks: PKS, /, returning: Literal[False] = False) -&gt; bool: ...
    @classmethod
    @overload
    def delete(cls, db: Connection, pks: PKS, /, returning: Literal[True] = True) -&gt; Optional[Self]: ...
    @classmethod
    def delete(cls, db: Connection, pks: PKS, /, returning: bool = False):
        &#34;&#34;&#34;
        Delete a record by primary key(s).

        ```python
        t.delete(db, 1)
        # SQL: DELETE FROM t WHERE id = 1
        ```

        Args:
            db: DB connection.
            pks: Primary key value(s).
            returning: Flag to return deleted record if any.
        Returns:
            Whether the record exists and deleted or delete record if any.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)

        if returning:
            models = cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)]), returning=True)
            return models[0] if models else None
        else:
            return cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])) == 1

    @classmethod
    @overload
    def delete_many(cls, db: Connection, pks: Union[Sequence[PKS], Sequence[Record]], /, returning: Literal[False] = False) -&gt; int: ...
    @overload
    @classmethod
    def delete_many(cls, db: Connection, pks: Union[Sequence[PKS], Sequence[Record]], /, returning: Literal[True] = True) -&gt; list[Self]: ...
    @classmethod
    def delete_many(cls, db: Connection, pks: Union[Sequence[PKS], Sequence[Record]], /, returning: bool = False):
        &#34;&#34;&#34;
        Delete a records by set of primary key(s).

        This method invokes on `executemany` defined in DB-API 2.0.
        Whether it is optimized compared to `execute` depends on DB driver.

        Args:
            db: DB connection.
            pks: Primary keys or objects each of which contains values of all primary keys.
            returning: Flag to return deleted records.
        Returns:
            The number of affected rows or deleted records.
        &#34;&#34;&#34;
        if len(pks) == 0:
            return None

        seq_of_pks: list[dict[str, Any]] = []
        for rec in pks:
            if isinstance(rec, (dict, cls)):
                seq_of_pks.append(extract_pks(cls, rec))
            else:
                cols, vals = parse_pks(cls, rec)
                seq_of_pks.append(dict(zip(cols, vals)))

        condition = Conditional.all([Q.eq(**{c: v}) for c, v in seq_of_pks[0].items()])
        wc, wp = where(condition)

        sql = f&#34;DELETE FROM {cls.name}{_spacer(wc)}&#34;
        seq_of_params: list[list[Any]] = [wp]

        for v in seq_of_pks[1:]:
            condition = Conditional.all([Q.eq(**{c: v}) for c, v in v.items()])
            _, wp = where(condition)
            seq_of_params.append(wp)

        if returning:
            models = cls.fetch_many(db, seq_of_pks)
            db.stmt().executemany(sql, seq_of_params)
            return models
        else:
            return db.stmt().executemany(sql, seq_of_params).rowcount

    @classmethod
    @overload
    def delete_where(cls, db: Connection, condition: Conditional, /, returning: Literal[False] = False, allow_all: bool = True) -&gt; int: ...
    @classmethod
    @overload
    def delete_where(cls, db: Connection, condition: Conditional, /, returning: Literal[True] = True, allow_all: bool = True) -&gt; list[Self]: ...
    @classmethod
    def delete_where(cls, db: Connection, condition: Conditional, /, returning: bool = False, allow_all: bool = True):
        &#34;&#34;&#34;
        Delete records which satisfy the condition.

        ```python
        t.delete(db, Q.eq(c1=1))
        # SQL: DELETE FROM t WHERE c1 = 1
        ```

        Args:
            db: DB connection.
            condition: Query condition.
            returning: Flag to return deleted records.
            allow_all: If `False`, empty condition raises `ValueError`.
        Returns:
            The number of affected rows or deleted records.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        if wc == &#34;&#34; and not allow_all:
            raise ValueError(&#34;Delete query to delete all records is not allowed.&#34;)

        sql = f&#34;DELETE FROM {cls.name}{_spacer(wc)}&#34;

        if returning:
            if cls.support_returning(db):
                c = db.stmt().execute(f&#34;{sql} RETURNING *&#34;, *wp)
                return [read_row(row, *cls.select())[0] for row in c.fetchall()]
            else:
                current = cls.fetch_where(db, condition)
                c = db.stmt().execute(sql, *wp)
                return current
        else:
            return db.stmt().execute(sql, *wp).rowcount

    @classmethod
    def last_sequences(cls, db: Connection, num: int) -&gt; list[tuple[Column, int]]:
        &#34;&#34;&#34;
        Returns the sequential (auto incremental) values of a table generated by the latest insertion.

        Result contains every sequential columns and their values.
        When the latest query inserts multiple rows, only the last (= biggest) value is returned.

        This method should be overridden by another mixin class defined in dialect module.

        Args:
            db: DB connection.
            num: The number of records inserted by the latest query.
        Returns:
            List of pairs of column and its values.
        &#34;&#34;&#34;
        return []

    @classmethod
    def support_returning(cls, db: Connection) -&gt; bool:
        &#34;&#34;&#34;
        Checks whehter this DBMS support **RETURNING** clause or not.

        Args:
            db: DB connection.
        Returns:
            Whehter this DBMS support **RETURNING** clause or not.
        &#34;&#34;&#34;
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.select.SelectMixin" href="select.html#pyracmon.select.SelectMixin">SelectMixin</a></li>
<li><a title="pyracmon.mixin.CRUDInternalMeta" href="#pyracmon.mixin.CRUDInternalMeta">CRUDInternalMeta</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.mixin.CRUDMixin.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>db:<a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition:<a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a>=Condition: '' -- []) >int</span>
</code></dt>
<dd>
<div class="desc"><p>Count rows which satisfies the condition.</p>
<pre><code class="language-python">t.count(db, Q.eq(c1=1))
# SQL: SELECT COUNT(*) FROM t WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of rows.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def count(cls, db: Connection, condition: Conditional = Q.of()) -&gt; int:
    &#34;&#34;&#34;
    Count rows which satisfies the condition.

    ```python
    t.count(db, Q.eq(c1=1))
    # SQL: SELECT COUNT(*) FROM t WHERE c1 = 1
    ```

    Args:
        db: DB connection.
        condition: Query condition.
    Returns:
        The number of rows.
    &#34;&#34;&#34;
    wc, wp = where(condition)
    c = db.stmt().execute(f&#34;SELECT COUNT(*) FROM {cls.name}{_spacer(wc)}&#34;, *wp)
    return c.fetchone()[0] # type: ignore</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>db:<a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, pks:Union[Any,dict[str,Any]], /, returning:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a record by primary key(s).</p>
<pre><code class="language-python">t.delete(db, 1)
# SQL: DELETE FROM t WHERE id = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>pks</code></strong></dt>
<dd>Primary key value(s).</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return deleted record if any.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the record exists and deleted or delete record if any.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete(cls, db: Connection, pks: PKS, /, returning: bool = False):
    &#34;&#34;&#34;
    Delete a record by primary key(s).

    ```python
    t.delete(db, 1)
    # SQL: DELETE FROM t WHERE id = 1
    ```

    Args:
        db: DB connection.
        pks: Primary key value(s).
        returning: Flag to return deleted record if any.
    Returns:
        Whether the record exists and deleted or delete record if any.
    &#34;&#34;&#34;
    cols, vals = parse_pks(cls, pks)

    if returning:
        models = cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)]), returning=True)
        return models[0] if models else None
    else:
        return cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])) == 1</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.delete_many"><code class="name flex">
<span>def <span class="ident">delete_many</span></span>(<span>db:<a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, pks:Union[collections.abc.Sequence[Union[Any,dict[str,Any]]],collections.abc.Sequence[Union[<a title="pyracmon.model.Meta" href="model.html#pyracmon.model.Meta">Meta</a>,dict[str,Any]]]], /, returning:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a records by set of primary key(s).</p>
<p>This method invokes on <code>executemany</code> defined in DB-API 2.0.
Whether it is optimized compared to <code>execute</code> depends on DB driver.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>pks</code></strong></dt>
<dd>Primary keys or objects each of which contains values of all primary keys.</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return deleted records.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of affected rows or deleted records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete_many(cls, db: Connection, pks: Union[Sequence[PKS], Sequence[Record]], /, returning: bool = False):
    &#34;&#34;&#34;
    Delete a records by set of primary key(s).

    This method invokes on `executemany` defined in DB-API 2.0.
    Whether it is optimized compared to `execute` depends on DB driver.

    Args:
        db: DB connection.
        pks: Primary keys or objects each of which contains values of all primary keys.
        returning: Flag to return deleted records.
    Returns:
        The number of affected rows or deleted records.
    &#34;&#34;&#34;
    if len(pks) == 0:
        return None

    seq_of_pks: list[dict[str, Any]] = []
    for rec in pks:
        if isinstance(rec, (dict, cls)):
            seq_of_pks.append(extract_pks(cls, rec))
        else:
            cols, vals = parse_pks(cls, rec)
            seq_of_pks.append(dict(zip(cols, vals)))

    condition = Conditional.all([Q.eq(**{c: v}) for c, v in seq_of_pks[0].items()])
    wc, wp = where(condition)

    sql = f&#34;DELETE FROM {cls.name}{_spacer(wc)}&#34;
    seq_of_params: list[list[Any]] = [wp]

    for v in seq_of_pks[1:]:
        condition = Conditional.all([Q.eq(**{c: v}) for c, v in v.items()])
        _, wp = where(condition)
        seq_of_params.append(wp)

    if returning:
        models = cls.fetch_many(db, seq_of_pks)
        db.stmt().executemany(sql, seq_of_params)
        return models
    else:
        return db.stmt().executemany(sql, seq_of_params).rowcount</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.delete_where"><code class="name flex">
<span>def <span class="ident">delete_where</span></span>(<span>db:<a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition:<a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a>, /, returning:bool=False, allow_all:bool=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete records which satisfy the condition.</p>
<pre><code class="language-python">t.delete(db, Q.eq(c1=1))
# SQL: DELETE FROM t WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return deleted records.</dd>
<dt><strong><code>allow_all</code></strong></dt>
<dd>If <code>False</code>, empty condition raises <code>ValueError</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of affected rows or deleted records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete_where(cls, db: Connection, condition: Conditional, /, returning: bool = False, allow_all: bool = True):
    &#34;&#34;&#34;
    Delete records which satisfy the condition.

    ```python
    t.delete(db, Q.eq(c1=1))
    # SQL: DELETE FROM t WHERE c1 = 1
    ```

    Args:
        db: DB connection.
        condition: Query condition.
        returning: Flag to return deleted records.
        allow_all: If `False`, empty condition raises `ValueError`.
    Returns:
        The number of affected rows or deleted records.
    &#34;&#34;&#34;
    wc, wp = where(condition)
    if wc == &#34;&#34; and not allow_all:
        raise ValueError(&#34;Delete query to delete all records is not allowed.&#34;)

    sql = f&#34;DELETE FROM {cls.name}{_spacer(wc)}&#34;

    if returning:
        if cls.support_returning(db):
            c = db.stmt().execute(f&#34;{sql} RETURNING *&#34;, *wp)
            return [read_row(row, *cls.select())[0] for row in c.fetchall()]
        else:
            current = cls.fetch_where(db, condition)
            c = db.stmt().execute(sql, *wp)
            return current
    else:
        return db.stmt().execute(sql, *wp).rowcount</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>db:<a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, pks:Union[Any,dict[str,Any]], lock:Optional[Any]=None) >Optional[typing_extensions.Self]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a record by primary key(s).</p>
<pre><code class="language-python">t.fetch(db, 1)
# SQL: SELECT * FROM t WHERE id = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>pks</code></strong></dt>
<dd>Primary key value(s).</dd>
<dt><strong><code>lock</code></strong></dt>
<dd>Locking statement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A model object if exists, otherwise <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fetch(cls, db: Connection, pks: PKS, lock: Optional[Any] = None) -&gt; Optional[Self]:
    &#34;&#34;&#34;
    Fetch a record by primary key(s).

    ```python
    t.fetch(db, 1)
    # SQL: SELECT * FROM t WHERE id = 1
    ```

    Args:
        db: DB connection.
        pks: Primary key value(s).
        lock: Locking statement.
    Returns:
        A model object if exists, otherwise `None`.
    &#34;&#34;&#34;
    cols, vals = parse_pks(cls, pks)
    cond = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
    wc, wp = where(cond)
    s = cls.select()
    c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}&#34;, *wp)
    row = c.fetchone()
    return read_row(row, *s)[0] if row else None</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.fetch_many"><code class="name flex">
<span>def <span class="ident">fetch_many</span></span>(<span>db:<a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, seq_pks:collections.abc.Sequence[typing.Union[typing.Any,dict[str,typing.Any]]], lock:Optional[Any]=None, /, per_page:int=1000) >list[typing_extensions.Self]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a record by sequence of primary key(s).</p>
<p>This method simply concatenates equality conditions on primary key by OR operator.</p>
<pre><code class="language-python">t.fetch_many(db, [1, 2, 3])
# SQL: SELECT * FROM t WHERE id = 1 OR id = 2 OR id = 3
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>seq_pks</code></strong></dt>
<dd>Sequence of primary key value.</dd>
<dt><strong><code>lock</code></strong></dt>
<dd>Locking statement.</dd>
<dt><strong><code>per_page</code></strong></dt>
<dd>Maximum number of keys for an execution of query.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model objects in the same order as passed sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fetch_many(cls, db: Connection, seq_pks: Sequence[PKS], lock: Optional[Any] = None, /, per_page: int = 1000) -&gt; list[Self]:
    &#34;&#34;&#34;
    Fetch a record by sequence of primary key(s).

    This method simply concatenates equality conditions on primary key by OR operator.

    ```python
    t.fetch_many(db, [1, 2, 3])
    # SQL: SELECT * FROM t WHERE id = 1 OR id = 2 OR id = 3
    ```

    Args:
        db: DB connection.
        seq_pks: Sequence of primary key value.
        lock: Locking statement.
        per_page: Maximum number of keys for an execution of query.
    Returns:
        Model objects in the same order as passed sequence.
    &#34;&#34;&#34;
    res = []
    index = 0
    while index &lt; len(seq_pks):
        ordered_pks = []
        cond = Q.of()
        for pks in seq_pks[index:index+per_page]:
            cols, vals = parse_pks(cls, pks)
            ordered_pks.append(tuple(v for v in vals))
            cond |= Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
        wc, wp = where(cond)
        s = cls.select()
        c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}&#34;, *wp)

        record_map = {}
        for r in [read_row(row, *s)[0] for row in c.fetchall()]:
            pk_values = {c.name:v for c, v in r if c.pk}
            record_map[tuple([v for _, v in check_columns(cls, pk_values, lambda c: c.pk, True)])] = r

        res.extend([record_map[k] for k in ordered_pks if k in record_map])
        index += per_page

    return res</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.fetch_one"><code class="name flex">
<span>def <span class="ident">fetch_one</span></span>(<span>db:<a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition:<a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a>=Condition: '' -- [], lock:Optional[Any]=None) >Optional[typing_extensions.Self]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a record which satisfies the condition.</p>
<p><code>ValueError</code> raises When multiple records are found.
Use this method for queries which certainly returns a single row, such as search by unique key.</p>
<pre><code class="language-python">t.fetch_one(db, Q.eq(c1=1))
# SQL: SELECT * FROM t WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>lock</code></strong></dt>
<dd>Locking statement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model objects If exists, otherwise <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fetch_one(
    cls,
    db: Connection,
    condition: Conditional = Q.of(),
    lock: Optional[Any] = None,
) -&gt; Optional[Self]:
    &#34;&#34;&#34;
    Fetch a record which satisfies the condition.

    `ValueError` raises When multiple records are found.
    Use this method for queries which certainly returns a single row, such as search by unique key.

    ```python
    t.fetch_one(db, Q.eq(c1=1))
    # SQL: SELECT * FROM t WHERE c1 = 1
    ```

    Args:
        db: DB connection.
        condition: Query condition.
        lock: Locking statement.
    Returns:
        Model objects If exists, otherwise `None`.
    &#34;&#34;&#34;
    rs = cls.fetch_where(db, condition, lock=lock)

    if not rs:
        return None
    elif len(rs) == 1:
        return rs[0]
    else:
        raise ValueError(f&#34;{len(rs)} records are found on the invocation of fetch_one().&#34;)</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.fetch_where"><code class="name flex">
<span>def <span class="ident">fetch_where</span></span>(<span>db:<a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition:<a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a>=Condition: '' -- [], orders:collections.abc.Mapping[typing.Union[str,<a title="pyracmon.select.AliasedColumn" href="select.html#pyracmon.select.AliasedColumn">AliasedColumn</a>],typing.Union[bool,tuple[bool,bool],str]]={}, limit:Optional[int]=None, offset:Optional[int]=None, lock:Optional[Any]=None) >list[typing_extensions.Self]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch records which satisfy the condition.</p>
<pre><code class="language-python">t.fetch_where(db, Q.eq(c1=1), dict(c2=True), 10, 5)
# SQL: SELECT * FROM t WHERE c1 = 1 ORDER BY c2 ASC LIMIT 10 OFFSET 5
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>orders</code></strong></dt>
<dd>Ordering specification where key is column name and value denotes whether the order is ascending or not.</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>Maximum nuber of rows to fetch. If <code>None</code>, all rows are returned.</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>The number of rows to skip.</dd>
<dt><strong><code>lock</code></strong></dt>
<dd>Locking statement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fetch_where(
    cls,
    db: Connection,
    condition: Conditional = Q.of(),
    orders: Mapping[Union[str, AliasedColumn], ORDER] = {},
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    lock: Optional[Any] = None,
) -&gt; list[Self]:
    &#34;&#34;&#34;
    Fetch records which satisfy the condition.

    ```python
    t.fetch_where(db, Q.eq(c1=1), dict(c2=True), 10, 5)
    # SQL: SELECT * FROM t WHERE c1 = 1 ORDER BY c2 ASC LIMIT 10 OFFSET 5
    ```

    Args:
        db: DB connection.
        condition: Query condition.
        orders: Ordering specification where key is column name and value denotes whether the order is ascending or not.
        limit: Maximum nuber of rows to fetch. If `None`, all rows are returned.
        offset: The number of rows to skip.
        lock: Locking statement.
    Returns:
        Model objects.
    &#34;&#34;&#34;
    wc, wp = where(condition)
    rc, rp = ranged_by(limit, offset)
    s = cls.select()
    c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(order_by(orders))}{_spacer(rc)}{_spacer(lock)}&#34;, *(wp + rp))
    return [read_row(row, *s)[0] for row in c.fetchall()]</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>db:<a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, record:Union[typing_extensions.Self,dict[str,Any]], qualifier:collections.abc.Mapping[str,collections.abc.Callable[[str],str]]={}, /, returning:bool=False) >typing_extensions.Self</span>
</code></dt>
<dd>
<div class="desc"><p>Insert a record.</p>
<p>If <code>returning</code> is <code>True</code> and the DBMS supports <strong>RETURNING</strong> clause,
returned model object contains comple and correct column values.
Otherwise, auto incremental value is set to the returned model object
but other column values generated inside DBMS such as default value are not set.</p>
<pre><code class="language-python">t.insert(db, dict(c1=1, c2=2))
# SQL: INSERT INTO t (c1, c2) VALUES (1, 2)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Object contains column values.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return inserted record with complete and correct column values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model of inserted record.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def insert(
    cls,
    db: Connection,
    record: Union[Self, dict[str, Any]],
    qualifier: Mapping[str, Qualifier] = {},
    /,
    returning: bool = False,
) -&gt; Self:
    &#34;&#34;&#34;
    Insert a record.

    If `returning` is `True` and the DBMS supports **RETURNING** clause,
    returned model object contains comple and correct column values.
    Otherwise, auto incremental value is set to the returned model object
    but other column values generated inside DBMS such as default value are not set.

    ```python
    t.insert(db, dict(c1=1, c2=2))
    # SQL: INSERT INTO t (c1, c2) VALUES (1, 2)
    ```

    Args:
        db: DB connection.
        record: Object contains column values.
        qualifier: Functions qualifying placeholder markers.
        returning: Flag to return inserted record with complete and correct column values.
    Returns:
        Model of inserted record.
    &#34;&#34;&#34;
    model: Self = cast(Self, record) if isinstance(record, cls) else cls(**cast(dict, record))
    sql, _, vals = cls._insert_sql(record, qualifier)

    if returning:
        if cls.support_returning(db):
            c = db.stmt().execute(f&#34;{sql} RETURNING *&#34;, *vals)
            s = cls.select()
            return read_row(c.fetchone(), *s)[0]
        else:
            # REVIEW
            # Inserted row can&#39;t be specified from the table where no primary keys are defined .
            pass

    db.stmt().execute(sql, *vals)
    for c, v in cls.last_sequences(db, 1):
        setattr(model, c.name, v)
    return model</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.insert_many"><code class="name flex">
<span>def <span class="ident">insert_many</span></span>(<span>db:<a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, records:list[typing.Union[typing_extensions.Self,dict[str,typing.Any]]], qualifier:collections.abc.Mapping[str,collections.abc.Callable[[str],str]]={}, /, returning:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Insert records.</p>
<p>If <code>returning</code> is <code>True</code> and the DBMS supports <strong>RETURNING</strong> clause,
returned model object contains comple and correct column values.
Otherwise, auto incremental value is set to the returned model object
but other column values generated inside DBMS such as default value are not set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Object contains column values.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return inserted records with complete and correct column values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Models of inserted records or cursor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def insert_many(
    cls,
    db: Connection,
    records: list[Union[Self, dict[str, Any]]],
    qualifier: Mapping[str, Qualifier] = {},
    /,
    returning: bool = False,
):
    &#34;&#34;&#34;
    Insert records.

    If `returning` is `True` and the DBMS supports **RETURNING** clause,
    returned model object contains comple and correct column values.
    Otherwise, auto incremental value is set to the returned model object
    but other column values generated inside DBMS such as default value are not set.

    Args:
        db: DB connection.
        record: Object contains column values.
        qualifier: Functions qualifying placeholder markers.
        returning: Flag to return inserted records with complete and correct column values.
    Returns:
        Models of inserted records or cursor.
    &#34;&#34;&#34;
    if len(records) == 0:
        return []

    models: list[Self] = [cast(Self, r) if isinstance(r, cls) else cls(**cast(dict, r)) for r in records]

    seq_of_params = []

    sql, cols, params = cls._insert_sql(models[0], qualifier)

    cols = set(cols)
    seq_of_params.append(params)

    for m in models[1:]:
        value_dict = model_values(cls, m)
        check_columns(cls, value_dict, lambda c: c.name in cols, requires_all=True)
        # REVIEW:
        # The consistency among columns where expression is set is not checked.
        _, _, params = cls._insert_sql(m, qualifier)
        seq_of_params.append(params)

    db.stmt().executemany(sql, seq_of_params)
    num = len(records)
    for c, v in cls.last_sequences(db, num):
        for i, m in enumerate(models):
            setattr(m, c.name, v - (num - i - 1))

    if returning:
        seq_pks = [extract_pks(cls, m) for m in models]
        return cls.fetch_many(db, seq_pks)
    else:
        return models</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.last_sequences"><code class="name flex">
<span>def <span class="ident">last_sequences</span></span>(<span>db:<a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, num:int) >list[tuple[<a title="pyracmon.model.Column" href="model.html#pyracmon.model.Column">Column</a>,int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sequential (auto incremental) values of a table generated by the latest insertion.</p>
<p>Result contains every sequential columns and their values.
When the latest query inserts multiple rows, only the last (= biggest) value is returned.</p>
<p>This method should be overridden by another mixin class defined in dialect module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>num</code></strong></dt>
<dd>The number of records inserted by the latest query.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of pairs of column and its values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def last_sequences(cls, db: Connection, num: int) -&gt; list[tuple[Column, int]]:
    &#34;&#34;&#34;
    Returns the sequential (auto incremental) values of a table generated by the latest insertion.

    Result contains every sequential columns and their values.
    When the latest query inserts multiple rows, only the last (= biggest) value is returned.

    This method should be overridden by another mixin class defined in dialect module.

    Args:
        db: DB connection.
        num: The number of records inserted by the latest query.
    Returns:
        List of pairs of column and its values.
    &#34;&#34;&#34;
    return []</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.support_returning"><code class="name flex">
<span>def <span class="ident">support_returning</span></span>(<span>db:<a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whehter this DBMS support <strong>RETURNING</strong> clause or not.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whehter this DBMS support <strong>RETURNING</strong> clause or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def support_returning(cls, db: Connection) -&gt; bool:
    &#34;&#34;&#34;
    Checks whehter this DBMS support **RETURNING** clause or not.

    Args:
        db: DB connection.
    Returns:
        Whehter this DBMS support **RETURNING** clause or not.
    &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>db:<a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, pks:Union[Any,dict[str,Any]], record:Union[<a title="pyracmon.model.Meta" href="model.html#pyracmon.model.Meta">Meta</a>,dict[str,Any]], qualifier:collections.abc.Mapping[str,collections.abc.Callable[[str],str]]={}, /, returning:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Update a record by primary key(s).</p>
<p>This method only updates columns which are found in <code>record</code> except for primary key(s).</p>
<pre><code class="language-python">t.update(db, 1, dict(c1=1, c2=2))
# SQL: UPDATE t SET c1 = 1, c2 = 2 WHERE id = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>pks</code></strong></dt>
<dd>Primary key value(s).</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Object contains column values.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return updated records with complete and correct column values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the record exists and updated or updated record model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def update(
    cls,
    db: Connection,
    pks: PKS,
    record: Record,
    qualifier: Mapping[str, Qualifier] = {},
    /,
    returning: bool = False,
):
    &#34;&#34;&#34;
    Update a record by primary key(s).

    This method only updates columns which are found in `record` except for primary key(s).

    ```python
    t.update(db, 1, dict(c1=1, c2=2))
    # SQL: UPDATE t SET c1 = 1, c2 = 2 WHERE id = 1
    ```

    Args:
        db: DB connection.
        pks: Primary key value(s).
        record: Object contains column values.
        qualifier: Functions qualifying placeholder markers.
        returning: Flag to return updated records with complete and correct column values.
    Returns:
        Whether the record exists and updated or updated record model.
    &#34;&#34;&#34;
    cols, vals = parse_pks(cls, pks)
    condition = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
    if returning:
        if cls.support_returning(db):
            models = cls.update_where(db, record, condition, qualifier, returning=True)
            return models[0] if models else None
        else:
            models = cls.update_where(db, record, condition, qualifier, returning=False)
            return cls.fetch(db, pks)
    else:
        return cls.update_where(db, record, condition, qualifier, returning=False) == 1</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.update_many"><code class="name flex">
<span>def <span class="ident">update_many</span></span>(<span>db:<a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, records:collections.abc.Sequence[typing.Union[<a title="pyracmon.model.Meta" href="model.html#pyracmon.model.Meta">Meta</a>,dict[str,typing.Any]]], qualifier:collections.abc.Mapping[str,collections.abc.Callable[[str],str]]={}, /, returning:bool=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Update records by set of primary key(s).</p>
<p>This method invokes on <code>executemany</code> defined in DB-API 2.0.
Whether it is optimized compared to <code>execute</code> depends on DB driver.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Sequence of objects contains column values.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return updated records with complete and correct column values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of affected rows or updated records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def update_many(
    cls,
    db: Connection,
    records: Sequence[Record],
    qualifier: Mapping[str, Qualifier] = {},
    /,
    returning: bool = False,
):
    &#34;&#34;&#34;
    Update records by set of primary key(s).

    This method invokes on `executemany` defined in DB-API 2.0.
    Whether it is optimized compared to `execute` depends on DB driver.

    Args:
        db: DB connection.
        record: Sequence of objects contains column values.
        qualifier: Functions qualifying placeholder markers.
        returning: Flag to return updated records with complete and correct column values.
    Returns:
        The number of affected rows or updated records.
    &#34;&#34;&#34;
    if len(records) == 0:
        return [] if returning else 0

    keys = {c.name for c in cls.columns if c.pk}
    if len(keys) == 0:
        raise ValueError(f&#34;update_many is not available because {cls} does not have primary key columns.&#34;)

    def classify(acc: tuple[dict[str, Any], dict[str, Any]], cv: tuple[str, Any]):
        if cv[0] in keys:
            acc[0][cv[0]] = cv[1]
        else:
            acc[1][cv[0]] = cv[1]
        return acc

    seq_of_values: list[tuple[dict[str, Any], dict[str, Any]]] = []
    target_columns: Optional[set[str]] = None

    for vs in [model_values(cls, r, excludes_pk=False) for r in records]:
        if not keys &lt; vs.keys():
            raise ValueError(f&#34;Every row must contain values of all primary keys and at least one update column value.&#34;)
        pks, rec = reduce(classify, vs.items(), ({}, {}))
        if target_columns is None:
            check_columns(cls, rec)
            target_columns = set(rec.keys())
        else:
            check_columns(cls, rec, lambda c: c.name in target_columns, True) # type: ignore
        seq_of_values.append((pks, rec))

    sql_first = &#34;&#34;
    seq_of_params: list[list[Any]] = []

    for pks, rec in seq_of_values:
        cols, vals = parse_pks(cls, pks)
        condition = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])

        sql, _, params = cls._update_sql(rec, condition, qualifier)
        if not sql_first:
            sql_first = sql
        seq_of_params.append(params)

    if returning:
        db.stmt().executemany(f&#34;{sql_first}&#34;, seq_of_params)
        return cls.fetch_many(db, [pks for pks, _ in seq_of_values])
    else:
        return db.stmt().executemany(sql_first, seq_of_params).rowcount</code></pre>
</details>
</dd>
<dt id="pyracmon.mixin.CRUDMixin.update_where"><code class="name flex">
<span>def <span class="ident">update_where</span></span>(<span>db:<a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, record:Union[<a title="pyracmon.model.Meta" href="model.html#pyracmon.model.Meta">Meta</a>,dict[str,Any]], condition:<a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a>, qualifier:collections.abc.Mapping[str,collections.abc.Callable[[str],str]]={}, /, returning:bool=False, allow_all:bool=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Update records which satisfy the condition.</p>
<pre><code class="language-python">t.update(db, dict(c2=2), Q.eq(c1=1))
# SQL: UPDATE t SET c2 = 2 WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Object contains column values.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return updated records with complete and correct column values.</dd>
<dt><strong><code>allow_all</code></strong></dt>
<dd>If <code>False</code>, empty condition raises <code>ValueError</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of affected rows or updated records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def update_where(
    cls,
    db: Connection,
    record: Record,
    condition: Conditional,
    qualifier: Mapping[str, Qualifier] = {},
    /,
    returning: bool = False,
    allow_all: bool = True,
):
    &#34;&#34;&#34;
    Update records which satisfy the condition.

    ```python
    t.update(db, dict(c2=2), Q.eq(c1=1))
    # SQL: UPDATE t SET c2 = 2 WHERE c1 = 1
    ```

    Args:
        db: DB connection.
        record: Object contains column values.
        condition: Query condition.
        qualifier: Functions qualifying placeholder markers.
        returning: Flag to return updated records with complete and correct column values.
        allow_all: If `False`, empty condition raises `ValueError`.
    Returns:
        The number of affected rows or updated records.
    &#34;&#34;&#34;
    sql, _, params = cls._update_sql(record, condition, qualifier, allow_all)

    if returning:
        if cls.support_returning(db):
            c = db.stmt().execute(f&#34;{sql} RETURNING *&#34;, *params)
            s = cls.select()
            return [read_row(row, *s)[0] for row in c.fetchall()]
        else:
            raise NotImplementedError(f&#34;RETURNING is not supported and there is no way to fetch updated rows exactly.&#34;)
    else:
        c = db.stmt().execute(sql, *params)

        return c.rowcount</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyracmon.select.SelectMixin" href="select.html#pyracmon.select.SelectMixin">SelectMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyracmon.select.SelectMixin.select" href="select.html#pyracmon.select.SelectMixin.select">select</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyracmon" href="index.html">pyracmon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyracmon.mixin.CRUDInternalMeta" href="#pyracmon.mixin.CRUDInternalMeta">CRUDInternalMeta</a></code></h4>
</li>
<li>
<h4><code><a title="pyracmon.mixin.CRUDMixin" href="#pyracmon.mixin.CRUDMixin">CRUDMixin</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.mixin.CRUDMixin.count" href="#pyracmon.mixin.CRUDMixin.count">count</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.delete" href="#pyracmon.mixin.CRUDMixin.delete">delete</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.delete_many" href="#pyracmon.mixin.CRUDMixin.delete_many">delete_many</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.delete_where" href="#pyracmon.mixin.CRUDMixin.delete_where">delete_where</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.fetch" href="#pyracmon.mixin.CRUDMixin.fetch">fetch</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.fetch_many" href="#pyracmon.mixin.CRUDMixin.fetch_many">fetch_many</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.fetch_one" href="#pyracmon.mixin.CRUDMixin.fetch_one">fetch_one</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.fetch_where" href="#pyracmon.mixin.CRUDMixin.fetch_where">fetch_where</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.insert" href="#pyracmon.mixin.CRUDMixin.insert">insert</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.insert_many" href="#pyracmon.mixin.CRUDMixin.insert_many">insert_many</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.last_sequences" href="#pyracmon.mixin.CRUDMixin.last_sequences">last_sequences</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.support_returning" href="#pyracmon.mixin.CRUDMixin.support_returning">support_returning</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.update" href="#pyracmon.mixin.CRUDMixin.update">update</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.update_many" href="#pyracmon.mixin.CRUDMixin.update_many">update_many</a></code></li>
<li><code><a title="pyracmon.mixin.CRUDMixin.update_where" href="#pyracmon.mixin.CRUDMixin.update_where">update_where</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>