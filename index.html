<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyracmon API documentation</title>
<meta name="description" content="Base module of pyracmon exporting commonly used objects.
Use `*` simply to import them …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>pyracmon</code></h1>
</header>
<section id="section-intro">
<p>Base module of pyracmon exporting commonly used objects.
Use <code>*</code> simply to import them.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pyracmon import *
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Base module of pyracmon exporting commonly used objects.  Use `*` simply to import them.

&gt;&gt;&gt; from pyracmon import *
&#34;&#34;&#34;
import sys
import types
from typing import Union, Optional, Any, TypeVar, TYPE_CHECKING
from pyracmon.config import default_config
from pyracmon.connection import connect, Connection
from pyracmon.context import ConnectionContext
from pyracmon.graph.serialize import NodeSerializer
from pyracmon.mixin import CRUDMixin
from pyracmon.select import read_row
from pyracmon.model import define_model, Table, Column
from pyracmon.model_graph import GraphEntityMixin
from pyracmon.query import Q, Expression, Conditional, escape_like, where
from pyracmon.query_graph import append_rows
from pyracmon.clause import order_by, ranged_by, holders, values
from pyracmon.stub import output_stub
from pyracmon.graph import new_graph, S
from pyracmon.graph.graph import Graph, GraphView, NodeContainer, ContainerView, Node, NodeView
from pyracmon.graph.spec import GraphSpec
from pyracmon.graph.template import GraphTemplate
from pyracmon.graph.schema import document_type, Typeable, GraphSchema
from pyracmon.graph.serialize import NodeContext
from pyracmon.graph.typing import walk_schema
from pyracmon.testing import TestingMixin


if TYPE_CHECKING:
    from pyracmon.model import Model as _Model
    class Model(_Model):
        pass
else:
    from pyracmon.model import Model


__all__ = [
    &#34;connect&#34;,
    &#34;Connection&#34;,
    &#34;ConnectionContext&#34;,
    &#34;CRUDMixin&#34;,
    &#34;read_row&#34;,
    &#34;define_model&#34;,
    &#34;Table&#34;,
    &#34;Column&#34;,
    &#34;Q&#34;,
    &#34;Expression&#34;,
    &#34;Conditional&#34;,
    &#34;where&#34;,
    &#34;append_rows&#34;,
    &#34;escape_like&#34;,
    &#34;order_by&#34;,
    &#34;ranged_by&#34;,
    &#34;holders&#34;,
    &#34;values&#34;,
    &#34;new_graph&#34;,
    &#34;S&#34;,
    &#34;Graph&#34;,
    &#34;GraphView&#34;,
    &#34;NodeContainer&#34;,
    &#34;ContainerView&#34;,
    &#34;Node&#34;,
    &#34;NodeView&#34;,
    &#34;document_type&#34;,
    &#34;Typeable&#34;,
    &#34;walk_schema&#34;,
    &#34;GraphSchema&#34;,
    &#34;NodeContext&#34;,
    &#34;Model&#34;,
    &#34;declare_models&#34;,
    &#34;graph_template&#34;,
    &#34;graph_dict&#34;,
    &#34;graph_schema&#34;,
]


M = TypeVar(&#39;M&#39;, bound=Model)


def declare_models(
    dialect: types.ModuleType,
    db: Connection,
    module: Union[types.ModuleType, str] = __name__,
    mixins: list[type] = [],
    excludes: Optional[list[str]] = None,
    includes: Optional[list[str]] = None,
    *,
    testing: bool = False,
    model_type: type[M] = Model,
    write_stub: bool = False,
) -&gt; list[type[M]]:
    &#34;&#34;&#34;
    Declare model types read from database into the specified module.

    Args:
        dialect: A module exporting `read_schema` function and `mixins` classes.
            `pyracmon.dialect.postgresql` and `pyracmon.dialect.mysql` are available.
        db: Connection already connected to database.
        module: A module or module name where the declarations will be located.
        mixins: Additional mixin classes for declaring model types.
        excludes: Excluding table names.
        includes: Including table names. When this argument is omitted, all tables except for specified in `excludes` are declared.
    Returns:
        Declared model types.
    &#34;&#34;&#34;
    tables = dialect.read_schema(db, excludes, includes)
    models = []
    mod = module if isinstance(module, types.ModuleType) else sys.modules[module]
    base_mixins = [CRUDMixin, GraphEntityMixin, model_type]
    if testing:
        base_mixins[0:0] = [TestingMixin]
    for t in tables:
        m = define_model(t, mixins + dialect.mixins + base_mixins)
        mod.__dict__[t.name] = m
        models.append(m)
    if write_stub:
        output_stub(None, mod, models, dialect, mixins, testing=testing)
    return models


def graph_template(*bases: GraphTemplate, **definitions: type) -&gt; GraphTemplate:
    &#34;&#34;&#34;
    Create a graph template on the default `GraphSpec` which handles model object in appropriate ways.

    See `pyracmon.graph.GraphSpec.new_template` for the detail of definitions.

    Args:
        bases: Base templates whose properties and relations are merged into new template.
        definitions: Definitions of template properties.
    Returns:
        Graph template.
    &#34;&#34;&#34;
    return default_config().graph_spec.new_template(*bases, **definitions)


def graph_dict(graph: GraphView, **settings: NodeSerializer) -&gt; dict[str, Any]:
    &#34;&#34;&#34;
    Serialize a graph into a `dict` under the default `GraphSpec` .

    See `pyracmon.graph.GraphSpec.to_dict` for the detail of serialization settings.

    Args:
        graph: A view of the graph.
        settings: Serialization settings where each key denotes a node name.
    Returns:
        Serialization result.
    &#34;&#34;&#34;
    return default_config().graph_spec.to_dict(graph, {}, **settings)


def graph_schema(template: GraphTemplate, **settings: NodeSerializer) -&gt; GraphSchema:
    &#34;&#34;&#34;
    Creates `GraphSchema` under the default `GraphSpec` .

    See `pyracmon.graph.GraphSpec.to_schema` for the detail of serialization settings.

    Args:
        template: A template of serializing graph.
        settings: Serialization settings where each key denotes a node name.
    Returns:
        Schema of serialization result.
    &#34;&#34;&#34;
    return default_config().graph_spec.to_schema(template, **settings)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyracmon.batch" href="batch.html">pyracmon.batch</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.clause" href="clause.html">pyracmon.clause</a></code></dt>
<dd>
<div class="desc"><p>This module provides functions to generate miscellaneous clauses in query.</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.config" href="config.html">pyracmon.config</a></code></dt>
<dd>
<div class="desc"><p>This module exports types and functions for configurations …</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.connection" href="connection.html">pyracmon.connection</a></code></dt>
<dd>
<div class="desc"><p>This module provides types and functions for DB connections.</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.context" href="context.html">pyracmon.context</a></code></dt>
<dd>
<div class="desc"><p>This module provides the context type which controls query execution as configured.</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.dbapi" href="dbapi.html">pyracmon.dbapi</a></code></dt>
<dd>
<div class="desc"><p>This module provides interfaces defined in DB-API 2.0.</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.dialect" href="dialect/index.html">pyracmon.dialect</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph" href="graph/index.html">pyracmon.graph</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.marker" href="marker.html">pyracmon.marker</a></code></dt>
<dd>
<div class="desc"><p>This module provides the abstration mechanism for marker creation used to embed parameters in a query …</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.mixin" href="mixin.html">pyracmon.mixin</a></code></dt>
<dd>
<div class="desc"><p>This module provides mixin type which supplies each model type various DB operations as class methods.</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.model" href="model.html">pyracmon.model</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.model_graph" href="model_graph.html">pyracmon.model_graph</a></code></dt>
<dd>
<div class="desc"><p>This module provides graph specifications to deal with model types …</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.query" href="query.html">pyracmon.query</a></code></dt>
<dd>
<div class="desc"><p>This module exports types and functions for query construction …</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.query_graph" href="query_graph.html">pyracmon.query_graph</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.select" href="select.html">pyracmon.select</a></code></dt>
<dd>
<div class="desc"><p>This module exports types and functions used for <code>SELECT</code> queries …</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.sql" href="sql.html">pyracmon.sql</a></code></dt>
<dd>
<div class="desc"><p>This module provides the type for query generation from a template string containing unified marker.</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.stub" href="stub.html">pyracmon.stub</a></code></dt>
<dd>
<div class="desc"><p>This module exports functions to output type stub of model types.</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.testing" href="testing/index.html">pyracmon.testing</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.util" href="util.html">pyracmon.util</a></code></dt>
<dd>
<div class="desc"><p>Utility types and functions for internal use.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyracmon.append_rows"><code class="name flex">
<span>def <span class="ident">append_rows</span></span>(<span>cursor: <a title="pyracmon.dbapi.Cursor" href="dbapi.html#pyracmon.dbapi.Cursor">Cursor</a>, exp: collections.abc.Iterable[typing.Union[<a title="pyracmon.select.Consumable" href="select.html#pyracmon.select.Consumable">Consumable</a>, typing.Any]], graph: <a title="pyracmon.graph.graph.Graph" href="graph/graph.html#pyracmon.graph.graph.Graph">Graph</a>, /, **assign: Union[<a title="pyracmon.select.Selection" href="select.html#pyracmon.select.Selection">Selection</a>, Any]) ‑> <a title="pyracmon.graph.graph.Graph" href="graph/graph.html#pyracmon.graph.graph.Graph">Graph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds all rows in cursor into the graph.</p>
<p>Values in <code>assign</code> are <code>Selection</code> or any kind of objects.
If <code>Selection</code> is passed, the corresponding value in row is selected.
In this case, the <code>Selection</code> must be contained in <code>exp</code> , otherwise <code>ValueError</code> is raised.</p>
<pre><code class="language-python">exp = ...
c = db.stmt().execute(...)
graph = add_all(c, exp, new_graph(SomeGraph), a=exp.a, b=exp.b, c=0)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cursor</code></strong></dt>
<dd>Cursor obtained by query.</dd>
<dt><strong><code>exp</code></strong></dt>
<dd>Expressions used in the query.</dd>
<dt><strong><code>graph</code></strong></dt>
<dd>Graph to append rows.</dd>
<dt><strong><code>assign</code></strong></dt>
<dd>Mapping from graph property name to <code>Selection</code> or arbitrary value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The same graph as passed one.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_rows(cursor: Cursor, exp: Iterable[Union[Consumable, Any]], graph: Graph, /, **assign: Union[Selection, Any]) -&gt; Graph:
    &#34;&#34;&#34;
    Adds all rows in cursor into the graph.

    Values in `assign` are `Selection` or any kind of objects.
    If `Selection` is passed, the corresponding value in row is selected.
    In this case, the `Selection` must be contained in `exp` , otherwise `ValueError` is raised.

    ```python
    exp = ...
    c = db.stmt().execute(...)
    graph = add_all(c, exp, new_graph(SomeGraph), a=exp.a, b=exp.b, c=0)
    ```

    Args:
        cursor: Cursor obtained by query.
        exp: Expressions used in the query.
        graph: Graph to append rows.
        assign: Mapping from graph property name to `Selection` or arbitrary value.
    Returns:
        The same graph as passed one. 
    &#34;&#34;&#34;
    def get(k: str) -&gt; Any:
        v = assign[k]
        if isinstance(v, Consumable):
            return getattr(r, v.name)
        else:
            return v

    for row in cursor.fetchall():
        r = read_row(row, *exp)
        graph.append(**{k:get(k) for k in assign.keys()})

    return graph</code></pre>
</details>
</dd>
<dt id="pyracmon.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>api: module, *args: Any, **kwargs: Any) ‑> <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a></span>
</code></dt>
<dd>
<div class="desc"><p>Connects to DB by passing arguments to DB-API 2.0 module.</p>
<p>Every optional argument is passed to <code>api.connect</code> and returns the <code><a title="pyracmon.Connection" href="#pyracmon.Connection">Connection</a></code> object which wraps obtained DB connection.</p>
<pre><code class="language-python">import psycopg2
from pyracmon import connect
db = connect(psycopg2, host=&quot;localhost&quot;, port=5432, dbname=&quot;pyracmon&quot;, user=&quot;postgres&quot;, password=&quot;postgres&quot;)
c = db.stmt().execute(&quot;SELECT 1&quot;)
assert c.fetchone()[0] == 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api</code></strong></dt>
<dd>DB-API 2.0 module which exports <code><a title="pyracmon.connect" href="#pyracmon.connect">connect()</a></code> function.</dd>
<dt><strong><code>args</code></strong></dt>
<dd>Positional arguments passed to <code>api.connect</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code>api.connect</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Wrapper of DB-API 2.0 connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(api: types.ModuleType, *args: Any, **kwargs: Any) -&gt; &#39;Connection&#39;:
    &#34;&#34;&#34;
    Connects to DB by passing arguments to DB-API 2.0 module.

    Every optional argument is passed to `api.connect` and returns the `Connection` object which wraps obtained DB connection.

    ```python
    import psycopg2
    from pyracmon import connect
    db = connect(psycopg2, host=&#34;localhost&#34;, port=5432, dbname=&#34;pyracmon&#34;, user=&#34;postgres&#34;, password=&#34;postgres&#34;)
    c = db.stmt().execute(&#34;SELECT 1&#34;)
    assert c.fetchone()[0] == 1
    ```

    Args:
        api: DB-API 2.0 module which exports `connect` function.
        args: Positional arguments passed to `api.connect`.
        kwargs: Keyword arguments passed to `api.connect`.
    Returns:
        Wrapper of DB-API 2.0 connection.
    &#34;&#34;&#34;
    return Connection(api, api.connect(*args, **kwargs), None)</code></pre>
</details>
</dd>
<dt id="pyracmon.declare_models"><code class="name flex">
<span>def <span class="ident">declare_models</span></span>(<span>dialect: module, db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, module: Union[module, str] = 'pyracmon', mixins: list[type] = [], excludes: Optional[list[str]] = None, includes: Optional[list[str]] = None, *, testing: bool = False, model_type: type[~M] = pyracmon.model.Model, write_stub: bool = False) ‑> list[type[~M]]</span>
</code></dt>
<dd>
<div class="desc"><p>Declare model types read from database into the specified module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dialect</code></strong></dt>
<dd>A module exporting <code>read_schema</code> function and <code>mixins</code> classes.
<code><a title="pyracmon.dialect.postgresql" href="dialect/postgresql.html">pyracmon.dialect.postgresql</a></code> and <code><a title="pyracmon.dialect.mysql" href="dialect/mysql.html">pyracmon.dialect.mysql</a></code> are available.</dd>
<dt><strong><code>db</code></strong></dt>
<dd>Connection already connected to database.</dd>
<dt><strong><code>module</code></strong></dt>
<dd>A module or module name where the declarations will be located.</dd>
<dt><strong><code>mixins</code></strong></dt>
<dd>Additional mixin classes for declaring model types.</dd>
<dt><strong><code>excludes</code></strong></dt>
<dd>Excluding table names.</dd>
<dt><strong><code>includes</code></strong></dt>
<dd>Including table names. When this argument is omitted, all tables except for specified in <code>excludes</code> are declared.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Declared model types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def declare_models(
    dialect: types.ModuleType,
    db: Connection,
    module: Union[types.ModuleType, str] = __name__,
    mixins: list[type] = [],
    excludes: Optional[list[str]] = None,
    includes: Optional[list[str]] = None,
    *,
    testing: bool = False,
    model_type: type[M] = Model,
    write_stub: bool = False,
) -&gt; list[type[M]]:
    &#34;&#34;&#34;
    Declare model types read from database into the specified module.

    Args:
        dialect: A module exporting `read_schema` function and `mixins` classes.
            `pyracmon.dialect.postgresql` and `pyracmon.dialect.mysql` are available.
        db: Connection already connected to database.
        module: A module or module name where the declarations will be located.
        mixins: Additional mixin classes for declaring model types.
        excludes: Excluding table names.
        includes: Including table names. When this argument is omitted, all tables except for specified in `excludes` are declared.
    Returns:
        Declared model types.
    &#34;&#34;&#34;
    tables = dialect.read_schema(db, excludes, includes)
    models = []
    mod = module if isinstance(module, types.ModuleType) else sys.modules[module]
    base_mixins = [CRUDMixin, GraphEntityMixin, model_type]
    if testing:
        base_mixins[0:0] = [TestingMixin]
    for t in tables:
        m = define_model(t, mixins + dialect.mixins + base_mixins)
        mod.__dict__[t.name] = m
        models.append(m)
    if write_stub:
        output_stub(None, mod, models, dialect, mixins, testing=testing)
    return models</code></pre>
</details>
</dd>
<dt id="pyracmon.define_model"><code class="name flex">
<span>def <span class="ident">define_model</span></span>(<span>table_: <a title="pyracmon.model.Table" href="model.html#pyracmon.model.Table">Table</a>, mixins: Union[type[~MXT], list[type], ForwardRef(None)] = None, model_type: Optional[type[~M]] = pyracmon.model.Model) ‑> type[~M]</span>
</code></dt>
<dd>
<div class="desc"><p>Create a model type representing a table.</p>
<p>Model type inherits all types in <code>mixins</code> in order.
When the same attribute is defined in multiple mixin types, the former overrides the latter.</p>
<p>Every model type has following attributes:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">name</th>
<th style="text-align: left;">type</th>
<th style="text-align: left;">description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">name</td>
<td style="text-align: left;"><code>str</code></td>
<td style="text-align: left;">Name of the table.</td>
</tr>
<tr>
<td style="text-align: left;">table</td>
<td style="text-align: left;"><code><a title="pyracmon.Table" href="#pyracmon.Table">Table</a></code></td>
<td style="text-align: left;">Table schema.</td>
</tr>
<tr>
<td style="text-align: left;">columns</td>
<td style="text-align: left;"><code>List[<a title="pyracmon.Column" href="#pyracmon.Column">Column</a>]</code></td>
<td style="text-align: left;">List of column schemas.</td>
</tr>
<tr>
<td style="text-align: left;">column</td>
<td style="text-align: left;"><code>Any</code></td>
<td style="text-align: left;">An object whose attribute exposes of column schema of its name.</td>
</tr>
</tbody>
</table>
<p>Model instances are created by passing the constructor keyword arguments composed of column names and values like builtin dataclass.
Unlike dataclass, the constructor does not require all of columns.
Omitted columns don't affect predefined operations such as <code><a title="pyracmon.CRUDMixin.insert" href="#pyracmon.CRUDMixin.insert">CRUDMixin.insert()</a></code> .
If <code>not null</code> constraint exists on the column, insertion will be denied at runtime and exception will be thrown.</p>
<pre><code class="language-python">&gt;&gt;&gt; # CREATE TABLE t1 (col1 int, col2 text, col3 text);
&gt;&gt;&gt; table = define_model(&quot;t1&quot;)
&gt;&gt;&gt; model = table(col1=1, col2=&quot;a&quot;)
</code></pre>
<p>Attributes are also assignable by normal setter. If attribute name is not a valid column name, <code>TypeError</code> raises.</p>
<pre><code class="language-python">&gt;&gt;&gt; model.col3 = &quot;b&quot;
</code></pre>
<p>Model instance supports iteration which yields pairs of assigned column schema and its value.</p>
<pre><code class="language-python">&gt;&gt;&gt; for c, v in model:
&gt;&gt;&gt;     print(f&quot;{c.name} = {v}&quot;)
col1 = 1
col2 = a
col3 = b
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>table__</code></strong></dt>
<dd>Table schema.</dd>
<dt><strong><code>mixin</code></strong></dt>
<dd>Mixin types providing class methods to the model type.</dd>
<dt><strong><code>model_type</code></strong></dt>
<dd>Use this just for type hinting to determine returned model type.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_model(table_: Table, mixins: Union[type[MXT], list[type], None] = None, model_type: Optional[type[M]] = Model) -&gt; type[M]:
    &#34;&#34;&#34;
    Create a model type representing a table.

    Model type inherits all types in `mixins` in order.
    When the same attribute is defined in multiple mixin types, the former overrides the latter.

    Every model type has following attributes:

    |name|type|description|
    |:---|:---|:---|
    |name|`str`|Name of the table.|
    |table|`Table`|Table schema.|
    |columns|`List[Column]`|List of column schemas.|
    |column|`Any`|An object whose attribute exposes of column schema of its name.|

    Model instances are created by passing the constructor keyword arguments composed of column names and values like builtin dataclass.
    Unlike dataclass, the constructor does not require all of columns.
    Omitted columns don&#39;t affect predefined operations such as `CRUDMixin.insert` .
    If `not null` constraint exists on the column, insertion will be denied at runtime and exception will be thrown.

    ```python
    &gt;&gt;&gt; # CREATE TABLE t1 (col1 int, col2 text, col3 text);
    &gt;&gt;&gt; table = define_model(&#34;t1&#34;)
    &gt;&gt;&gt; model = table(col1=1, col2=&#34;a&#34;)
    ```

    Attributes are also assignable by normal setter. If attribute name is not a valid column name, `TypeError` raises.

    ```python
    &gt;&gt;&gt; model.col3 = &#34;b&#34;
    ```

    Model instance supports iteration which yields pairs of assigned column schema and its value.

    ```python
    &gt;&gt;&gt; for c, v in model:
    &gt;&gt;&gt;     print(f&#34;{c.name} = {v}&#34;)
    col1 = 1
    col2 = a
    col3 = b
    ```

    Args:
        table__: Table schema.
        mixin: Mixin types providing class methods to the model type.
        model_type: Use this just for type hinting to determine returned model type.
    Returns:
        Model type.
    &#34;&#34;&#34;
    column_names = {c.name for c in table_.columns}

    class Columns:
        def __init__(self):
            for c in table_.columns:
                setattr(self, c.name, c)

    class Meta(type):
        name = table_.name
        table = table_
        columns = table_.columns
        column = Columns()

        @classmethod
        def shrink(cls, excludes: list[str], includes: Optional[list[str]] = None) -&gt; Self:
            &#34;&#34;&#34;
            Creates new model type containing subset of columns.

            Args:
                excludes: Column names to exclude.
                includes: Column names to include.
            Returns:
                model type.
            &#34;&#34;&#34;
            cols = [c for c in cls.columns if (not includes or c.name in includes) and c.name not in excludes]
            return define_model(Table(cls.name, cols, cls.table.comment), mixins) # type: ignore

    class Base(Model, metaclass=Meta):
        pass

    mixin_types: list[type] = []

    if isinstance(mixins, list):
        mixin_types = mixins
    elif get_origin(mixins) is not None:
        mixin_types = cast(list[type], list(get_args(mixins)))
    elif mixins is not None:
        raise ValueError(f&#34;Model mixin types should be specified by Mixins or a list of types.&#34;)

    class _Model(type(&#34;ModelBase&#34;, tuple([Base] + mixin_types), {})):
        def __init__(self, **kwargs):
            for k, v in kwargs.items():
                setattr(self, k, v)

        def __repr__(self):
            cls = cast(type[Base], type(self))
            return f&#34;{cls.name}({&#39;, &#39;.join([f&#39;{c.name}={repr(getattr(self, c.name))}&#39; for c in cls.columns if hasattr(self, c.name)])})&#34;

        def __str__(self):
            cls = cast(type[Base], type(self))
            return f&#34;{cls.name}({&#39;, &#39;.join([f&#39;{c.name}={str(getattr(self, c.name))}&#39; for c in cls.columns if hasattr(self, c.name)])})&#34;

        def __iter__(self) -&gt; Iterator[tuple[Column, Any]]:
            cls = cast(type[Base], type(self))
            return map(lambda c: (c, getattr(self, c.name)), filter(lambda c: hasattr(self, c.name), cls.columns))

        def __setattr__(self, key, value):
            cls = cast(type[Base], type(self))
            if key not in column_names:
                raise TypeError(f&#34;{key} is not a column of {cls.name}&#34;)
            object.__setattr__(self, key, value)

        def __getitem__(self, key):
            return getattr(self, key)

        def __contains__(self, key):
            return hasattr(self, key)

        def __eq__(self, other):
            cls = type(self)
            if cls != type(other):
                return False
            for k in column_names:
                if hasattr(self, k) ^ hasattr(other, k):
                    return False
                if getattr(self, k, None) != getattr(other, k, None):
                    return False
            return True

    return cast(type[M], _Model)</code></pre>
</details>
</dd>
<dt id="pyracmon.document_type"><code class="name flex">
<span>def <span class="ident">document_type</span></span>(<span>t: type, doc: str) ‑> <class 'Annotated'></span>
</code></dt>
<dd>
<div class="desc"><p>Supplies a document to a type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>t</code></strong></dt>
<dd>A type.</dd>
<dt><strong><code>doc</code></strong></dt>
<dd>A document.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Documented type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def document_type(t: type, doc: str) -&gt; Annotated:
    &#34;&#34;&#34;
    Supplies a document to a type.

    Args:
        t: A type.
        doc: A document.
    Returns:
        Documented type.
    &#34;&#34;&#34;
    return Annotated[t, doc]</code></pre>
</details>
</dd>
<dt id="pyracmon.escape_like"><code class="name flex">
<span>def <span class="ident">escape_like</span></span>(<span>v: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Escape a string for the use in <code>LIKE</code> condition.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>v</code></strong></dt>
<dd>A string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Escaped string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def escape_like(v: str) -&gt; str:
    &#34;&#34;&#34;
    Escape a string for the use in `LIKE` condition.

    Args:
        v: A string.
    Returns:
        Escaped string.
    &#34;&#34;&#34;
    def esc(c):
        if c == &#34;\\&#34;:
            return r&#34;\\\\&#34;
        elif c == &#34;%&#34;:
            return r&#34;\%&#34;
        elif c == &#34;_&#34;:
            return r&#34;\_&#34;
        else:
            return c
    return &#39;&#39;.join(map(esc, v))</code></pre>
</details>
</dd>
<dt id="pyracmon.graph_dict"><code class="name flex">
<span>def <span class="ident">graph_dict</span></span>(<span>graph: <a title="pyracmon.graph.graph.GraphView" href="graph/graph.html#pyracmon.graph.graph.GraphView">GraphView</a>, **settings: <a title="pyracmon.graph.serialize.NodeSerializer" href="graph/serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize a graph into a <code>dict</code> under the default <code>GraphSpec</code> .</p>
<p>See <code><a title="pyracmon.graph.GraphSpec.to_dict" href="graph/index.html#pyracmon.graph.GraphSpec.to_dict">GraphSpec.to_dict()</a></code> for the detail of serialization settings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>A view of the graph.</dd>
<dt><strong><code>settings</code></strong></dt>
<dd>Serialization settings where each key denotes a node name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Serialization result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graph_dict(graph: GraphView, **settings: NodeSerializer) -&gt; dict[str, Any]:
    &#34;&#34;&#34;
    Serialize a graph into a `dict` under the default `GraphSpec` .

    See `pyracmon.graph.GraphSpec.to_dict` for the detail of serialization settings.

    Args:
        graph: A view of the graph.
        settings: Serialization settings where each key denotes a node name.
    Returns:
        Serialization result.
    &#34;&#34;&#34;
    return default_config().graph_spec.to_dict(graph, {}, **settings)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph_schema"><code class="name flex">
<span>def <span class="ident">graph_schema</span></span>(<span>template: <a title="pyracmon.graph.template.GraphTemplate" href="graph/template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, **settings: <a title="pyracmon.graph.serialize.NodeSerializer" href="graph/serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>) ‑> <a title="pyracmon.graph.schema.GraphSchema" href="graph/schema.html#pyracmon.graph.schema.GraphSchema">GraphSchema</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates <code><a title="pyracmon.GraphSchema" href="#pyracmon.GraphSchema">GraphSchema</a></code> under the default <code>GraphSpec</code> .</p>
<p>See <code><a title="pyracmon.graph.GraphSpec.to_schema" href="graph/index.html#pyracmon.graph.GraphSpec.to_schema">GraphSpec.to_schema()</a></code> for the detail of serialization settings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template</code></strong></dt>
<dd>A template of serializing graph.</dd>
<dt><strong><code>settings</code></strong></dt>
<dd>Serialization settings where each key denotes a node name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Schema of serialization result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graph_schema(template: GraphTemplate, **settings: NodeSerializer) -&gt; GraphSchema:
    &#34;&#34;&#34;
    Creates `GraphSchema` under the default `GraphSpec` .

    See `pyracmon.graph.GraphSpec.to_schema` for the detail of serialization settings.

    Args:
        template: A template of serializing graph.
        settings: Serialization settings where each key denotes a node name.
    Returns:
        Schema of serialization result.
    &#34;&#34;&#34;
    return default_config().graph_spec.to_schema(template, **settings)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph_template"><code class="name flex">
<span>def <span class="ident">graph_template</span></span>(<span>*bases: <a title="pyracmon.graph.template.GraphTemplate" href="graph/template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, **definitions: type) ‑> <a title="pyracmon.graph.template.GraphTemplate" href="graph/template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a graph template on the default <code>GraphSpec</code> which handles model object in appropriate ways.</p>
<p>See <code><a title="pyracmon.graph.GraphSpec.new_template" href="graph/index.html#pyracmon.graph.GraphSpec.new_template">GraphSpec.new_template()</a></code> for the detail of definitions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bases</code></strong></dt>
<dd>Base templates whose properties and relations are merged into new template.</dd>
<dt><strong><code>definitions</code></strong></dt>
<dd>Definitions of template properties.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Graph template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graph_template(*bases: GraphTemplate, **definitions: type) -&gt; GraphTemplate:
    &#34;&#34;&#34;
    Create a graph template on the default `GraphSpec` which handles model object in appropriate ways.

    See `pyracmon.graph.GraphSpec.new_template` for the detail of definitions.

    Args:
        bases: Base templates whose properties and relations are merged into new template.
        definitions: Definitions of template properties.
    Returns:
        Graph template.
    &#34;&#34;&#34;
    return default_config().graph_spec.new_template(*bases, **definitions)</code></pre>
</details>
</dd>
<dt id="pyracmon.holders"><code class="name flex">
<span>def <span class="ident">holders</span></span>(<span>length_or_keys: Union[int, collections.abc.Sequence[Union[str, int, NoneType, <a title="pyracmon.query.Expression" href="query.html#pyracmon.query.Expression">Expression</a>]]], qualifier: Optional[collections.abc.Mapping[int, collections.abc.Callable[[str], str]]] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generates partial query string containing placeholder markers separated by comma.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>length_or_keys</code></strong></dt>
<dd>The number of placeholders or list of placeholder keys.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Qualifying function for each index.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Query string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def holders(length_or_keys: Union[int, Sequence[HolderKeys]], qualifier: Optional[Mapping[int, Qualifier]] = None) -&gt; str:
    &#34;&#34;&#34;
    Generates partial query string containing placeholder markers separated by comma.

    Args:
        length_or_keys: The number of placeholders or list of placeholder keys.
        qualifier: Qualifying function for each index.
    Returns:
        Query string.
    &#34;&#34;&#34;
    if isinstance(length_or_keys, int):
        hs = [&#34;${_}&#34;] * length_or_keys
    else:
        def key(k):
            if isinstance(k, Expression):
                return k.expression
            elif isinstance(k, int):
                return f&#34;${{_{k}}}&#34;
            elif k:
                return f&#34;${{{k}}}&#34;
            else:
                return &#34;${_}&#34;
        hs = [key(k) for k in length_or_keys]

    if qualifier:
        hs = [qualifier.get(i, _noop)(h) for i, h in enumerate(hs)]

    return &#39;, &#39;.join(hs)</code></pre>
</details>
</dd>
<dt id="pyracmon.new_graph"><code class="name flex">
<span>def <span class="ident">new_graph</span></span>(<span>template: <a title="pyracmon.graph.template.GraphTemplate" href="graph/template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, *bases: Union[<a title="pyracmon.graph.graph.Graph" href="graph/graph.html#pyracmon.graph.graph.Graph">Graph</a>, <a title="pyracmon.graph.graph.GraphView" href="graph/graph.html#pyracmon.graph.graph.GraphView">GraphView</a>]) ‑> <a title="pyracmon.graph.graph.Graph" href="graph/graph.html#pyracmon.graph.graph.Graph">Graph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a graph from a template.</p>
<p>Use this function instead of invoking constructor directly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template</code></strong></dt>
<dd>A template of a graph.</dd>
<dt><strong><code>bases</code></strong></dt>
<dd>Other graphs whose nodes are appended to created graph.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Created graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_graph(template: GraphTemplate, *bases: Union[Graph, GraphView]) -&gt; Graph:
    &#34;&#34;&#34;
    Create a graph from a template.

    Use this function instead of invoking constructor directly.

    Args:
        template: A template of a graph.
        bases: Other graphs whose nodes are appended to created graph.
    Returns:
        Created graph.
    &#34;&#34;&#34;
    graph = Graph(template)

    for b in bases:
        graph += b

    return graph</code></pre>
</details>
</dd>
<dt id="pyracmon.order_by"><code class="name flex">
<span>def <span class="ident">order_by</span></span>(<span>columns: collections.abc.Mapping[typing.Union[str, <a title="pyracmon.select.AliasedColumn" href="select.html#pyracmon.select.AliasedColumn">AliasedColumn</a>], typing.Union[bool, tuple[bool, bool], str]], **defaults: Union[bool, tuple[bool, bool], str]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generates <code>ORDER BY</code> clause from columns and directions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>columns</code></strong></dt>
<dd>Columns and directions. Iteration order is kept in rendered clause.</dd>
<dt><strong><code>defaults</code></strong></dt>
<dd>Column names and directions appended to the clause if the column is not contained in <code>columns</code> .</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>ORDER BY</code> clause.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_by(columns: Mapping[Union[str, AliasedColumn], ORDER], **defaults: ORDER) -&gt; str:
    &#34;&#34;&#34;
    Generates `ORDER BY` clause from columns and directions.

    Args:
        columns: Columns and directions. Iteration order is kept in rendered clause.
        defaults: Column names and directions appended to the clause if the column is not contained in `columns` .
    Returns:
        `ORDER BY` clause.
    &#34;&#34;&#34;
    columns = dict(columns, **{c:v for c,v in defaults.items() if c not in columns})
    def col(cd):
        if isinstance(cd[1], bool):
            return f&#34;{cd[0]} ASC&#34; if cd[1] else f&#34;{cd[0]} DESC&#34;
        elif isinstance(cd[1], str):
            return f&#34;{cd[0]} {cd[1]}&#34;
        elif isinstance(cd[1], tuple) and len(cd[1]) == 2:
            return f&#34;{cd[0]} {&#39;ASC&#39; if cd[1][0] else &#39;DESC&#39;} NULLS {&#39;FIRST&#39; if cd[1][1] else &#39;LAST&#39;}&#34;
        else:
            raise ValueError(f&#34;Directions must be specified by bool, pair of bools or string: {cd[1]}&#34;)
    return &#39;&#39; if len(columns) == 0 else f&#34;ORDER BY {&#39;, &#39;.join(map(col, columns.items()))}&#34;</code></pre>
</details>
</dd>
<dt id="pyracmon.ranged_by"><code class="name flex">
<span>def <span class="ident">ranged_by</span></span>(<span>limit: Optional[int] = None, offset: Optional[int] = None) ‑> tuple[str, list[typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates <code>LIMIT OFFSET</code> clause using marker.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>limit</code></strong></dt>
<dd>Limit value. <code>None</code> means no limitation.</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>Offset value. <code>None</code> means <code>0</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>LIMIT OFFSET</code> clause and its parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ranged_by(limit: Optional[int] = None, offset: Optional[int] = None) -&gt; tuple[str, list[Any]]:
    &#34;&#34;&#34;
    Generates `LIMIT OFFSET` clause using marker.

    Args:
        limit: Limit value. `None` means no limitation.
        offset: Offset value. `None` means `0`.
    Returns:
        `LIMIT OFFSET` clause and its parameters.
    &#34;&#34;&#34;
    clause, params = [], []

    if limit is not None:
        clause.append(&#34;LIMIT $_&#34;)
        params.append(limit)

    if offset is not None:
        clause.append(&#34;OFFSET $_&#34;)
        params.append(offset)

    return &#39; &#39;.join(clause) if clause else &#39;&#39;, params</code></pre>
</details>
</dd>
<dt id="pyracmon.read_row"><code class="name flex">
<span>def <span class="ident">read_row</span></span>(<span>row, *selections: Union[<a title="pyracmon.select.Consumable" href="select.html#pyracmon.select.Consumable">Consumable</a>, str, tuple], allow_redundancy: bool = False) ‑> <a title="pyracmon.select.RowValues" href="select.html#pyracmon.select.RowValues">RowValues</a></span>
</code></dt>
<dd>
<div class="desc"><p>Read values in a row according to given selections.</p>
<p>This function returns <code>RowValues</code> where each value is created by each selection respectively.
The type of the selection determines how values in the row are handled:</p>
<ul>
<li><code>Selection</code> consumes as many values as the number of columns in it and creates a model instance.</li>
<li>Empty tuple or a string consumes a value, which is stored in <code>RowValues</code> as it is.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>selections</code></strong></dt>
<dd>List of selections or their equivalents.</dd>
<dt><strong><code>allow_redundancy</code></strong></dt>
<dd>If <code>False</code>, <code>ValueError</code> is thrown when not all values in a row are consumed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Values read from the row accoding to the selections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_row(row, *selections: Union[Consumable, str, tuple], allow_redundancy: bool = False) -&gt; RowValues:
    &#34;&#34;&#34;
    Read values in a row according to given selections.

    This function returns `RowValues` where each value is created by each selection respectively.
    The type of the selection determines how values in the row are handled:

    - `Selection` consumes as many values as the number of columns in it and creates a model instance.
    - Empty tuple or a string consumes a value, which is stored in `RowValues` as it is.

    Args:
        selections: List of selections or their equivalents.
        allow_redundancy: If `False`, `ValueError` is thrown when not all values in a row are consumed.
    Returns:
        Values read from the row accoding to the selections.
    &#34;&#34;&#34;
    consumables = [Consumable.to_consumable(s) for s in selections]

    result = RowValues(consumables)

    for s in consumables:
        result.append(s.consume(row))
        row = row[len(s):]

    if not allow_redundancy and len(row) &gt; 0:
        raise ValueError(&#34;Not all elements in row is consumed.&#34;)

    return result</code></pre>
</details>
</dd>
<dt id="pyracmon.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>length_or_key_gen: Union[int, collections.abc.Sequence[collections.abc.Callable[[int], Union[str, int, NoneType, <a title="pyracmon.query.Expression" href="query.html#pyracmon.query.Expression">Expression</a>]]]], rows: int, qualifier: Optional[collections.abc.Mapping[int, collections.abc.Callable[[str], str]]] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generates partial query string for <code>VALUES</code> clause in insertion query.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>length_or_key_gen</code></strong></dt>
<dd>The number of placeholders or list of functions taking row index and returning key for each placeholder.</dd>
<dt><strong><code>rows</code></strong></dt>
<dd>The number of rows to insert.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Qualifying function for each index.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Query string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(length_or_key_gen: Union[int, Sequence[Callable[[int], HolderKeys]]], rows: int, qualifier: Optional[Mapping[int, Qualifier]] = None) -&gt; str:
    &#34;&#34;&#34;
    Generates partial query string for `VALUES` clause in insertion query.

    Args:
        length_or_key_gen: The number of placeholders or list of functions taking row index and returning key for each placeholder.
        rows: The number of rows to insert.
        qualifier: Qualifying function for each index.
    Returns:
        Query string.
    &#34;&#34;&#34;
    if isinstance(length_or_key_gen, int):
        lok = lambda i: length_or_key_gen
    else:
        lok = lambda i: [g(i) for g in length_or_key_gen] # type: ignore

    return &#39;, &#39;.join([f&#34;({holders(lok(i), qualifier)})&#34; for i in range(rows)])</code></pre>
</details>
</dd>
<dt id="pyracmon.walk_schema"><code class="name flex">
<span>def <span class="ident">walk_schema</span></span>(<span>td, with_doc=False) ‑> dict[str, typing.Union[type, typing.Annotated]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary as a result of walking a schema object from its root.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>td</code></strong></dt>
<dd>A schema represented by <code>TypedDict</code>.</dd>
<dt><strong><code>with_doc</code></strong></dt>
<dd>Flag to include documentations into result.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Key value representation of the schema. If <code>with_doc</code> is <code>True</code>, each value is <code>Annotated</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walk_schema(td, with_doc=False) -&gt; dict[str, Union[type, Annotated]]:
    &#34;&#34;&#34;
    Returns a dictionary as a result of walking a schema object from its root.

    Args:
        td: A schema represented by `TypedDict`.
        with_doc: Flag to include documentations into result.
    Returns:
        Key value representation of the schema. If `with_doc` is `True`, each value is `Annotated`.
    &#34;&#34;&#34;
    if &#39;__annotations__&#39; not in td.__dict__:
        return {}

    result = {}

    def put(k, t, doc):
        if with_doc:
            result[k] = (t, doc)
        else:
            result[k] = t

    def expand(t):
        return (get_args(t)[0], lambda x:[x]) if issubgeneric(t, list) else (t, lambda x:x)

    for k, t in get_type_hints(td, include_extras=True).items():
        t, doc = decompose_document(t)

        t, conv = expand(t)

        opt_type = is_optional(t)

        if is_typeddict(t):
            put(k, conv(walk_schema(t, with_doc)), doc)
        elif opt_type is not None and is_typeddict(opt_type):
            put(k, conv(walk_schema(opt_type, with_doc)), doc)
        else:
            put(k, conv(t), doc)
    
    return result</code></pre>
</details>
</dd>
<dt id="pyracmon.where"><code class="name flex">
<span>def <span class="ident">where</span></span>(<span>condition: <a title="pyracmon.Conditional" href="#pyracmon.Conditional">Conditional</a>) ‑> tuple[str, list[typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a <code>WHERE</code> clause and parameters representing given condition.</p>
<p>If the condition is empty, returned clause is an empty string which does not contain <code>WHERE</code> keyword.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>condition</code></strong></dt>
<dd>Condition object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple of <code>WHERE</code> clause and parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def where(condition: &#39;Conditional&#39;) -&gt; tuple[str, list[Any]]:
    &#34;&#34;&#34;
    Generates a `WHERE` clause and parameters representing given condition.

    If the condition is empty, returned clause is an empty string which does not contain `WHERE` keyword.

    Args:
        condition: Condition object.
    Returns:
        Tuple of `WHERE` clause and parameters.
    &#34;&#34;&#34;
    return (&#39;&#39;, []) if condition.expression == &#39;&#39; else (f&#39;WHERE {condition.expression}&#39;, condition.params)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyracmon.CRUDMixin"><code class="flex name class">
<span>class <span class="ident">CRUDMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Default mixin providing class methods available on all model types.</p>
<p>Every method takes the DB connection object as its first argument.
Following arguments are defined in several methods commonly.</p>
<ul>
<li><code>pks</code><ul>
<li>Names and values of all primary key columns in form of <code>dict</code> .</li>
<li>A primary key value. This form is allowed when the table has just one primary key column.</li>
<li>e.g. If the table has a single primary key <code>id</code> of int, <code>1</code> is available to spcecify the row of <code>id = 1</code> .</li>
<li>e.g. If the table has multiple primary keys <code>intid</code> and <code>strid</code>, <code>dict(intid=1, strid="abc")</code> is a valid argument.</li>
</ul>
</li>
<li><code>record</code><ul>
<li>A model object or a mapping from column name to its value, which corresponds to a table row.</li>
<li>Only columns contained in the record is affected by the operation.</li>
<li>e.g. When <code>dict(c1=1, c2="abc")</code> is passed for insertion, only <code>c1</code> and <code>c2</code> are set in INSERT query.</li>
<li>e.g. For update, only the columns will be updated. Other columns are not affected.</li>
</ul>
</li>
<li><code>condition</code><ul>
<li>Query condition which will compose WHERE clause.</li>
<li><code><a title="pyracmon.query.Q" href="query.html#pyracmon.query.Q">Q</a></code> is a factory class to create condition object.</li>
<li>When <code>None</code> is passed, all rows are subject to the operation.</li>
</ul>
</li>
<li><code>qualifier</code><ul>
<li>A mapping from column name to a function which qualifies a placeholder passed by an argument.</li>
<li>Detail of qualifier function is described below.</li>
</ul>
</li>
<li><code>lock</code><ul>
<li>This is reserved argument for locking statement but works just as the postfix of the query currently.</li>
<li>The usage will be changed in future version.</li>
</ul>
</li>
</ul>
<p>Qualifier function is used typically to convert or replace placeholder marker in insert/update query.
By default, those queries contain markers like <code>insert into t (c1, c2) values (?, ?)</code> (<code><a title="pyracmon.Q" href="#pyracmon.Q">Q</a></code> parameter style).
We need sometimes qualify markers to apply DB function, calculation, type cast and so on. This feature enables them like below.</p>
<pre><code class="language-python">t.insert(db, dict(c1=1, c2=None), dict(c1=lambda x: f&quot;{x}+1&quot;, c2=lambda x: &quot;now()&quot;))
# SQL: INSERT INTO t (c1, c2) VALUES (?+1, now())
</code></pre>
<p>Be aware that when model object is passed, its column values may differ from actual values in DB after query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CRUDMixin(SelectMixin, CRUDInternalMeta):
    &#34;&#34;&#34;
    Default mixin providing class methods available on all model types.

    Every method takes the DB connection object as its first argument.
    Following arguments are defined in several methods commonly.

    - `pks`
        - Names and values of all primary key columns in form of `dict` .
        - A primary key value. This form is allowed when the table has just one primary key column.
        - e.g. If the table has a single primary key `id` of int, `1` is available to spcecify the row of `id = 1` .
        - e.g. If the table has multiple primary keys `intid` and `strid`, `dict(intid=1, strid=&#34;abc&#34;)` is a valid argument.
    - `record`
        - A model object or a mapping from column name to its value, which corresponds to a table row.
        - Only columns contained in the record is affected by the operation.
        - e.g. When `dict(c1=1, c2=&#34;abc&#34;)` is passed for insertion, only `c1` and `c2` are set in INSERT query.
        - e.g. For update, only the columns will be updated. Other columns are not affected.
    - `condition`
        - Query condition which will compose WHERE clause.
        - `pyracmon.query.Q` is a factory class to create condition object.
        - When `None` is passed, all rows are subject to the operation.
    - `qualifier`
        - A mapping from column name to a function which qualifies a placeholder passed by an argument.
        - Detail of qualifier function is described below.
    - `lock`
        - This is reserved argument for locking statement but works just as the postfix of the query currently.
        - The usage will be changed in future version.

    Qualifier function is used typically to convert or replace placeholder marker in insert/update query.
    By default, those queries contain markers like `insert into t (c1, c2) values (?, ?)` (`Q` parameter style).
    We need sometimes qualify markers to apply DB function, calculation, type cast and so on. This feature enables them like below.

    ```python
    t.insert(db, dict(c1=1, c2=None), dict(c1=lambda x: f&#34;{x}+1&#34;, c2=lambda x: &#34;now()&#34;))
    # SQL: INSERT INTO t (c1, c2) VALUES (?+1, now())
    ```

    Be aware that when model object is passed, its column values may differ from actual values in DB after query.
    &#34;&#34;&#34;
    @classmethod
    def count(cls, db: Connection, condition: Conditional = Q.of()) -&gt; int:
        &#34;&#34;&#34;
        Count rows which satisfies the condition.

        ```python
        t.count(db, Q.eq(c1=1))
        # SQL: SELECT COUNT(*) FROM t WHERE c1 = 1
        ```

        Args:
            db: DB connection.
            condition: Query condition.
        Returns:
            The number of rows.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        c = db.stmt().execute(f&#34;SELECT COUNT(*) FROM {cls.name}{_spacer(wc)}&#34;, *wp)
        return c.fetchone()[0] # type: ignore

    @classmethod
    def fetch(cls, db: Connection, pks: PKS, lock: Optional[Any] = None) -&gt; Optional[Self]:
        &#34;&#34;&#34;
        Fetch a record by primary key(s).

        ```python
        t.fetch(db, 1)
        # SQL: SELECT * FROM t WHERE id = 1
        ```

        Args:
            db: DB connection.
            pks: Primary key value(s).
            lock: Locking statement.
        Returns:
            A model object if exists, otherwise `None`.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)
        cond = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
        wc, wp = where(cond)
        s = cls.select()
        c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}&#34;, *wp)
        row = c.fetchone()
        return read_row(row, *s)[0] if row else None

    @classmethod
    def fetch_many(cls, db: Connection, seq_pks: Sequence[PKS], lock: Optional[Any] = None, /, per_page: int = 1000) -&gt; list[Self]:
        &#34;&#34;&#34;
        Fetch a record by sequence of primary key(s).

        This method simply concatenates equality conditions on primary key by OR operator.

        ```python
        t.fetch_many(db, [1, 2, 3])
        # SQL: SELECT * FROM t WHERE id = 1 OR id = 2 OR id = 3
        ```

        Args:
            db: DB connection.
            seq_pks: Sequence of primary key value.
            lock: Locking statement.
            per_page: Maximum number of keys for an execution of query.
        Returns:
            Model objects in the same order as passed sequence.
        &#34;&#34;&#34;
        res = []
        index = 0
        while index &lt; len(seq_pks):
            ordered_pks = []
            cond = Q.of()
            for pks in seq_pks[index:index+per_page]:
                cols, vals = parse_pks(cls, pks)
                ordered_pks.append(tuple(v for v in vals))
                cond |= Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
            wc, wp = where(cond)
            s = cls.select()
            c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}&#34;, *wp)

            record_map = {}
            for r in [read_row(row, *s)[0] for row in c.fetchall()]:
                pk_values = {c.name:v for c, v in r if c.pk}
                record_map[tuple([v for _, v in check_columns(cls, pk_values, lambda c: c.pk, True)])] = r

            res.extend([record_map[k] for k in ordered_pks if k in record_map])
            index += per_page

        return res

    @classmethod
    def fetch_where(
        cls,
        db: Connection,
        condition: Conditional = Q.of(),
        orders: Mapping[Union[str, AliasedColumn], ORDER] = {},
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        lock: Optional[Any] = None,
    ) -&gt; list[Self]:
        &#34;&#34;&#34;
        Fetch records which satisfy the condition.

        ```python
        t.fetch_where(db, Q.eq(c1=1), dict(c2=True), 10, 5)
        # SQL: SELECT * FROM t WHERE c1 = 1 ORDER BY c2 ASC LIMIT 10 OFFSET 5
        ```

        Args:
            db: DB connection.
            condition: Query condition.
            orders: Ordering specification where key is column name and value denotes whether the order is ascending or not.
            limit: Maximum nuber of rows to fetch. If `None`, all rows are returned.
            offset: The number of rows to skip.
            lock: Locking statement.
        Returns:
            Model objects.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        rc, rp = ranged_by(limit, offset)
        s = cls.select()
        c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(order_by(orders))}{_spacer(rc)}{_spacer(lock)}&#34;, *(wp + rp))
        return [read_row(row, *s)[0] for row in c.fetchall()]

    @classmethod
    def fetch_one(
        cls,
        db: Connection,
        condition: Conditional = Q.of(),
        lock: Optional[Any] = None,
    ) -&gt; Optional[Self]:
        &#34;&#34;&#34;
        Fetch a record which satisfies the condition.

        `ValueError` raises When multiple records are found.
        Use this method for queries which certainly returns a single row, such as search by unique key.

        ```python
        t.fetch_one(db, Q.eq(c1=1))
        # SQL: SELECT * FROM t WHERE c1 = 1
        ```

        Args:
            db: DB connection.
            condition: Query condition.
            lock: Locking statement.
        Returns:
            Model objects If exists, otherwise `None`.
        &#34;&#34;&#34;
        rs = cls.fetch_where(db, condition, lock=lock)

        if not rs:
            return None
        elif len(rs) == 1:
            return rs[0]
        else:
            raise ValueError(f&#34;{len(rs)} records are found on the invocation of fetch_one().&#34;)

    @classmethod
    def _insert_sql(cls, record: Union[Self, dict[str, Any]], qualifier: Mapping[str, Qualifier] = {}) -&gt; tuple[str, list[str], list[Any]]:
        model: Self = cast(Self, record) if isinstance(record, cls) else cls(**cast(dict, record))
        value_dict = model_values(cls, model)
        check_columns(cls, value_dict)
        cols, vals = list(value_dict.keys()), list(value_dict.values())
        ordered_qs = key_to_index(qualifier, cols)

        def exp(v):
            return lambda i: v

        if any(isinstance(v, Expression) for v in vals):
            key_gen = []
            org_vals = vals
            vals = []
            for v in org_vals:
                if isinstance(v, Expression):
                    key_gen.append(exp(v))
                    vals.extend(v.params)
                else:
                    key_gen.append(lambda i: None)
                    vals.append(v)
            values_clause = values(key_gen, 1, ordered_qs)
        else:
            values_clause = values(len(cols), 1, ordered_qs)

        return f&#34;INSERT INTO {cls.name} ({&#39;, &#39;.join(cols)}) VALUES {values_clause}&#34;, cols, vals

    @classmethod
    def insert(
        cls,
        db: Connection,
        record: Union[Self, dict[str, Any]],
        qualifier: Mapping[str, Qualifier] = {},
        /,
        returning: bool = False,
    ) -&gt; Self:
        &#34;&#34;&#34;
        Insert a record.

        If `returning` is `True` and the DBMS supports **RETURNING** clause,
        returned model object contains comple and correct column values.
        Otherwise, auto incremental value is set to the returned model object
        but other column values generated inside DBMS such as default value are not set.

        ```python
        t.insert(db, dict(c1=1, c2=2))
        # SQL: INSERT INTO t (c1, c2) VALUES (1, 2)
        ```

        Args:
            db: DB connection.
            record: Object contains column values.
            qualifier: Functions qualifying placeholder markers.
            returning: Flag to return inserted record with complete and correct column values.
        Returns:
            Model of inserted record.
        &#34;&#34;&#34;
        model: Self = cast(Self, record) if isinstance(record, cls) else cls(**cast(dict, record))
        sql, _, vals = cls._insert_sql(record, qualifier)

        if returning:
            if cls.support_returning(db):
                c = db.stmt().execute(f&#34;{sql} RETURNING *&#34;, *vals)
                s = cls.select()
                return read_row(c.fetchone(), *s)[0]
            else:
                # REVIEW
                # Inserted row can&#39;t be specified from the table where no primary keys are defined .
                pass

        db.stmt().execute(sql, *vals)
        for c, v in cls.last_sequences(db, 1):
            setattr(model, c.name, v)
        return model

    @classmethod
    @overload
    def insert_many(cls, db: Connection, records: list[Union[Self, dict[str, Any]]], qualifier: Mapping[str, Qualifier] = {},
                    /, returning: Literal[False] = False) -&gt; list[Self]: ...
    @classmethod
    @overload
    def insert_many(cls, db: Connection, records: list[Union[Self, dict[str, Any]]], qualifier: Mapping[str, Qualifier] = {},
                    /, returning: Literal[True] = True) -&gt; list[Self]: ...
    @classmethod
    def insert_many(
        cls,
        db: Connection,
        records: list[Union[Self, dict[str, Any]]],
        qualifier: Mapping[str, Qualifier] = {},
        /,
        returning: bool = False,
    ):
        &#34;&#34;&#34;
        Insert records.

        If `returning` is `True` and the DBMS supports **RETURNING** clause,
        returned model object contains comple and correct column values.
        Otherwise, auto incremental value is set to the returned model object
        but other column values generated inside DBMS such as default value are not set.

        Args:
            db: DB connection.
            record: Object contains column values.
            qualifier: Functions qualifying placeholder markers.
            returning: Flag to return inserted records with complete and correct column values.
        Returns:
            Models of inserted records or cursor.
        &#34;&#34;&#34;
        if len(records) == 0:
            return []

        models: list[Self] = [cast(Self, r) if isinstance(r, cls) else cls(**cast(dict, r)) for r in records]

        seq_of_params = []

        sql, cols, params = cls._insert_sql(models[0], qualifier)

        cols = set(cols)
        seq_of_params.append(params)

        for m in models[1:]:
            value_dict = model_values(cls, m)
            check_columns(cls, value_dict, lambda c: c.name in cols, requires_all=True)
            # REVIEW:
            # The consistency among columns where expression is set is not checked.
            _, _, params = cls._insert_sql(m, qualifier)
            seq_of_params.append(params)

        db.stmt().executemany(sql, seq_of_params)
        num = len(records)
        for c, v in cls.last_sequences(db, num):
            for i, m in enumerate(models):
                setattr(m, c.name, v - (num - i - 1))

        if returning:
            seq_pks = [extract_pks(cls, m) for m in models]
            return cls.fetch_many(db, seq_pks)
        else:
            return models

    @classmethod
    def _update_sql(cls, record: Record, condition: Conditional, qualifier: Mapping[str, Qualifier] = {}, allow_all: bool = True) -&gt; tuple[str, list[str], list[Any]]:
        value_dict = model_values(cls, record, excludes_pk=True)
        check_columns(cls, value_dict)
        cols, vals = list(value_dict.keys()), list(value_dict.values())
        ordered_qs = key_to_index(qualifier, cols)

        def set_col(acc, icv):
            i, (c, v) = icv
            if isinstance(v, Expression):
                clause = f&#34;{c} = {ordered_qs.get(i, lambda x:x)(v.expression)}&#34;
                params = v.params
            else:
                clause = f&#34;{c} = {ordered_qs.get(i, lambda x:x)(&#39;$_&#39;)}&#34;
                params = [v]
            acc[0].append(clause)
            acc[1].extend(params)
            return acc

        setters, params = reduce(set_col, enumerate(zip(cols, vals)), ([], []))

        wc, wp = where(condition)
        if wc == &#34;&#34; and not allow_all:
            raise ValueError(&#34;Update query to update all records is not allowed.&#34;)

        return f&#34;UPDATE {cls.name} SET {&#39;, &#39;.join(setters)}{_spacer(wc)}&#34;, cols, params + wp

    @classmethod
    @overload
    def update(cls, db: Connection, pks: PKS, record: Record, qualifier: Mapping[str, Qualifier] = {},
               /, returning: Literal[False] = False) -&gt; bool: ...
    @classmethod
    @overload
    def update(cls, db: Connection, pks: PKS, record: Record, qualifier: Mapping[str, Qualifier] = {},
               /, returning: Literal[True] = True) -&gt; Optional[Self]: ...
    @classmethod
    def update(
        cls,
        db: Connection,
        pks: PKS,
        record: Record,
        qualifier: Mapping[str, Qualifier] = {},
        /,
        returning: bool = False,
    ):
        &#34;&#34;&#34;
        Update a record by primary key(s).

        This method only updates columns which are found in `record` except for primary key(s).

        ```python
        t.update(db, 1, dict(c1=1, c2=2))
        # SQL: UPDATE t SET c1 = 1, c2 = 2 WHERE id = 1
        ```

        Args:
            db: DB connection.
            pks: Primary key value(s).
            record: Object contains column values.
            qualifier: Functions qualifying placeholder markers.
            returning: Flag to return updated records with complete and correct column values.
        Returns:
            Whether the record exists and updated or updated record model.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)
        condition = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
        if returning:
            if cls.support_returning(db):
                models = cls.update_where(db, record, condition, qualifier, returning=True)
                return models[0] if models else None
            else:
                models = cls.update_where(db, record, condition, qualifier, returning=False)
                return cls.fetch(db, pks)
        else:
            return cls.update_where(db, record, condition, qualifier, returning=False) == 1

    @classmethod
    @overload
    def update_many(cls, db: Connection, records: Sequence[Record], qualifier: Mapping[str, Qualifier] = {},
               /, returning: Literal[False] = False) -&gt; int: ...
    @classmethod
    @overload
    def update_many(cls, db: Connection, records: Sequence[Record], qualifier: Mapping[str, Qualifier] = {},
               /, returning: Literal[True] = True) -&gt; list[Self]: ...
    @classmethod
    def update_many(
        cls,
        db: Connection,
        records: Sequence[Record],
        qualifier: Mapping[str, Qualifier] = {},
        /,
        returning: bool = False,
    ):
        &#34;&#34;&#34;
        Update records by set of primary key(s).

        This method invokes on `executemany` defined in DB-API 2.0.
        Whether it is optimized compared to `execute` depends on DB driver.

        Args:
            db: DB connection.
            record: Sequence of objects contains column values.
            qualifier: Functions qualifying placeholder markers.
            returning: Flag to return updated records with complete and correct column values.
        Returns:
            The number of affected rows or updated records.
        &#34;&#34;&#34;
        if len(records) == 0:
            return [] if returning else 0

        keys = {c.name for c in cls.columns if c.pk}
        if len(keys) == 0:
            raise ValueError(f&#34;update_many is not available because {cls} does not have primary key columns.&#34;)

        def classify(acc: tuple[dict[str, Any], dict[str, Any]], cv: tuple[str, Any]):
            if cv[0] in keys:
                acc[0][cv[0]] = cv[1]
            else:
                acc[1][cv[0]] = cv[1]
            return acc

        seq_of_values: list[tuple[dict[str, Any], dict[str, Any]]] = []
        target_columns: Optional[set[str]] = None

        for vs in [model_values(cls, r, excludes_pk=False) for r in records]:
            if not keys &lt; vs.keys():
                raise ValueError(f&#34;Every row must contain values of all primary keys and at least one update column value.&#34;)
            pks, rec = reduce(classify, vs.items(), ({}, {}))
            if target_columns is None:
                check_columns(cls, rec)
                target_columns = set(rec.keys())
            else:
                check_columns(cls, rec, lambda c: c.name in target_columns, True) # type: ignore
            seq_of_values.append((pks, rec))

        sql_first = &#34;&#34;
        seq_of_params: list[list[Any]] = []

        for pks, rec in seq_of_values:
            cols, vals = parse_pks(cls, pks)
            condition = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])

            sql, _, params = cls._update_sql(rec, condition, qualifier)
            if not sql_first:
                sql_first = sql
            seq_of_params.append(params)

        if returning:
            db.stmt().executemany(f&#34;{sql_first}&#34;, seq_of_params)
            return cls.fetch_many(db, [pks for pks, _ in seq_of_values])
        else:
            return db.stmt().executemany(sql_first, seq_of_params).rowcount

    @classmethod
    @overload
    def update_where(cls, db: Connection, record: Record, condition: Conditional, qualifier: Mapping[str, Qualifier] = {},
                     /, returning: Literal[False] = False, allow_all: bool = False) -&gt; int: ...
    @classmethod
    @overload
    def update_where(cls, db: Connection, record: Record, condition: Conditional, qualifier: Mapping[str, Qualifier] = {},
                     /, returning: Literal[True] = True, allow_all: bool = False) -&gt; list[Self]: ...
    @classmethod
    def update_where(
        cls,
        db: Connection,
        record: Record,
        condition: Conditional,
        qualifier: Mapping[str, Qualifier] = {},
        /,
        returning: bool = False,
        allow_all: bool = True,
    ):
        &#34;&#34;&#34;
        Update records which satisfy the condition.

        ```python
        t.update(db, dict(c2=2), Q.eq(c1=1))
        # SQL: UPDATE t SET c2 = 2 WHERE c1 = 1
        ```

        Args:
            db: DB connection.
            record: Object contains column values.
            condition: Query condition.
            qualifier: Functions qualifying placeholder markers.
            returning: Flag to return updated records with complete and correct column values.
            allow_all: If `False`, empty condition raises `ValueError`.
        Returns:
            The number of affected rows or updated records.
        &#34;&#34;&#34;
        sql, _, params = cls._update_sql(record, condition, qualifier, allow_all)

        if returning:
            if cls.support_returning(db):
                c = db.stmt().execute(f&#34;{sql} RETURNING *&#34;, *params)
                s = cls.select()
                return [read_row(row, *s)[0] for row in c.fetchall()]
            else:
                raise NotImplementedError(f&#34;RETURNING is not supported and there is no way to fetch updated rows exactly.&#34;)
        else:
            c = db.stmt().execute(sql, *params)

            return c.rowcount

    @classmethod
    @overload
    def delete(cls, db: Connection, pks: PKS, /, returning: Literal[False] = False) -&gt; bool: ...
    @classmethod
    @overload
    def delete(cls, db: Connection, pks: PKS, /, returning: Literal[True] = True) -&gt; Optional[Self]: ...
    @classmethod
    def delete(cls, db: Connection, pks: PKS, /, returning: bool = False):
        &#34;&#34;&#34;
        Delete a record by primary key(s).

        ```python
        t.delete(db, 1)
        # SQL: DELETE FROM t WHERE id = 1
        ```

        Args:
            db: DB connection.
            pks: Primary key value(s).
            returning: Flag to return deleted record if any.
        Returns:
            Whether the record exists and deleted or delete record if any.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)

        if returning:
            models = cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)]), returning=True)
            return models[0] if models else None
        else:
            return cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])) == 1

    @classmethod
    @overload
    def delete_many(cls, db: Connection, pks: Union[Sequence[PKS], Sequence[Record]], /, returning: Literal[False] = False) -&gt; int: ...
    @overload
    @classmethod
    def delete_many(cls, db: Connection, pks: Union[Sequence[PKS], Sequence[Record]], /, returning: Literal[True] = True) -&gt; list[Self]: ...
    @classmethod
    def delete_many(cls, db: Connection, pks: Union[Sequence[PKS], Sequence[Record]], /, returning: bool = False):
        &#34;&#34;&#34;
        Delete a records by set of primary key(s).

        This method invokes on `executemany` defined in DB-API 2.0.
        Whether it is optimized compared to `execute` depends on DB driver.

        Args:
            db: DB connection.
            pks: Primary keys or objects each of which contains values of all primary keys.
            returning: Flag to return deleted records.
        Returns:
            The number of affected rows or deleted records.
        &#34;&#34;&#34;
        if len(pks) == 0:
            return None

        seq_of_pks: list[dict[str, Any]] = []
        for rec in pks:
            if isinstance(rec, (dict, cls)):
                seq_of_pks.append(extract_pks(cls, rec))
            else:
                cols, vals = parse_pks(cls, rec)
                seq_of_pks.append(dict(zip(cols, vals)))

        condition = Conditional.all([Q.eq(**{c: v}) for c, v in seq_of_pks[0].items()])
        wc, wp = where(condition)

        sql = f&#34;DELETE FROM {cls.name}{_spacer(wc)}&#34;
        seq_of_params: list[list[Any]] = [wp]

        for v in seq_of_pks[1:]:
            condition = Conditional.all([Q.eq(**{c: v}) for c, v in v.items()])
            _, wp = where(condition)
            seq_of_params.append(wp)

        if returning:
            models = cls.fetch_many(db, seq_of_pks)
            db.stmt().executemany(sql, seq_of_params)
            return models
        else:
            return db.stmt().executemany(sql, seq_of_params).rowcount

    @classmethod
    @overload
    def delete_where(cls, db: Connection, condition: Conditional, /, returning: Literal[False] = False, allow_all: bool = True) -&gt; int: ...
    @classmethod
    @overload
    def delete_where(cls, db: Connection, condition: Conditional, /, returning: Literal[True] = True, allow_all: bool = True) -&gt; list[Self]: ...
    @classmethod
    def delete_where(cls, db: Connection, condition: Conditional, /, returning: bool = False, allow_all: bool = True):
        &#34;&#34;&#34;
        Delete records which satisfy the condition.

        ```python
        t.delete(db, Q.eq(c1=1))
        # SQL: DELETE FROM t WHERE c1 = 1
        ```

        Args:
            db: DB connection.
            condition: Query condition.
            returning: Flag to return deleted records.
            allow_all: If `False`, empty condition raises `ValueError`.
        Returns:
            The number of affected rows or deleted records.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        if wc == &#34;&#34; and not allow_all:
            raise ValueError(&#34;Delete query to delete all records is not allowed.&#34;)

        sql = f&#34;DELETE FROM {cls.name}{_spacer(wc)}&#34;

        if returning:
            if cls.support_returning(db):
                c = db.stmt().execute(f&#34;{sql} RETURNING *&#34;, *wp)
                return [read_row(row, *cls.select())[0] for row in c.fetchall()]
            else:
                current = cls.fetch_where(db, condition)
                c = db.stmt().execute(sql, *wp)
                return current
        else:
            return db.stmt().execute(sql, *wp).rowcount

    @classmethod
    def last_sequences(cls, db: Connection, num: int) -&gt; list[tuple[Column, int]]:
        &#34;&#34;&#34;
        Returns the sequential (auto incremental) values of a table generated by the latest insertion.

        Result contains every sequential columns and their values.
        When the latest query inserts multiple rows, only the last (= biggest) value is returned.

        This method should be overridden by another mixin class defined in dialect module.

        Args:
            db: DB connection.
            num: The number of records inserted by the latest query.
        Returns:
            List of pairs of column and its values.
        &#34;&#34;&#34;
        return []

    @classmethod
    def support_returning(cls, db: Connection) -&gt; bool:
        &#34;&#34;&#34;
        Checks whehter this DBMS support **RETURNING** clause or not.

        Args:
            db: DB connection.
        Returns:
            Whehter this DBMS support **RETURNING** clause or not.
        &#34;&#34;&#34;
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.select.SelectMixin" href="select.html#pyracmon.select.SelectMixin">SelectMixin</a></li>
<li><a title="pyracmon.mixin.CRUDInternalMeta" href="mixin.html#pyracmon.mixin.CRUDInternalMeta">CRUDInternalMeta</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.CRUDMixin.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition: <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a> = Condition: '' -- []) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Count rows which satisfies the condition.</p>
<pre><code class="language-python">t.count(db, Q.eq(c1=1))
# SQL: SELECT COUNT(*) FROM t WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of rows.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def count(cls, db: Connection, condition: Conditional = Q.of()) -&gt; int:
    &#34;&#34;&#34;
    Count rows which satisfies the condition.

    ```python
    t.count(db, Q.eq(c1=1))
    # SQL: SELECT COUNT(*) FROM t WHERE c1 = 1
    ```

    Args:
        db: DB connection.
        condition: Query condition.
    Returns:
        The number of rows.
    &#34;&#34;&#34;
    wc, wp = where(condition)
    c = db.stmt().execute(f&#34;SELECT COUNT(*) FROM {cls.name}{_spacer(wc)}&#34;, *wp)
    return c.fetchone()[0] # type: ignore</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, pks: Union[Any, dict[str, Any]], /, returning: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a record by primary key(s).</p>
<pre><code class="language-python">t.delete(db, 1)
# SQL: DELETE FROM t WHERE id = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>pks</code></strong></dt>
<dd>Primary key value(s).</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return deleted record if any.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the record exists and deleted or delete record if any.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete(cls, db: Connection, pks: PKS, /, returning: bool = False):
    &#34;&#34;&#34;
    Delete a record by primary key(s).

    ```python
    t.delete(db, 1)
    # SQL: DELETE FROM t WHERE id = 1
    ```

    Args:
        db: DB connection.
        pks: Primary key value(s).
        returning: Flag to return deleted record if any.
    Returns:
        Whether the record exists and deleted or delete record if any.
    &#34;&#34;&#34;
    cols, vals = parse_pks(cls, pks)

    if returning:
        models = cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)]), returning=True)
        return models[0] if models else None
    else:
        return cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])) == 1</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.delete_many"><code class="name flex">
<span>def <span class="ident">delete_many</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, pks: Union[collections.abc.Sequence[Union[Any, dict[str, Any]]], collections.abc.Sequence[Union[<a title="pyracmon.model.Meta" href="model.html#pyracmon.model.Meta">Meta</a>, dict[str, Any]]]], /, returning: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a records by set of primary key(s).</p>
<p>This method invokes on <code>executemany</code> defined in DB-API 2.0.
Whether it is optimized compared to <code>execute</code> depends on DB driver.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>pks</code></strong></dt>
<dd>Primary keys or objects each of which contains values of all primary keys.</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return deleted records.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of affected rows or deleted records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete_many(cls, db: Connection, pks: Union[Sequence[PKS], Sequence[Record]], /, returning: bool = False):
    &#34;&#34;&#34;
    Delete a records by set of primary key(s).

    This method invokes on `executemany` defined in DB-API 2.0.
    Whether it is optimized compared to `execute` depends on DB driver.

    Args:
        db: DB connection.
        pks: Primary keys or objects each of which contains values of all primary keys.
        returning: Flag to return deleted records.
    Returns:
        The number of affected rows or deleted records.
    &#34;&#34;&#34;
    if len(pks) == 0:
        return None

    seq_of_pks: list[dict[str, Any]] = []
    for rec in pks:
        if isinstance(rec, (dict, cls)):
            seq_of_pks.append(extract_pks(cls, rec))
        else:
            cols, vals = parse_pks(cls, rec)
            seq_of_pks.append(dict(zip(cols, vals)))

    condition = Conditional.all([Q.eq(**{c: v}) for c, v in seq_of_pks[0].items()])
    wc, wp = where(condition)

    sql = f&#34;DELETE FROM {cls.name}{_spacer(wc)}&#34;
    seq_of_params: list[list[Any]] = [wp]

    for v in seq_of_pks[1:]:
        condition = Conditional.all([Q.eq(**{c: v}) for c, v in v.items()])
        _, wp = where(condition)
        seq_of_params.append(wp)

    if returning:
        models = cls.fetch_many(db, seq_of_pks)
        db.stmt().executemany(sql, seq_of_params)
        return models
    else:
        return db.stmt().executemany(sql, seq_of_params).rowcount</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.delete_where"><code class="name flex">
<span>def <span class="ident">delete_where</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition: <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a>, /, returning: bool = False, allow_all: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete records which satisfy the condition.</p>
<pre><code class="language-python">t.delete(db, Q.eq(c1=1))
# SQL: DELETE FROM t WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return deleted records.</dd>
<dt><strong><code>allow_all</code></strong></dt>
<dd>If <code>False</code>, empty condition raises <code>ValueError</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of affected rows or deleted records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete_where(cls, db: Connection, condition: Conditional, /, returning: bool = False, allow_all: bool = True):
    &#34;&#34;&#34;
    Delete records which satisfy the condition.

    ```python
    t.delete(db, Q.eq(c1=1))
    # SQL: DELETE FROM t WHERE c1 = 1
    ```

    Args:
        db: DB connection.
        condition: Query condition.
        returning: Flag to return deleted records.
        allow_all: If `False`, empty condition raises `ValueError`.
    Returns:
        The number of affected rows or deleted records.
    &#34;&#34;&#34;
    wc, wp = where(condition)
    if wc == &#34;&#34; and not allow_all:
        raise ValueError(&#34;Delete query to delete all records is not allowed.&#34;)

    sql = f&#34;DELETE FROM {cls.name}{_spacer(wc)}&#34;

    if returning:
        if cls.support_returning(db):
            c = db.stmt().execute(f&#34;{sql} RETURNING *&#34;, *wp)
            return [read_row(row, *cls.select())[0] for row in c.fetchall()]
        else:
            current = cls.fetch_where(db, condition)
            c = db.stmt().execute(sql, *wp)
            return current
    else:
        return db.stmt().execute(sql, *wp).rowcount</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, pks: Union[Any, dict[str, Any]], lock: Optional[Any] = None) ‑> Optional[typing_extensions.Self]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a record by primary key(s).</p>
<pre><code class="language-python">t.fetch(db, 1)
# SQL: SELECT * FROM t WHERE id = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>pks</code></strong></dt>
<dd>Primary key value(s).</dd>
<dt><strong><code>lock</code></strong></dt>
<dd>Locking statement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A model object if exists, otherwise <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fetch(cls, db: Connection, pks: PKS, lock: Optional[Any] = None) -&gt; Optional[Self]:
    &#34;&#34;&#34;
    Fetch a record by primary key(s).

    ```python
    t.fetch(db, 1)
    # SQL: SELECT * FROM t WHERE id = 1
    ```

    Args:
        db: DB connection.
        pks: Primary key value(s).
        lock: Locking statement.
    Returns:
        A model object if exists, otherwise `None`.
    &#34;&#34;&#34;
    cols, vals = parse_pks(cls, pks)
    cond = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
    wc, wp = where(cond)
    s = cls.select()
    c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}&#34;, *wp)
    row = c.fetchone()
    return read_row(row, *s)[0] if row else None</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.fetch_many"><code class="name flex">
<span>def <span class="ident">fetch_many</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, seq_pks: collections.abc.Sequence[typing.Union[typing.Any, dict[str, typing.Any]]], lock: Optional[Any] = None, /, per_page: int = 1000) ‑> list[typing_extensions.Self]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a record by sequence of primary key(s).</p>
<p>This method simply concatenates equality conditions on primary key by OR operator.</p>
<pre><code class="language-python">t.fetch_many(db, [1, 2, 3])
# SQL: SELECT * FROM t WHERE id = 1 OR id = 2 OR id = 3
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>seq_pks</code></strong></dt>
<dd>Sequence of primary key value.</dd>
<dt><strong><code>lock</code></strong></dt>
<dd>Locking statement.</dd>
<dt><strong><code>per_page</code></strong></dt>
<dd>Maximum number of keys for an execution of query.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model objects in the same order as passed sequence.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fetch_many(cls, db: Connection, seq_pks: Sequence[PKS], lock: Optional[Any] = None, /, per_page: int = 1000) -&gt; list[Self]:
    &#34;&#34;&#34;
    Fetch a record by sequence of primary key(s).

    This method simply concatenates equality conditions on primary key by OR operator.

    ```python
    t.fetch_many(db, [1, 2, 3])
    # SQL: SELECT * FROM t WHERE id = 1 OR id = 2 OR id = 3
    ```

    Args:
        db: DB connection.
        seq_pks: Sequence of primary key value.
        lock: Locking statement.
        per_page: Maximum number of keys for an execution of query.
    Returns:
        Model objects in the same order as passed sequence.
    &#34;&#34;&#34;
    res = []
    index = 0
    while index &lt; len(seq_pks):
        ordered_pks = []
        cond = Q.of()
        for pks in seq_pks[index:index+per_page]:
            cols, vals = parse_pks(cls, pks)
            ordered_pks.append(tuple(v for v in vals))
            cond |= Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
        wc, wp = where(cond)
        s = cls.select()
        c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}&#34;, *wp)

        record_map = {}
        for r in [read_row(row, *s)[0] for row in c.fetchall()]:
            pk_values = {c.name:v for c, v in r if c.pk}
            record_map[tuple([v for _, v in check_columns(cls, pk_values, lambda c: c.pk, True)])] = r

        res.extend([record_map[k] for k in ordered_pks if k in record_map])
        index += per_page

    return res</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.fetch_one"><code class="name flex">
<span>def <span class="ident">fetch_one</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition: <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a> = Condition: '' -- [], lock: Optional[Any] = None) ‑> Optional[typing_extensions.Self]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a record which satisfies the condition.</p>
<p><code>ValueError</code> raises When multiple records are found.
Use this method for queries which certainly returns a single row, such as search by unique key.</p>
<pre><code class="language-python">t.fetch_one(db, Q.eq(c1=1))
# SQL: SELECT * FROM t WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>lock</code></strong></dt>
<dd>Locking statement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model objects If exists, otherwise <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fetch_one(
    cls,
    db: Connection,
    condition: Conditional = Q.of(),
    lock: Optional[Any] = None,
) -&gt; Optional[Self]:
    &#34;&#34;&#34;
    Fetch a record which satisfies the condition.

    `ValueError` raises When multiple records are found.
    Use this method for queries which certainly returns a single row, such as search by unique key.

    ```python
    t.fetch_one(db, Q.eq(c1=1))
    # SQL: SELECT * FROM t WHERE c1 = 1
    ```

    Args:
        db: DB connection.
        condition: Query condition.
        lock: Locking statement.
    Returns:
        Model objects If exists, otherwise `None`.
    &#34;&#34;&#34;
    rs = cls.fetch_where(db, condition, lock=lock)

    if not rs:
        return None
    elif len(rs) == 1:
        return rs[0]
    else:
        raise ValueError(f&#34;{len(rs)} records are found on the invocation of fetch_one().&#34;)</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.fetch_where"><code class="name flex">
<span>def <span class="ident">fetch_where</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition: <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a> = Condition: '' -- [], orders: collections.abc.Mapping[typing.Union[str, <a title="pyracmon.select.AliasedColumn" href="select.html#pyracmon.select.AliasedColumn">AliasedColumn</a>], typing.Union[bool, tuple[bool, bool], str]] = {}, limit: Optional[int] = None, offset: Optional[int] = None, lock: Optional[Any] = None) ‑> list[typing_extensions.Self]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch records which satisfy the condition.</p>
<pre><code class="language-python">t.fetch_where(db, Q.eq(c1=1), dict(c2=True), 10, 5)
# SQL: SELECT * FROM t WHERE c1 = 1 ORDER BY c2 ASC LIMIT 10 OFFSET 5
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>orders</code></strong></dt>
<dd>Ordering specification where key is column name and value denotes whether the order is ascending or not.</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>Maximum nuber of rows to fetch. If <code>None</code>, all rows are returned.</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>The number of rows to skip.</dd>
<dt><strong><code>lock</code></strong></dt>
<dd>Locking statement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fetch_where(
    cls,
    db: Connection,
    condition: Conditional = Q.of(),
    orders: Mapping[Union[str, AliasedColumn], ORDER] = {},
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    lock: Optional[Any] = None,
) -&gt; list[Self]:
    &#34;&#34;&#34;
    Fetch records which satisfy the condition.

    ```python
    t.fetch_where(db, Q.eq(c1=1), dict(c2=True), 10, 5)
    # SQL: SELECT * FROM t WHERE c1 = 1 ORDER BY c2 ASC LIMIT 10 OFFSET 5
    ```

    Args:
        db: DB connection.
        condition: Query condition.
        orders: Ordering specification where key is column name and value denotes whether the order is ascending or not.
        limit: Maximum nuber of rows to fetch. If `None`, all rows are returned.
        offset: The number of rows to skip.
        lock: Locking statement.
    Returns:
        Model objects.
    &#34;&#34;&#34;
    wc, wp = where(condition)
    rc, rp = ranged_by(limit, offset)
    s = cls.select()
    c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(order_by(orders))}{_spacer(rc)}{_spacer(lock)}&#34;, *(wp + rp))
    return [read_row(row, *s)[0] for row in c.fetchall()]</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, record: Union[typing_extensions.Self, dict[str, Any]], qualifier: collections.abc.Mapping[str, collections.abc.Callable[[str], str]] = {}, /, returning: bool = False) ‑> typing_extensions.Self</span>
</code></dt>
<dd>
<div class="desc"><p>Insert a record.</p>
<p>If <code>returning</code> is <code>True</code> and the DBMS supports <strong>RETURNING</strong> clause,
returned model object contains comple and correct column values.
Otherwise, auto incremental value is set to the returned model object
but other column values generated inside DBMS such as default value are not set.</p>
<pre><code class="language-python">t.insert(db, dict(c1=1, c2=2))
# SQL: INSERT INTO t (c1, c2) VALUES (1, 2)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Object contains column values.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return inserted record with complete and correct column values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model of inserted record.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def insert(
    cls,
    db: Connection,
    record: Union[Self, dict[str, Any]],
    qualifier: Mapping[str, Qualifier] = {},
    /,
    returning: bool = False,
) -&gt; Self:
    &#34;&#34;&#34;
    Insert a record.

    If `returning` is `True` and the DBMS supports **RETURNING** clause,
    returned model object contains comple and correct column values.
    Otherwise, auto incremental value is set to the returned model object
    but other column values generated inside DBMS such as default value are not set.

    ```python
    t.insert(db, dict(c1=1, c2=2))
    # SQL: INSERT INTO t (c1, c2) VALUES (1, 2)
    ```

    Args:
        db: DB connection.
        record: Object contains column values.
        qualifier: Functions qualifying placeholder markers.
        returning: Flag to return inserted record with complete and correct column values.
    Returns:
        Model of inserted record.
    &#34;&#34;&#34;
    model: Self = cast(Self, record) if isinstance(record, cls) else cls(**cast(dict, record))
    sql, _, vals = cls._insert_sql(record, qualifier)

    if returning:
        if cls.support_returning(db):
            c = db.stmt().execute(f&#34;{sql} RETURNING *&#34;, *vals)
            s = cls.select()
            return read_row(c.fetchone(), *s)[0]
        else:
            # REVIEW
            # Inserted row can&#39;t be specified from the table where no primary keys are defined .
            pass

    db.stmt().execute(sql, *vals)
    for c, v in cls.last_sequences(db, 1):
        setattr(model, c.name, v)
    return model</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.insert_many"><code class="name flex">
<span>def <span class="ident">insert_many</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, records: list[typing.Union[typing_extensions.Self, dict[str, typing.Any]]], qualifier: collections.abc.Mapping[str, collections.abc.Callable[[str], str]] = {}, /, returning: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Insert records.</p>
<p>If <code>returning</code> is <code>True</code> and the DBMS supports <strong>RETURNING</strong> clause,
returned model object contains comple and correct column values.
Otherwise, auto incremental value is set to the returned model object
but other column values generated inside DBMS such as default value are not set.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Object contains column values.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return inserted records with complete and correct column values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Models of inserted records or cursor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def insert_many(
    cls,
    db: Connection,
    records: list[Union[Self, dict[str, Any]]],
    qualifier: Mapping[str, Qualifier] = {},
    /,
    returning: bool = False,
):
    &#34;&#34;&#34;
    Insert records.

    If `returning` is `True` and the DBMS supports **RETURNING** clause,
    returned model object contains comple and correct column values.
    Otherwise, auto incremental value is set to the returned model object
    but other column values generated inside DBMS such as default value are not set.

    Args:
        db: DB connection.
        record: Object contains column values.
        qualifier: Functions qualifying placeholder markers.
        returning: Flag to return inserted records with complete and correct column values.
    Returns:
        Models of inserted records or cursor.
    &#34;&#34;&#34;
    if len(records) == 0:
        return []

    models: list[Self] = [cast(Self, r) if isinstance(r, cls) else cls(**cast(dict, r)) for r in records]

    seq_of_params = []

    sql, cols, params = cls._insert_sql(models[0], qualifier)

    cols = set(cols)
    seq_of_params.append(params)

    for m in models[1:]:
        value_dict = model_values(cls, m)
        check_columns(cls, value_dict, lambda c: c.name in cols, requires_all=True)
        # REVIEW:
        # The consistency among columns where expression is set is not checked.
        _, _, params = cls._insert_sql(m, qualifier)
        seq_of_params.append(params)

    db.stmt().executemany(sql, seq_of_params)
    num = len(records)
    for c, v in cls.last_sequences(db, num):
        for i, m in enumerate(models):
            setattr(m, c.name, v - (num - i - 1))

    if returning:
        seq_pks = [extract_pks(cls, m) for m in models]
        return cls.fetch_many(db, seq_pks)
    else:
        return models</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.last_sequences"><code class="name flex">
<span>def <span class="ident">last_sequences</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, num: int) ‑> list[tuple[<a title="pyracmon.model.Column" href="model.html#pyracmon.model.Column">Column</a>, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sequential (auto incremental) values of a table generated by the latest insertion.</p>
<p>Result contains every sequential columns and their values.
When the latest query inserts multiple rows, only the last (= biggest) value is returned.</p>
<p>This method should be overridden by another mixin class defined in dialect module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>num</code></strong></dt>
<dd>The number of records inserted by the latest query.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of pairs of column and its values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def last_sequences(cls, db: Connection, num: int) -&gt; list[tuple[Column, int]]:
    &#34;&#34;&#34;
    Returns the sequential (auto incremental) values of a table generated by the latest insertion.

    Result contains every sequential columns and their values.
    When the latest query inserts multiple rows, only the last (= biggest) value is returned.

    This method should be overridden by another mixin class defined in dialect module.

    Args:
        db: DB connection.
        num: The number of records inserted by the latest query.
    Returns:
        List of pairs of column and its values.
    &#34;&#34;&#34;
    return []</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.support_returning"><code class="name flex">
<span>def <span class="ident">support_returning</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whehter this DBMS support <strong>RETURNING</strong> clause or not.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whehter this DBMS support <strong>RETURNING</strong> clause or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def support_returning(cls, db: Connection) -&gt; bool:
    &#34;&#34;&#34;
    Checks whehter this DBMS support **RETURNING** clause or not.

    Args:
        db: DB connection.
    Returns:
        Whehter this DBMS support **RETURNING** clause or not.
    &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, pks: Union[Any, dict[str, Any]], record: Union[<a title="pyracmon.model.Meta" href="model.html#pyracmon.model.Meta">Meta</a>, dict[str, Any]], qualifier: collections.abc.Mapping[str, collections.abc.Callable[[str], str]] = {}, /, returning: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Update a record by primary key(s).</p>
<p>This method only updates columns which are found in <code>record</code> except for primary key(s).</p>
<pre><code class="language-python">t.update(db, 1, dict(c1=1, c2=2))
# SQL: UPDATE t SET c1 = 1, c2 = 2 WHERE id = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>pks</code></strong></dt>
<dd>Primary key value(s).</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Object contains column values.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return updated records with complete and correct column values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the record exists and updated or updated record model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def update(
    cls,
    db: Connection,
    pks: PKS,
    record: Record,
    qualifier: Mapping[str, Qualifier] = {},
    /,
    returning: bool = False,
):
    &#34;&#34;&#34;
    Update a record by primary key(s).

    This method only updates columns which are found in `record` except for primary key(s).

    ```python
    t.update(db, 1, dict(c1=1, c2=2))
    # SQL: UPDATE t SET c1 = 1, c2 = 2 WHERE id = 1
    ```

    Args:
        db: DB connection.
        pks: Primary key value(s).
        record: Object contains column values.
        qualifier: Functions qualifying placeholder markers.
        returning: Flag to return updated records with complete and correct column values.
    Returns:
        Whether the record exists and updated or updated record model.
    &#34;&#34;&#34;
    cols, vals = parse_pks(cls, pks)
    condition = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
    if returning:
        if cls.support_returning(db):
            models = cls.update_where(db, record, condition, qualifier, returning=True)
            return models[0] if models else None
        else:
            models = cls.update_where(db, record, condition, qualifier, returning=False)
            return cls.fetch(db, pks)
    else:
        return cls.update_where(db, record, condition, qualifier, returning=False) == 1</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.update_many"><code class="name flex">
<span>def <span class="ident">update_many</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, records: collections.abc.Sequence[typing.Union[<a title="pyracmon.model.Meta" href="model.html#pyracmon.model.Meta">Meta</a>, dict[str, typing.Any]]], qualifier: collections.abc.Mapping[str, collections.abc.Callable[[str], str]] = {}, /, returning: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Update records by set of primary key(s).</p>
<p>This method invokes on <code>executemany</code> defined in DB-API 2.0.
Whether it is optimized compared to <code>execute</code> depends on DB driver.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Sequence of objects contains column values.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return updated records with complete and correct column values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of affected rows or updated records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def update_many(
    cls,
    db: Connection,
    records: Sequence[Record],
    qualifier: Mapping[str, Qualifier] = {},
    /,
    returning: bool = False,
):
    &#34;&#34;&#34;
    Update records by set of primary key(s).

    This method invokes on `executemany` defined in DB-API 2.0.
    Whether it is optimized compared to `execute` depends on DB driver.

    Args:
        db: DB connection.
        record: Sequence of objects contains column values.
        qualifier: Functions qualifying placeholder markers.
        returning: Flag to return updated records with complete and correct column values.
    Returns:
        The number of affected rows or updated records.
    &#34;&#34;&#34;
    if len(records) == 0:
        return [] if returning else 0

    keys = {c.name for c in cls.columns if c.pk}
    if len(keys) == 0:
        raise ValueError(f&#34;update_many is not available because {cls} does not have primary key columns.&#34;)

    def classify(acc: tuple[dict[str, Any], dict[str, Any]], cv: tuple[str, Any]):
        if cv[0] in keys:
            acc[0][cv[0]] = cv[1]
        else:
            acc[1][cv[0]] = cv[1]
        return acc

    seq_of_values: list[tuple[dict[str, Any], dict[str, Any]]] = []
    target_columns: Optional[set[str]] = None

    for vs in [model_values(cls, r, excludes_pk=False) for r in records]:
        if not keys &lt; vs.keys():
            raise ValueError(f&#34;Every row must contain values of all primary keys and at least one update column value.&#34;)
        pks, rec = reduce(classify, vs.items(), ({}, {}))
        if target_columns is None:
            check_columns(cls, rec)
            target_columns = set(rec.keys())
        else:
            check_columns(cls, rec, lambda c: c.name in target_columns, True) # type: ignore
        seq_of_values.append((pks, rec))

    sql_first = &#34;&#34;
    seq_of_params: list[list[Any]] = []

    for pks, rec in seq_of_values:
        cols, vals = parse_pks(cls, pks)
        condition = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])

        sql, _, params = cls._update_sql(rec, condition, qualifier)
        if not sql_first:
            sql_first = sql
        seq_of_params.append(params)

    if returning:
        db.stmt().executemany(f&#34;{sql_first}&#34;, seq_of_params)
        return cls.fetch_many(db, [pks for pks, _ in seq_of_values])
    else:
        return db.stmt().executemany(sql_first, seq_of_params).rowcount</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.update_where"><code class="name flex">
<span>def <span class="ident">update_where</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, record: Union[<a title="pyracmon.model.Meta" href="model.html#pyracmon.model.Meta">Meta</a>, dict[str, Any]], condition: <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a>, qualifier: collections.abc.Mapping[str, collections.abc.Callable[[str], str]] = {}, /, returning: bool = False, allow_all: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Update records which satisfy the condition.</p>
<pre><code class="language-python">t.update(db, dict(c2=2), Q.eq(c1=1))
# SQL: UPDATE t SET c2 = 2 WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Object contains column values.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
<dt><strong><code>returning</code></strong></dt>
<dd>Flag to return updated records with complete and correct column values.</dd>
<dt><strong><code>allow_all</code></strong></dt>
<dd>If <code>False</code>, empty condition raises <code>ValueError</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of affected rows or updated records.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def update_where(
    cls,
    db: Connection,
    record: Record,
    condition: Conditional,
    qualifier: Mapping[str, Qualifier] = {},
    /,
    returning: bool = False,
    allow_all: bool = True,
):
    &#34;&#34;&#34;
    Update records which satisfy the condition.

    ```python
    t.update(db, dict(c2=2), Q.eq(c1=1))
    # SQL: UPDATE t SET c2 = 2 WHERE c1 = 1
    ```

    Args:
        db: DB connection.
        record: Object contains column values.
        condition: Query condition.
        qualifier: Functions qualifying placeholder markers.
        returning: Flag to return updated records with complete and correct column values.
        allow_all: If `False`, empty condition raises `ValueError`.
    Returns:
        The number of affected rows or updated records.
    &#34;&#34;&#34;
    sql, _, params = cls._update_sql(record, condition, qualifier, allow_all)

    if returning:
        if cls.support_returning(db):
            c = db.stmt().execute(f&#34;{sql} RETURNING *&#34;, *params)
            s = cls.select()
            return [read_row(row, *s)[0] for row in c.fetchall()]
        else:
            raise NotImplementedError(f&#34;RETURNING is not supported and there is no way to fetch updated rows exactly.&#34;)
    else:
        c = db.stmt().execute(sql, *params)

        return c.rowcount</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyracmon.select.SelectMixin" href="select.html#pyracmon.select.SelectMixin">SelectMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyracmon.select.SelectMixin.select" href="select.html#pyracmon.select.SelectMixin.select">select</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyracmon.Column"><code class="flex name class">
<span>class <span class="ident">Column</span></span>
<span>(</span><span>name: str, ptype: type, type_info: Optional[Any], pk: bool, fk: Optional[<a title="pyracmon.model.Relations" href="model.html#pyracmon.model.Relations">Relations</a>], incremental: Optional[Any], nullable: bool, comment: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a schema of a column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Column:
    &#34;&#34;&#34;
    This class represents a schema of a column.
    &#34;&#34;&#34;
    def __init__(
        self,
        name: str,
        ptype: type,
        type_info: Optional[Any],
        pk: bool,
        fk: Optional[Relations],
        incremental: Optional[Any],
        nullable: bool,
        comment: str = &#34;&#34;,
    ):
        #: Column name.
        self.name = name
        #: Data type in python.
        self.ptype = ptype
        #: Type informations obtained from DB.
        self.type_info = type_info
        #: Is this column a primary key?
        self.pk = pk
        #: Foreign key constraints.
        self.fk = fk
        #: If this column is auto-incremental, this object contains the information of the feature, otherwise, `None`.
        self.incremental = incremental
        #: Can this column contain null?
        self.nullable = nullable
        #: Comment of the column.
        self.comment = comment</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.Column.comment"><code class="name">var <span class="ident">comment</span></code></dt>
<dd>
<div class="desc"><p>Comment of the column.</p></div>
</dd>
<dt id="pyracmon.Column.fk"><code class="name">var <span class="ident">fk</span></code></dt>
<dd>
<div class="desc"><p>Foreign key constraints.</p></div>
</dd>
<dt id="pyracmon.Column.incremental"><code class="name">var <span class="ident">incremental</span></code></dt>
<dd>
<div class="desc"><p>If this column is auto-incremental, this object contains the information of the feature, otherwise, <code>None</code>.</p></div>
</dd>
<dt id="pyracmon.Column.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Column name.</p></div>
</dd>
<dt id="pyracmon.Column.nullable"><code class="name">var <span class="ident">nullable</span></code></dt>
<dd>
<div class="desc"><p>Can this column contain null?</p></div>
</dd>
<dt id="pyracmon.Column.pk"><code class="name">var <span class="ident">pk</span></code></dt>
<dd>
<div class="desc"><p>Is this column a primary key?</p></div>
</dd>
<dt id="pyracmon.Column.ptype"><code class="name">var <span class="ident">ptype</span></code></dt>
<dd>
<div class="desc"><p>Data type in python.</p></div>
</dd>
<dt id="pyracmon.Column.type_info"><code class="name">var <span class="ident">type_info</span></code></dt>
<dd>
<div class="desc"><p>Type informations obtained from DB.</p></div>
</dd>
</dl>
</dd>
<dt id="pyracmon.Conditional"><code class="flex name class">
<span>class <span class="ident">Conditional</span></span>
<span>(</span><span>expression='', params=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a query condition composed of an expression and parameters.</p>
<p>Parameters must be a list where the index of each parameter matches the index of placeholder for it.
The expression accepts only the unified marker <code>$_</code>.</p>
<p>Applying logical operators such as <code>&amp;</code>, <code>|</code> and <code>~</code> generates new condition.</p>
<pre><code class="language-python">&gt;&gt;&gt; c1 = Q.of(&quot;a = $_&quot;, 0)
&gt;&gt;&gt; c2 = Q.of(&quot;b &lt; $_&quot;, 1)
&gt;&gt;&gt; c3 = Q.of(&quot;c &gt; $_&quot;, 2)
&gt;&gt;&gt; c = ~(c1 &amp; c2 | c3)
&gt;&gt;&gt; c
Condition: NOT (((a = $_) AND (b &lt; $_)) OR (c &gt; $_)) -- [0, 1, 2]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Conditional(Expression):
    &#34;&#34;&#34;
    Represents a query condition composed of an expression and parameters.

    Parameters must be a list where the index of each parameter matches the index of placeholder for it.
    The expression accepts only the unified marker `$_`.

    Applying logical operators such as `&amp;`, `|` and `~` generates new condition.

    ```python
    &gt;&gt;&gt; c1 = Q.of(&#34;a = $_&#34;, 0)
    &gt;&gt;&gt; c2 = Q.of(&#34;b &lt; $_&#34;, 1)
    &gt;&gt;&gt; c3 = Q.of(&#34;c &gt; $_&#34;, 2)
    &gt;&gt;&gt; c = ~(c1 &amp; c2 | c3)
    &gt;&gt;&gt; c
    Condition: NOT (((a = $_) AND (b &lt; $_)) OR (c &gt; $_)) -- [0, 1, 2]
    ```
    &#34;&#34;&#34;
    @classmethod
    def all(cls, conditionals: Sequence[&#39;Conditional&#39;]) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Concatenates condition objects with `AND`.

        Args:
            conditionals: Condition objects.
        Returns:
            Concatenated condition object.
        &#34;&#34;&#34;
        return reduce(lambda acc, c: acc &amp; c, conditionals, Conditional())

    @classmethod
    def any(cls, conditionals: Sequence[&#39;Conditional&#39;]) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Concatenates condition objects with `OR`.

        Args:
            conditionals: Condition objects.
        Returns:
            Concatenated condition object.
        &#34;&#34;&#34;
        if len(conditionals) == 0:
            return Conditional(&#34;1 = 0&#34;)
        return reduce(lambda acc, c: acc | c, conditionals, Conditional())

    def __init__(self, expression=&#34;&#34;, params=None):
        super().__init__(expression, params or [])

    def __repr__(self):
        return f&#34;Condition: &#39;{self.expression}&#39; -- {self.params}&#34;

    def __and__(self, other) -&gt; &#39;Conditional&#39;:
        expression = &#34;&#34;
        if self.expression and other.expression:
            expression = f&#34;({self.expression}) AND ({other.expression})&#34;
        elif self.expression:
            expression = self.expression
        elif other.expression:
            expression = other.expression

        return Conditional(expression, self.params + other.params)

    def __or__(self, other) -&gt; &#39;Conditional&#39;:
        expression = &#34;&#34;
        if self.expression and other.expression:
            expression = f&#34;({self.expression}) OR ({other.expression})&#34;
        elif self.expression:
            expression = self.expression
        elif other.expression:
            expression = other.expression

        return Conditional(expression, self.params + other.params)

    def __invert__(self) -&gt; &#39;Conditional&#39;:
        if self.expression:
            return Conditional(f&#34;NOT ({self.expression})&#34;, self.params)
        else:
            return Conditional(f&#34;1 = 0&#34;, [])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.query.Expression" href="query.html#pyracmon.query.Expression">Expression</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.Conditional.all"><code class="name flex">
<span>def <span class="ident">all</span></span>(<span>conditionals: collections.abc.Sequence['<a title="pyracmon.Conditional" href="#pyracmon.Conditional">Conditional</a>']) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates condition objects with <code>AND</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>conditionals</code></strong></dt>
<dd>Condition objects.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Concatenated condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def all(cls, conditionals: Sequence[&#39;Conditional&#39;]) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Concatenates condition objects with `AND`.

    Args:
        conditionals: Condition objects.
    Returns:
        Concatenated condition object.
    &#34;&#34;&#34;
    return reduce(lambda acc, c: acc &amp; c, conditionals, Conditional())</code></pre>
</details>
</dd>
<dt id="pyracmon.Conditional.any"><code class="name flex">
<span>def <span class="ident">any</span></span>(<span>conditionals: collections.abc.Sequence['<a title="pyracmon.Conditional" href="#pyracmon.Conditional">Conditional</a>']) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates condition objects with <code>OR</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>conditionals</code></strong></dt>
<dd>Condition objects.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Concatenated condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def any(cls, conditionals: Sequence[&#39;Conditional&#39;]) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Concatenates condition objects with `OR`.

    Args:
        conditionals: Condition objects.
    Returns:
        Concatenated condition object.
    &#34;&#34;&#34;
    if len(conditionals) == 0:
        return Conditional(&#34;1 = 0&#34;)
    return reduce(lambda acc, c: acc | c, conditionals, Conditional())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyracmon.query.Expression" href="query.html#pyracmon.query.Expression">Expression</a></b></code>:
<ul class="hlist">
<li><code><a title="pyracmon.query.Expression.expression" href="query.html#pyracmon.query.Expression.expression">expression</a></code></li>
<li><code><a title="pyracmon.query.Expression.params" href="query.html#pyracmon.query.Expression.params">params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyracmon.Connection"><code class="flex name class">
<span>class <span class="ident">Connection</span></span>
<span>(</span><span>api, conn: <a title="pyracmon.dbapi.Connection" href="dbapi.html#pyracmon.dbapi.Connection">Connection</a>, context_factory: Optional[Callable[[], <a title="pyracmon.context.ConnectionContext" href="context.html#pyracmon.context.ConnectionContext">ConnectionContext</a>]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper class of DB-API 2.0 Connection.</p>
<p>Every instance works as the proxy object to original connection, therefore any attribute in it is still available.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Connection(dbapi.Connection):
    &#34;&#34;&#34;
    Wrapper class of DB-API 2.0 Connection.

    Every instance works as the proxy object to original connection, therefore any attribute in it is still available.
    &#34;&#34;&#34;
    _characters = string.ascii_letters + string.digits + &#34;.=&#34;

    def __init__(self, api, conn: dbapi.Connection, context_factory: Optional[Callable[[], ConnectionContext]] = None):
        #: A string which identifies a connection.
        self.identifier = self._gen_identifier()
        #: DB-API 2.0 module.
        self.api = api
        #: Original connection object.
        self.conn = conn
        self._context_factory = context_factory
        self._context = None

    def __getattr__(self, name):
        return getattr(self.conn, name)

    def __enter__(self):
        if hasattr(self.conn, &#34;__enter__&#34;):
            self.conn.__enter__() # type: ignore
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        if hasattr(self.conn, &#34;__exit__&#34;):
            self.conn.__exit__(exc_type, exc_value, traceback) # type: ignore
        else:
            if exc_value is None:
                self.conn.rollback()
            else:
                self.conn.commit()
            self.conn.close()

    def _gen_identifier(self):
        return threading.current_thread().name + &#34;-&#34; + secrets.token_hex(4)

    @property
    def context(self) -&gt; ConnectionContext:
        &#34;&#34;&#34;
        Context object used for this connection.
        &#34;&#34;&#34;
        if not self._context:
            self._context = (self._context_factory or ConnectionContext)()
            self._context.identifier = self.identifier
        return self._context

    def close(self) -&gt; None:
        return self.conn.close()

    def commit(self) -&gt; None:
        return self.conn.commit()

    def rollback(self) -&gt; None:
        return self.conn.rollback()

    def cursor(self) -&gt; dbapi.Cursor:
        return self.conn.cursor()

    def use(self, factory: Callable[[], ConnectionContext]) -&gt; Self:
        &#34;&#34;&#34;
        Sets factory function of `ConnectionContext` to use custom context.

        When the context is already set, it will be replaced with new one.

        Args:
            factory: Function returning custom context.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self._context_factory = factory
        self._context = None
        return self

    def stmt(self, context: Optional[ConnectionContext] = None) -&gt; &#39;Statement&#39;:
        &#34;&#34;&#34;
        Creates new `Statement` which executes queries on this connection.

        Args:
            context: Context object used in the statement. If `None`, the context of this connection is used.
        Returns:
            Created statement.
        &#34;&#34;&#34;
        return Statement(self, context or self.context)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.dbapi.Connection" href="dbapi.html#pyracmon.dbapi.Connection">Connection</a></li>
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.Connection.api"><code class="name">var <span class="ident">api</span></code></dt>
<dd>
<div class="desc"><p>DB-API 2.0 module.</p></div>
</dd>
<dt id="pyracmon.Connection.conn"><code class="name">var <span class="ident">conn</span></code></dt>
<dd>
<div class="desc"><p>Original connection object.</p></div>
</dd>
<dt id="pyracmon.Connection.context"><code class="name">var <span class="ident">context</span> : <a title="pyracmon.context.ConnectionContext" href="context.html#pyracmon.context.ConnectionContext">ConnectionContext</a></code></dt>
<dd>
<div class="desc"><p>Context object used for this connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def context(self) -&gt; ConnectionContext:
    &#34;&#34;&#34;
    Context object used for this connection.
    &#34;&#34;&#34;
    if not self._context:
        self._context = (self._context_factory or ConnectionContext)()
        self._context.identifier = self.identifier
    return self._context</code></pre>
</details>
</dd>
<dt id="pyracmon.Connection.identifier"><code class="name">var <span class="ident">identifier</span></code></dt>
<dd>
<div class="desc"><p>A string which identifies a connection.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.Connection.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    return self.conn.close()</code></pre>
</details>
</dd>
<dt id="pyracmon.Connection.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit(self) -&gt; None:
    return self.conn.commit()</code></pre>
</details>
</dd>
<dt id="pyracmon.Connection.cursor"><code class="name flex">
<span>def <span class="ident">cursor</span></span>(<span>self) ‑> <a title="pyracmon.dbapi.Cursor" href="dbapi.html#pyracmon.dbapi.Cursor">Cursor</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cursor(self) -&gt; dbapi.Cursor:
    return self.conn.cursor()</code></pre>
</details>
</dd>
<dt id="pyracmon.Connection.rollback"><code class="name flex">
<span>def <span class="ident">rollback</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rollback(self) -&gt; None:
    return self.conn.rollback()</code></pre>
</details>
</dd>
<dt id="pyracmon.Connection.stmt"><code class="name flex">
<span>def <span class="ident">stmt</span></span>(<span>self, context: Optional[<a title="pyracmon.context.ConnectionContext" href="context.html#pyracmon.context.ConnectionContext">ConnectionContext</a>] = None) ‑> <a title="pyracmon.connection.Statement" href="connection.html#pyracmon.connection.Statement">Statement</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates new <code>Statement</code> which executes queries on this connection.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong></dt>
<dd>Context object used in the statement. If <code>None</code>, the context of this connection is used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Created statement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stmt(self, context: Optional[ConnectionContext] = None) -&gt; &#39;Statement&#39;:
    &#34;&#34;&#34;
    Creates new `Statement` which executes queries on this connection.

    Args:
        context: Context object used in the statement. If `None`, the context of this connection is used.
    Returns:
        Created statement.
    &#34;&#34;&#34;
    return Statement(self, context or self.context)</code></pre>
</details>
</dd>
<dt id="pyracmon.Connection.use"><code class="name flex">
<span>def <span class="ident">use</span></span>(<span>self, factory: Callable[[], <a title="pyracmon.context.ConnectionContext" href="context.html#pyracmon.context.ConnectionContext">ConnectionContext</a>]) ‑> typing_extensions.Self</span>
</code></dt>
<dd>
<div class="desc"><p>Sets factory function of <code><a title="pyracmon.ConnectionContext" href="#pyracmon.ConnectionContext">ConnectionContext</a></code> to use custom context.</p>
<p>When the context is already set, it will be replaced with new one.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>factory</code></strong></dt>
<dd>Function returning custom context.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def use(self, factory: Callable[[], ConnectionContext]) -&gt; Self:
    &#34;&#34;&#34;
    Sets factory function of `ConnectionContext` to use custom context.

    When the context is already set, it will be replaced with new one.

    Args:
        factory: Function returning custom context.
    Returns:
        This instance.
    &#34;&#34;&#34;
    self._context_factory = factory
    self._context = None
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.ConnectionContext"><code class="flex name class">
<span>class <span class="ident">ConnectionContext</span></span>
<span>(</span><span>identifier: Optional[str] = None, **configurations)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a context of query execution.</p>
<p>By default, the context based on global configuration is used.
You should declare your own context class and set it to <code><a title="pyracmon.Connection.use" href="#pyracmon.Connection.use">Connection.use()</a></code> if you want to change the behavior.</p>
<p>Custom context is also useful to change cursor state before and after query execution.
Overwrite <code>execute</code> method to do it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConnectionContext:
    &#34;&#34;&#34;
    This class represents a context of query execution.

    By default, the context based on global configuration is used.
    You should declare your own context class and set it to `Connection.use` if you want to change the behavior.

    Custom context is also useful to change cursor state before and after query execution.  Overwrite `execute` method to do it.
    &#34;&#34;&#34;
    def __init__(self, identifier: Optional[str] = None, **configurations):
        #: Identifier of this context. `None` by default.
        self.identifier = identifier
        #: Configuration used in this context.
        self.config = default_config().derive(**configurations)

    def _message(self, message):
        return f&#34;({self.identifier}) {message}&#34; if self.identifier else message

    def configure(self, **configurations: Any) -&gt; &#39;ConnectionContext&#39;:
        &#34;&#34;&#34;
        Change configurations of this context.

        Changes by this method never affect global configuration even if the context is based on it.

        Args:
            configurations: Configurations. See `pyracmon.config` to know available keys.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self.config.set(**configurations)
        return self

    def execute(self, cursor: dbapi.Cursor, sql: str, params: PARAMS) -&gt; dbapi.Cursor:
        &#34;&#34;&#34;
        Executes a query on a cursor.

        Args:
            cursor: Cursor object.
            sql: Query string.
            params: Query parameters.
        Returns:
            Given cursor object. Internal state may be changed by the execution of the query.
        &#34;&#34;&#34;
        return self._execute(cursor, sql, params, False)

    def executemany(self, cursor: dbapi.Cursor, sql: str, seq_of_params: Sequence[PARAMS]) -&gt; dbapi.Cursor:
        &#34;&#34;&#34;
        Repeats query on a cursor for sequencee of parameters.

        This method works similar to `execute` but invoke `executemany` instead.

        Args:
            cursor: Cursor object.
            sql: Query string.
            seq_of_args: A sequence of parameters of the query.
        Returns:
            Given cursor object. Internal state may be changed by the execution of the query.
        &#34;&#34;&#34;
        return self._execute(cursor, sql, seq_of_params, True)

    @overload
    def _execute(self, cursor: dbapi.Cursor, sql: str, params: PARAMS, is_many: Literal[False] = False) -&gt; dbapi.Cursor: ...
    @overload
    def _execute(self, cursor: dbapi.Cursor, sql: str, params: Sequence[PARAMS], is_many: Literal[True] = True) -&gt; dbapi.Cursor: ...
    def _execute(
        self,
        cursor: dbapi.Cursor,
        sql: str,
        params,
        is_many: bool = False,
    ) -&gt; dbapi.Cursor:
        logger = _logger(self.config)

        if logger:
            sql_log = sql if len(sql) &lt;= self.config.sql_log_length else f&#34;{sql[0:self.config.sql_log_length]}...&#34;

            logger.log(self.config.log_level, self._message(sql_log))

            if self.config.parameter_log:
                if is_many:
                    for ps in params:
                        logger.log(self.config.log_level, self._message(f&#34;Parameters: {ps}&#34;))
                else:
                    logger.log(self.config.log_level, self._message(f&#34;Parameters: {params}&#34;))

        if is_many:
            cursor.executemany(sql, params)
        else:
            cursor.execute(sql, params)

        return cursor</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.ConnectionContext.config"><code class="name">var <span class="ident">config</span></code></dt>
<dd>
<div class="desc"><p>Configuration used in this context.</p></div>
</dd>
<dt id="pyracmon.ConnectionContext.identifier"><code class="name">var <span class="ident">identifier</span></code></dt>
<dd>
<div class="desc"><p>Identifier of this context. <code>None</code> by default.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.ConnectionContext.configure"><code class="name flex">
<span>def <span class="ident">configure</span></span>(<span>self, **configurations: Any) ‑> <a title="pyracmon.context.ConnectionContext" href="context.html#pyracmon.context.ConnectionContext">ConnectionContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Change configurations of this context.</p>
<p>Changes by this method never affect global configuration even if the context is based on it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>configurations</code></strong></dt>
<dd>Configurations. See <code><a title="pyracmon.config" href="config.html">pyracmon.config</a></code> to know available keys.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure(self, **configurations: Any) -&gt; &#39;ConnectionContext&#39;:
    &#34;&#34;&#34;
    Change configurations of this context.

    Changes by this method never affect global configuration even if the context is based on it.

    Args:
        configurations: Configurations. See `pyracmon.config` to know available keys.
    Returns:
        This instance.
    &#34;&#34;&#34;
    self.config.set(**configurations)
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.ConnectionContext.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, cursor: <a title="pyracmon.dbapi.Cursor" href="dbapi.html#pyracmon.dbapi.Cursor">Cursor</a>, sql: str, params: Union[list[Any], dict[str, Any]]) ‑> <a title="pyracmon.dbapi.Cursor" href="dbapi.html#pyracmon.dbapi.Cursor">Cursor</a></span>
</code></dt>
<dd>
<div class="desc"><p>Executes a query on a cursor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cursor</code></strong></dt>
<dd>Cursor object.</dd>
<dt><strong><code>sql</code></strong></dt>
<dd>Query string.</dd>
<dt><strong><code>params</code></strong></dt>
<dd>Query parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Given cursor object. Internal state may be changed by the execution of the query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, cursor: dbapi.Cursor, sql: str, params: PARAMS) -&gt; dbapi.Cursor:
    &#34;&#34;&#34;
    Executes a query on a cursor.

    Args:
        cursor: Cursor object.
        sql: Query string.
        params: Query parameters.
    Returns:
        Given cursor object. Internal state may be changed by the execution of the query.
    &#34;&#34;&#34;
    return self._execute(cursor, sql, params, False)</code></pre>
</details>
</dd>
<dt id="pyracmon.ConnectionContext.executemany"><code class="name flex">
<span>def <span class="ident">executemany</span></span>(<span>self, cursor: <a title="pyracmon.dbapi.Cursor" href="dbapi.html#pyracmon.dbapi.Cursor">Cursor</a>, sql: str, seq_of_params: collections.abc.Sequence[typing.Union[list[typing.Any], dict[str, typing.Any]]]) ‑> <a title="pyracmon.dbapi.Cursor" href="dbapi.html#pyracmon.dbapi.Cursor">Cursor</a></span>
</code></dt>
<dd>
<div class="desc"><p>Repeats query on a cursor for sequencee of parameters.</p>
<p>This method works similar to <code>execute</code> but invoke <code>executemany</code> instead.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cursor</code></strong></dt>
<dd>Cursor object.</dd>
<dt><strong><code>sql</code></strong></dt>
<dd>Query string.</dd>
<dt><strong><code>seq_of_args</code></strong></dt>
<dd>A sequence of parameters of the query.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Given cursor object. Internal state may be changed by the execution of the query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def executemany(self, cursor: dbapi.Cursor, sql: str, seq_of_params: Sequence[PARAMS]) -&gt; dbapi.Cursor:
    &#34;&#34;&#34;
    Repeats query on a cursor for sequencee of parameters.

    This method works similar to `execute` but invoke `executemany` instead.

    Args:
        cursor: Cursor object.
        sql: Query string.
        seq_of_args: A sequence of parameters of the query.
    Returns:
        Given cursor object. Internal state may be changed by the execution of the query.
    &#34;&#34;&#34;
    return self._execute(cursor, sql, seq_of_params, True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.ContainerView"><code class="flex name class">
<span>class <span class="ident">ContainerView</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The interface of the view of a node set, i.e. <code><a title="pyracmon.NodeContainer" href="#pyracmon.NodeContainer">NodeContainer</a></code> and <code><a title="pyracmon.Node.Children" href="#pyracmon.Node.Children">Node.Children</a></code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContainerView(Protocol, Generic[T]):
    &#34;&#34;&#34;
    The interface of the view of a node set, i.e. `NodeContainer` and `Node.Children` .
    &#34;&#34;&#34;
    def __bool__(self) -&gt; bool:
        &#34;&#34;&#34;Returns whether this container is not empty.&#34;&#34;&#34;
        ...
    def __call__(self) -&gt; T:
        &#34;&#34;&#34;Returns a base container.&#34;&#34;&#34;
        ...
    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Returns the number of nodes.&#34;&#34;&#34;
        ...
    def __iter__(self) -&gt; Iterator[&#39;NodeView&#39;]:
        &#34;&#34;&#34;Iterates views of nodes.&#34;&#34;&#34;
        ...
    @overload
    def __getitem__(self, index: int) -&gt; &#39;NodeView&#39;: ...
    @overload
    def __getitem__(self, index: slice) -&gt; Iterable[&#39;NodeView&#39;]: ...
    def __getitem__(self, index: Union[int, slice]) -&gt; Union[&#39;NodeView&#39;, Iterable[&#39;NodeView&#39;]]:
        &#34;&#34;&#34;Returns a view of a node at the index.&#34;&#34;&#34;
        ...
    def __getattr__(self, key) -&gt; &#39;ContainerView&#39;:
        &#34;&#34;&#34;Returns a view of the first node or empty container view if it does not exist.&#34;&#34;&#34;
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyracmon.graph.graph._EmptyContainerView</li>
</ul>
</dd>
<dt id="pyracmon.Expression"><code class="flex name class">
<span>class <span class="ident">Expression</span></span>
<span>(</span><span>expression: str, params: list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Abstraction of expression in any query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Expression:
    &#34;&#34;&#34;
    Abstraction of expression in any query.
    &#34;&#34;&#34;
    def __init__(self, expression: str, params: list[Any]):
        #: Expression string.
        self.expression = expression
        #: Parameters corresponding to placeholders in the expression.
        self.params = params</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.Expression.expression"><code class="name">var <span class="ident">expression</span></code></dt>
<dd>
<div class="desc"><p>Expression string.</p></div>
</dd>
<dt id="pyracmon.Expression.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"><p>Parameters corresponding to placeholders in the expression.</p></div>
</dd>
</dl>
</dd>
<dt id="pyracmon.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>template: <a title="pyracmon.graph.template.GraphTemplate" href="graph/template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a graph composed of tree-structured node containers.</p>
<p>The structure is determined by <code>GraphTemplate</code>. Use <code><a title="pyracmon.new_graph" href="#pyracmon.new_graph">new_graph()</a></code> Instead of constructor to create new graph instance.</p>
<pre><code class="language-python">template = GraphSpac().new_template(
    a = (int, lambda x:x),
    b = (str, lambda x:x),
    c = (str, lambda x:x),
)
template.a &lt;&lt; template.b &lt;&lt; template.c
graph = new_graph(template)
</code></pre>
<p>In above code, a graph which has 3 properties ( <code>a</code> <code>b</code> <code>c</code> ) and a structure where <code>a</code> is parent of <code>b</code> and <code>b</code> is parent of <code>c</code> is created.</p>
<p><code>append</code> ( <code>replace</code> ) is a method to store entities in the graph with tying them each other according to the structure.
Entites are encapsulated by <code><a title="pyracmon.Node" href="#pyracmon.Node">Node</a></code> which can have an edge to parent node.</p>
<pre><code class="language-python">graph.append(a=1, b=&quot;a&quot;, c=&quot;x&quot;).append(a=2, b=&quot;b&quot;, c=&quot;y&quot;)
</code></pre>
<p>In <code>append</code>, entities are first sorted in descending order, and then:</p>
<ul>
<li>Search a node whose entity is <em>identical</em> to the first entity from the corresponding node container.<ul>
<li>If found, new node is not created and the <em>identical</em> node is set to next parent.</li>
<li>Otherwise, new node is appended and it is set to next parent.</li>
</ul>
</li>
<li>Apply this to following entities in order. A difference is that <em>identical</em> node is searched from the sequence of parents in the session.</li>
</ul>
<p>In example here, the identification is done by entity value itself ( <code>lambda x:x</code> ). Next code is the example where <em>identical</em> nodes are found.</p>
<pre><code class="language-python">graph.append(a=1, b=&quot;a&quot;, c=&quot;z&quot;).append(a=2, b=&quot;c&quot;, c=&quot;y&quot;)
</code></pre>
<p>In the first <code>append</code>, <code>a</code> and <code>b</code> has its <em>identical</em> node and <code>a</code> is <em>identical</em> in the second.
<code>c</code> in the second one is not <em>identical</em> to any node because parent node <code>b="c"</code> is already added as new node.</p>
<p>Due to the identification mechanism, entity relationships in the graph is guaranteed after repeating <code>append</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph:
    &#34;&#34;&#34;
    This class represents a graph composed of tree-structured node containers.

    The structure is determined by `GraphTemplate`. Use `new_graph` Instead of constructor to create new graph instance.

    ```python
    template = GraphSpac().new_template(
        a = (int, lambda x:x),
        b = (str, lambda x:x),
        c = (str, lambda x:x),
    )
    template.a &lt;&lt; template.b &lt;&lt; template.c
    graph = new_graph(template)
    ```

    In above code, a graph which has 3 properties ( `a` `b` `c` ) and a structure where `a` is parent of `b` and `b` is parent of `c` is created.

    `append` ( `replace` ) is a method to store entities in the graph with tying them each other according to the structure.
    Entites are encapsulated by `Node` which can have an edge to parent node.

    ```python
    graph.append(a=1, b=&#34;a&#34;, c=&#34;x&#34;).append(a=2, b=&#34;b&#34;, c=&#34;y&#34;)
    ```

    In `append`, entities are first sorted in descending order, and then:

    - Search a node whose entity is *identical* to the first entity from the corresponding node container.
        - If found, new node is not created and the *identical* node is set to next parent.
        - Otherwise, new node is appended and it is set to next parent.
    - Apply this to following entities in order. A difference is that *identical* node is searched from the sequence of parents in the session.

    In example here, the identification is done by entity value itself ( `lambda x:x` ). Next code is the example where *identical* nodes are found.

    ```python
    graph.append(a=1, b=&#34;a&#34;, c=&#34;z&#34;).append(a=2, b=&#34;c&#34;, c=&#34;y&#34;)
    ```

    In the first `append`, `a` and `b` has its *identical* node and `a` is *identical* in the second.
    `c` in the second one is not *identical* to any node because parent node `b=&#34;c&#34;` is already added as new node.

    Due to the identification mechanism, entity relationships in the graph is guaranteed after repeating `append` .
    &#34;&#34;&#34;
    def __init__(self, template: GraphTemplate):
        #: Graph template.
        self.template: GraphTemplate = template
        #: A `dict` containing node containers by their names.
        self.containers: dict[str, NodeContainer] = {p.name:self._to_container(p) for p in template}
        self._view = None

    def _to_container(self, prop: GraphTemplate.Property) -&gt; &#39;NodeContainer&#39;:
        if isinstance(prop.kind, GraphTemplate):
            return _GraphNodeContainer(prop)
        else:
            return NodeContainer(prop)

    def _container_of(self, prop: GraphTemplate.Property) -&gt; Optional[&#39;NodeContainer&#39;]:
        candidates = [c for c in self.containers.values() if c.prop.is_compatible(prop)]
        if len(candidates) &gt; 1:
            raise ValueError(f&#34;Container can&#39;t be determined from property &#39;{prop.name}&#39;.&#34;)
        return candidates[0] if candidates else None

    def __add__(self, another: Union[Self, GraphView]) -&gt; &#39;Graph&#39;:
        &#34;&#34;&#34;
        Create new graph by adding this graph and another graph.

        New graph has the same template as this graph&#39;s.
        On the other hand, because this method depends on `__iadd__()`, another graph must not have the same template.

        Args:
            another: Graph or its view.
        Returns:
            Created graph.
        &#34;&#34;&#34;
        graph = Graph(self.template)

        graph += self
        graph += another

        return graph

    def __iadd__(self, another: Union[Self, GraphView]) -&gt; Self:
        &#34;&#34;&#34;
        Append nodes from another graph.

        Nodes of another graph are traversed from its root and appended to compatible containers each other.

        Args:
            another: Graph or its view.
        Returns:
            This graph.
        &#34;&#34;&#34;
        graph = another if isinstance(another, Graph) else another()

        def add(n: Node, anc: dict[str, list[Node]]):
            c = self._container_of(n.prop)
            if c:
                c.append(n.entity, anc)
            for ch_ in n.children.values():
                for m in ch_.nodes:
                    add(m, anc.copy())

        for c_ in graph.roots:
            for n_ in c_.nodes:
                add(n_, {})

        return self

    @property
    def roots(self) -&gt; Iterable[&#39;NodeContainer&#39;]:
        &#34;&#34;&#34;
        Returns root node containers.
        &#34;&#34;&#34;
        return filter(lambda c: c.prop.parent is None, self.containers.values())

    @property
    def view(self) -&gt; GraphView:
        &#34;&#34;&#34;
        Returns an unmodifiable view of this graph.

        The view object works as the accessor to graph nodes.

        ```python
        &gt;&gt;&gt; template = GraphSpac().new_template(a=int, b=str, c=str)
        &gt;&gt;&gt; template.a &lt;&lt; template.b
        &gt;&gt;&gt; graph = new_graph(template)
        &gt;&gt;&gt; view = graph.view
        &gt;&gt;&gt; assert view() is graph                        # invocation
        &gt;&gt;&gt; assert view.a is graph.containers[&#34;a&#34;].view   # attribute
        &gt;&gt;&gt; assert [c().name for c in view] == [&#34;a&#34;, &#34;c&#34;] # iteration
        ```
        &#34;&#34;&#34;
        if self._view is None:
            graph = self
            class _GraphView:
                def __call__(self) -&gt; Graph:
                    &#34;&#34;&#34;Returns the greph of this view.&#34;&#34;&#34;
                    return graph
                def __iter__(self) -&gt; Iterator[tuple[str, ContainerView[NodeContainer]]]:
                    &#34;&#34;&#34;Iterates views of root containers.&#34;&#34;&#34;
                    return map(lambda c: (c.name, c.view), filter(lambda c: c.prop.parent is None, graph.containers.values()))
                def __getattr__(self, name: str) -&gt; ContainerView:
                    &#34;&#34;&#34;Returns a view of a container of the name.&#34;&#34;&#34;
                    return graph.containers[name].view
            self._view = _GraphView()
        return self._view

    def _append(self, to_replace: bool, entities: dict[str, Any]) -&gt; Self:
        props = [p for p in self.template if p.name in entities]

        filtered = set()
        for p in props:
            if (p.parent is None) or (p.parent.name not in entities) or (p.parent.name in filtered):
                if p.entity_filter is None or p.entity_filter(entities[p.name]):
                    filtered.add(p.name)

        ancestors = {}
        for k in [p.name for p in props if p.name in filtered]:
            self.containers[k].append(entities[k], ancestors, to_replace)

        return self

    def append(self, **entities: Any) -&gt; Self:
        &#34;&#34;&#34;
        Append entities with associated property names.

        Args:
            entities: Entities keyed with associated property names.
        Returns:
            This graph.
        &#34;&#34;&#34;
        return self._append(False, entities)

    def replace(self, **entities: Any) -&gt; Self:
        &#34;&#34;&#34;
        Works similarly to `append`, but entities of identical nodes are replaced with given entities.

        Args:
            entities: Entities keyed with associated property names.
        Returns:
            This graph.
        &#34;&#34;&#34;
        return self._append(True, entities)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.Graph.containers"><code class="name">var <span class="ident">containers</span></code></dt>
<dd>
<div class="desc"><p>A <code>dict</code> containing node containers by their names.</p></div>
</dd>
<dt id="pyracmon.Graph.roots"><code class="name">var <span class="ident">roots</span> : collections.abc.Iterable['<a title="pyracmon.NodeContainer" href="#pyracmon.NodeContainer">NodeContainer</a>']</code></dt>
<dd>
<div class="desc"><p>Returns root node containers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def roots(self) -&gt; Iterable[&#39;NodeContainer&#39;]:
    &#34;&#34;&#34;
    Returns root node containers.
    &#34;&#34;&#34;
    return filter(lambda c: c.prop.parent is None, self.containers.values())</code></pre>
</details>
</dd>
<dt id="pyracmon.Graph.template"><code class="name">var <span class="ident">template</span></code></dt>
<dd>
<div class="desc"><p>Graph template.</p></div>
</dd>
<dt id="pyracmon.Graph.view"><code class="name">var <span class="ident">view</span> : <a title="pyracmon.graph.graph.GraphView" href="graph/graph.html#pyracmon.graph.graph.GraphView">GraphView</a></code></dt>
<dd>
<div class="desc"><p>Returns an unmodifiable view of this graph.</p>
<p>The view object works as the accessor to graph nodes.</p>
<pre><code class="language-python">&gt;&gt;&gt; template = GraphSpac().new_template(a=int, b=str, c=str)
&gt;&gt;&gt; template.a &lt;&lt; template.b
&gt;&gt;&gt; graph = new_graph(template)
&gt;&gt;&gt; view = graph.view
&gt;&gt;&gt; assert view() is graph                        # invocation
&gt;&gt;&gt; assert view.a is graph.containers[&quot;a&quot;].view   # attribute
&gt;&gt;&gt; assert [c().name for c in view] == [&quot;a&quot;, &quot;c&quot;] # iteration
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def view(self) -&gt; GraphView:
    &#34;&#34;&#34;
    Returns an unmodifiable view of this graph.

    The view object works as the accessor to graph nodes.

    ```python
    &gt;&gt;&gt; template = GraphSpac().new_template(a=int, b=str, c=str)
    &gt;&gt;&gt; template.a &lt;&lt; template.b
    &gt;&gt;&gt; graph = new_graph(template)
    &gt;&gt;&gt; view = graph.view
    &gt;&gt;&gt; assert view() is graph                        # invocation
    &gt;&gt;&gt; assert view.a is graph.containers[&#34;a&#34;].view   # attribute
    &gt;&gt;&gt; assert [c().name for c in view] == [&#34;a&#34;, &#34;c&#34;] # iteration
    ```
    &#34;&#34;&#34;
    if self._view is None:
        graph = self
        class _GraphView:
            def __call__(self) -&gt; Graph:
                &#34;&#34;&#34;Returns the greph of this view.&#34;&#34;&#34;
                return graph
            def __iter__(self) -&gt; Iterator[tuple[str, ContainerView[NodeContainer]]]:
                &#34;&#34;&#34;Iterates views of root containers.&#34;&#34;&#34;
                return map(lambda c: (c.name, c.view), filter(lambda c: c.prop.parent is None, graph.containers.values()))
            def __getattr__(self, name: str) -&gt; ContainerView:
                &#34;&#34;&#34;Returns a view of a container of the name.&#34;&#34;&#34;
                return graph.containers[name].view
        self._view = _GraphView()
    return self._view</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.Graph.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, **entities: Any) ‑> typing_extensions.Self</span>
</code></dt>
<dd>
<div class="desc"><p>Append entities with associated property names.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entities</code></strong></dt>
<dd>Entities keyed with associated property names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, **entities: Any) -&gt; Self:
    &#34;&#34;&#34;
    Append entities with associated property names.

    Args:
        entities: Entities keyed with associated property names.
    Returns:
        This graph.
    &#34;&#34;&#34;
    return self._append(False, entities)</code></pre>
</details>
</dd>
<dt id="pyracmon.Graph.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, **entities: Any) ‑> typing_extensions.Self</span>
</code></dt>
<dd>
<div class="desc"><p>Works similarly to <code>append</code>, but entities of identical nodes are replaced with given entities.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entities</code></strong></dt>
<dd>Entities keyed with associated property names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(self, **entities: Any) -&gt; Self:
    &#34;&#34;&#34;
    Works similarly to `append`, but entities of identical nodes are replaced with given entities.

    Args:
        entities: Entities keyed with associated property names.
    Returns:
        This graph.
    &#34;&#34;&#34;
    return self._append(True, entities)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.GraphSchema"><code class="flex name class">
<span>class <span class="ident">GraphSchema</span></span>
<span>(</span><span>spec: Any, template: <a title="pyracmon.graph.template.GraphTemplate" href="graph/template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, **serializers: <a title="pyracmon.graph.serialize.NodeSerializer" href="graph/serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This class exposes a property to get the schema of serialization result of a graph.</p>
<p>TODO: Dependency to <code>GraphSpec</code> should be replaced in another way.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphSchema:
    &#34;&#34;&#34;
    This class exposes a property to get the schema of serialization result of a graph.

    TODO: Dependency to `GraphSpec` should be replaced in another way.
    &#34;&#34;&#34;
    def __init__(self, spec: Any, template: GraphTemplate, **serializers: NodeSerializer):
        #: Specification of graph operations.
        self.spec = spec
        #: Graph template to serialize.
        self.template = template
        #: `NodeSerializer`s used for the serialization.
        self.serializers = serializers

    def _return_from(self, prop: GraphTemplate.Property) -&gt; type:
        &#34;&#34;&#34;
        Get a type the node of passed property will be serialized.
        &#34;&#34;&#34;
        ns = self.serializers[prop.name]

        # Type of the node entity.
        entity_type = prop.kind
        if isinstance(entity_type, GraphTemplate):
            # GraphTemplate type is ignored because serializer added by sub() resolve the type by iteself.
            entity_type = _templateType(entity_type)

        # Return type of the NodeSerializer.
        ns_type = signature(ns.serializer).return_annotation

        # Return type of base serializer obtained from GraphSpec.
        base = chain_serializers(self.spec.find_serializers(entity_type))
        base_type = signature(base).return_annotation if base else Signature.empty
        #base_type = entity_type if base_type == Signature.empty else base_type

        # If the return type contains a single type parameter, previous type is applied to it.
        # Serializer without return annotation is supposed to return input type as it is.
        def next_resolvable(it: Iterator[type]) -&gt; type:
            while True:
                res = next(it, None)
                if res is None:
                    break
                elif res != Signature.empty:
                    return res
            return Signature.empty

        def resolve(it: Iterator[type]) -&gt; type:
            origin = next_resolvable(it)
            if origin == Signature.empty:
                return origin
            elif issubgeneric(origin, Typeable):
                if not Typeable.is_resolved(origin):
                    param = resolve(it)
                    if param == Signature.empty:
                        # Type parameter is not known.
                        return Signature.empty
                    # Replace type parameter.
                    origin = origin[param] # type: ignore
                return Typeable.resolve(origin, resolve(it), self.spec)
            else:
                args = get_args(origin)
                if args:
                    # origin is generics.
                    type_params = list(filter(lambda ia: isinstance(ia[1], TypeVar), enumerate(args)))
                    # python &lt; 3.10
                    param_num = len(type_params)
                    if param_num == 0:
                        return origin
                    elif param_num == 1:
                        # Replace type parameter
                        param = resolve(it)
                        return origin[param] # type: ignore
                    else:
                        return Signature.empty
                    # python &gt;= 3.10
                    #match len(type_params):
                    #    case 0:
                    #        return origin
                    #    case 1:
                    #        # Replace type parameter
                    #        param = resolve(it)
                    #        return origin[param] # type: ignore
                    #    case _:
                    #        return Signature.empty
                else:
                    return origin

        return resolve(iter([ns_type, base_type, entity_type, entity_type]))

    def schema_of(self, prop: GraphTemplate.Property) -&gt; Type[Annotated]:
        &#34;&#34;&#34;
        Generates structured and documented schema for a template property.

        Args:
            prop: A template property.
        Returns:
            Schema with documentation.
        &#34;&#34;&#34;
        return_type = self._return_from(prop)

        doc = self.serializers[prop.name]._doc or &#34;&#34;

        # TypedDict type is also a subclass of dict.
        if issubclass(return_type, dict):
            annotations = {}

            for c in filter(lambda c: c.name in self.serializers, prop.children):
                ns = self.serializers[c.name]
                cs = self.schema_of(c)

                t, d = decompose_document(cs)

                if ns.be_merged:
                    if not issubclass(t, dict):
                        raise ValueError(f&#34;Property &#39;{c.name}&#39; is not configured to be serialized into dict.&#34;)
                    annotations.update(**{ns.namer(k):t for k, t in get_type_hints(t, include_extras=True).items()})
                elif ns.be_singular:
                    rt = signature(ns.aggregator).return_annotation
                    rt = replace_optional_typevar(rt, cs)
                    annotations[ns.namer(c.name)] = rt
                else:
                    annotations[ns.namer(c.name)] = document_type(list[t], d)

            td_type: Optional[type[TypedDict]] = cast(type[TypedDict], return_type) if is_typeddict(return_type) else None

            return document_type(generate_schema(annotations, td_type), doc)
        else:
            return document_type(return_type, doc)

    @property
    def schema(self) -&gt; type[TypedDict]:
        &#34;&#34;&#34;
        Generates `TypedDict` which represents the schema of serialized graph.
        &#34;&#34;&#34;
        annotations: dict[str, Any] = {}

        def put_root_schema(p: GraphTemplate.Property):
            nonlocal annotations

            ns = self.serializers[p.name]
            dt = self.schema_of(p)

            if ns.be_merged:
                t, d = decompose_document(dt)
                annotations.update(**{ns.namer(k):t_ for k, t_ in get_type_hints(t, include_extras=True).items()})
            elif ns.be_singular:
                rt = signature(ns.aggregator).return_annotation
                rt = replace_optional_typevar(rt, dt)
                annotations[ns.namer(p.name)] = rt
            else:
                t, d = decompose_document(dt)
                annotations[ns.namer(p.name)] = document_type(list[t], d)

        roots = filter(lambda p: p.parent is None and p.name in self.serializers, self.template._properties.values())

        for p in roots:
            put_root_schema(p)

        return generate_schema(annotations)

    def serialize(self, graph: GraphView, **node_params: dict[str, Any]) -&gt; dict[str, Any]:
        &#34;&#34;&#34;
        Serialize graph into a dictionary.

        Args:
            graph: A view of a graph.
            node_params: Parameters passed to `SerializationContext` and used by *serializer* s.
        Returns:
            Serialization result.
        &#34;&#34;&#34;
        return self.spec.to_dict(graph, node_params, **self.serializers)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.GraphSchema.schema"><code class="name">var <span class="ident">schema</span> : type[typing.TypedDict]</code></dt>
<dd>
<div class="desc"><p>Generates <code>TypedDict</code> which represents the schema of serialized graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def schema(self) -&gt; type[TypedDict]:
    &#34;&#34;&#34;
    Generates `TypedDict` which represents the schema of serialized graph.
    &#34;&#34;&#34;
    annotations: dict[str, Any] = {}

    def put_root_schema(p: GraphTemplate.Property):
        nonlocal annotations

        ns = self.serializers[p.name]
        dt = self.schema_of(p)

        if ns.be_merged:
            t, d = decompose_document(dt)
            annotations.update(**{ns.namer(k):t_ for k, t_ in get_type_hints(t, include_extras=True).items()})
        elif ns.be_singular:
            rt = signature(ns.aggregator).return_annotation
            rt = replace_optional_typevar(rt, dt)
            annotations[ns.namer(p.name)] = rt
        else:
            t, d = decompose_document(dt)
            annotations[ns.namer(p.name)] = document_type(list[t], d)

    roots = filter(lambda p: p.parent is None and p.name in self.serializers, self.template._properties.values())

    for p in roots:
        put_root_schema(p)

    return generate_schema(annotations)</code></pre>
</details>
</dd>
<dt id="pyracmon.GraphSchema.serializers"><code class="name">var <span class="ident">serializers</span></code></dt>
<dd>
<div class="desc"><p><code>NodeSerializer</code>s used for the serialization.</p></div>
</dd>
<dt id="pyracmon.GraphSchema.spec"><code class="name">var <span class="ident">spec</span></code></dt>
<dd>
<div class="desc"><p>Specification of graph operations.</p></div>
</dd>
<dt id="pyracmon.GraphSchema.template"><code class="name">var <span class="ident">template</span></code></dt>
<dd>
<div class="desc"><p>Graph template to serialize.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.GraphSchema.schema_of"><code class="name flex">
<span>def <span class="ident">schema_of</span></span>(<span>self, prop: <a title="pyracmon.graph.template.GraphTemplate.Property" href="graph/template.html#pyracmon.graph.template.GraphTemplate.Property">GraphTemplate.Property</a>) ‑> Type[Annotated]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates structured and documented schema for a template property.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>prop</code></strong></dt>
<dd>A template property.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Schema with documentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def schema_of(self, prop: GraphTemplate.Property) -&gt; Type[Annotated]:
    &#34;&#34;&#34;
    Generates structured and documented schema for a template property.

    Args:
        prop: A template property.
    Returns:
        Schema with documentation.
    &#34;&#34;&#34;
    return_type = self._return_from(prop)

    doc = self.serializers[prop.name]._doc or &#34;&#34;

    # TypedDict type is also a subclass of dict.
    if issubclass(return_type, dict):
        annotations = {}

        for c in filter(lambda c: c.name in self.serializers, prop.children):
            ns = self.serializers[c.name]
            cs = self.schema_of(c)

            t, d = decompose_document(cs)

            if ns.be_merged:
                if not issubclass(t, dict):
                    raise ValueError(f&#34;Property &#39;{c.name}&#39; is not configured to be serialized into dict.&#34;)
                annotations.update(**{ns.namer(k):t for k, t in get_type_hints(t, include_extras=True).items()})
            elif ns.be_singular:
                rt = signature(ns.aggregator).return_annotation
                rt = replace_optional_typevar(rt, cs)
                annotations[ns.namer(c.name)] = rt
            else:
                annotations[ns.namer(c.name)] = document_type(list[t], d)

        td_type: Optional[type[TypedDict]] = cast(type[TypedDict], return_type) if is_typeddict(return_type) else None

        return document_type(generate_schema(annotations, td_type), doc)
    else:
        return document_type(return_type, doc)</code></pre>
</details>
</dd>
<dt id="pyracmon.GraphSchema.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, graph: <a title="pyracmon.graph.graph.GraphView" href="graph/graph.html#pyracmon.graph.graph.GraphView">GraphView</a>, **node_params: dict[str, typing.Any]) ‑> dict[str, typing.Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize graph into a dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>A view of a graph.</dd>
<dt><strong><code>node_params</code></strong></dt>
<dd>Parameters passed to <code>SerializationContext</code> and used by <em>serializer</em> s.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Serialization result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self, graph: GraphView, **node_params: dict[str, Any]) -&gt; dict[str, Any]:
    &#34;&#34;&#34;
    Serialize graph into a dictionary.

    Args:
        graph: A view of a graph.
        node_params: Parameters passed to `SerializationContext` and used by *serializer* s.
    Returns:
        Serialization result.
    &#34;&#34;&#34;
    return self.spec.to_dict(graph, node_params, **self.serializers)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.GraphView"><code class="flex name class">
<span>class <span class="ident">GraphView</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The interface of the view of graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphView(Protocol):
    &#34;&#34;&#34;
    The interface of the view of graph.
    &#34;&#34;&#34;
    def __call__(self) -&gt; &#39;Graph&#39;: ...
    def __iter__(self) -&gt; Iterator[tuple[str, &#39;ContainerView[NodeContainer]&#39;]]:
        &#34;&#34;&#34;
        Iterates root container views.

        Returns:
            Iterator of pairs of name and container view.
        &#34;&#34;&#34;
        ...
    def __getattr__(self, name: str) -&gt; &#39;ContainerView&#39;:
        &#34;&#34;&#34;
        Returns a container view by its name.

        Args:
            name: Container name. i.e. template property name for the node container.
        Returns:
            Container view.
        &#34;&#34;&#34;
        ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="pyracmon.Model"><code class="flex name class">
<span>class <span class="ident">Model</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Model(Mixins[Unpack[MXS]], metaclass=Meta):
    &#34;&#34;&#34;
    Base type of model types.

    This class only works as a marker of model types and gives no functionalities to them.
    &#34;&#34;&#34;
    def __init__(self, **kwargs) -&gt; None: ... # for typing</code></pre>
</details>
</dd>
<dt id="pyracmon.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>prop: <a title="pyracmon.graph.template.GraphTemplate.Property" href="graph/template.html#pyracmon.graph.template.GraphTemplate.Property">GraphTemplate.Property</a>, entity: Any, key: Optional[Any], index: int)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a node which contains an entity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node:
    &#34;&#34;&#34;
    This class represents a node which contains an entity.
    &#34;&#34;&#34;
    class Children:
        &#34;&#34;&#34;
        This class represents a child nodes of a node.
        &#34;&#34;&#34;
        def __init__(self, prop: GraphTemplate.Property):
            #: Template property.
            self.prop = prop
            self.nodes: list[Node] = []
            self.keys = set()
            self._view = None

        @property
        def name(self) -&gt; str:
            &#34;&#34;&#34;
            Returns the name of corresponding template property.
            &#34;&#34;&#34;
            return self.prop.name

        @property
        def view(self) -&gt; ContainerView[&#39;Node.Children&#39;]:
            &#34;&#34;&#34;
            Returns an unmodifiable view of child nodes.
            &#34;&#34;&#34;
            if self._view is None:
                base = self
                class _ChildrenView:
                    def __bool__(self):
                        &#34;&#34;&#34;Returns whether this container is not empty.&#34;&#34;&#34;
                        return len(base.nodes) != 0
                    def __call__(self):
                        &#34;&#34;&#34;Returns children container.&#34;&#34;&#34;
                        return base
                    def __iter__(self):
                        &#34;&#34;&#34;Iterates views of child nodes.&#34;&#34;&#34;
                        return map(lambda n: n.view, base.nodes)
                    def __len__(self):
                        &#34;&#34;&#34;Returns the number of child nodes.&#34;&#34;&#34;
                        return len(base.nodes)
                    @overload
                    def __getitem__(self, index: int) -&gt; &#39;NodeView&#39;: ...
                    @overload
                    def __getitem__(self, index: slice) -&gt; Iterable[&#39;NodeView&#39;]: ...
                    def __getitem__(self, index):
                        &#34;&#34;&#34;Returns a view of child node at the index.&#34;&#34;&#34;
                        if isinstance(index, slice):
                            return [n.view for n in base.nodes[index]]
                        else:
                            return base.nodes[index].view
                    def __getattr__(self, key):
                        &#34;&#34;&#34;Returns a view of the first node or empty container view if it does not exist.&#34;&#34;&#34;
                        child = next(filter(lambda c: c.name == key, base.prop.children), None)
                        if child:
                            return base.nodes[0].children[key].view if len(base.nodes) &gt; 0 else _EmptyContainerView(child)
                        else:
                            raise KeyError(f&#34;Graph property &#39;{base.prop.name}&#39; does not have a child property &#39;{key}&#39;.&#34;)
                self._view = _ChildrenView()
            return self._view

        def __contains__(self, node: &#39;Node&#39;) -&gt; bool:
            return node in self.keys

        def __iter__(self) -&gt; Iterator[&#39;Node&#39;]:
            return iter(self.nodes)

        def append(self, node):
            if node not in self.keys:
                self.keys.add(node)
                self.nodes.append(node)

    def __init__(self, prop: GraphTemplate.Property, entity: Any, key: Optional[Any], index: int):
        #: Template property.
        self.prop = prop
        #: An entity value.
        self.entity = entity
        self.key = key
        self.parents = set()
        self.children: dict[str, Node.Children] = {c.name: Node.Children(c) for c in prop.children}
        self._index = index
        self._view = None

    def __contains__(self, key: str) -&gt; bool:
        return key in self.children

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the container name, which is same as the name of template property.
        &#34;&#34;&#34;
        return self.prop.name

    @property
    def view(self) -&gt; NodeView:
        &#34;&#34;&#34;
        Returns an unmodifiable view of this node.

        The view object works as the accessor to entity and child nodes.
        &#34;&#34;&#34;
        if self._view is None:
            node = self
            class _NodeView(NodeView):
                def __call__(self, alt: Any = None) -&gt; Any:
                    &#34;&#34;&#34;Returns an entity of this node.&#34;&#34;&#34;
                    return node.entity
                def __getattr__(self, key: str) -&gt; ContainerView:
                    &#34;&#34;&#34;Returns a view of child nodes by its name.&#34;&#34;&#34;
                    return node.children[key].view
                def __iter__(self) -&gt; Iterator[tuple[str, ContainerView]]:
                    &#34;&#34;&#34;Iterate key-value pairs of child nodes.&#34;&#34;&#34;
                    return map(lambda nc: (nc[0], nc[1].view), node.children.items())
            self._view = _NodeView()
        return self._view

    def add_child(self, child: &#39;Node&#39;) -&gt; Self:
        &#34;&#34;&#34;
        Adds a child node.

        Args:
            child: Child node.
        Returns:
            This instance.
        &#34;&#34;&#34;
        if child.prop.template != self.prop.template:
            raise ValueError(f&#34;Nodes from different graph template can&#39;t be associated.&#34;)
        self.children[child.prop.name].append(child)
        child.parents.add(self)
        return self

    def has_child(self, child: &#39;Node&#39;) -&gt; bool:
        &#34;&#34;&#34;
        Checks this node contains the node identical to given node.

        Args:
            child: Node to search.
        Returns:
            `True` if exists.
        &#34;&#34;&#34;
        if child.prop.template != self.prop.template:
            return False
        elif child.prop.name in self.children:
            return child in self.children[child.prop.name].keys
        else:
            return False</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyracmon.graph.graph._GraphNode</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyracmon.Node.Children"><code class="name">var <span class="ident">Children</span></code></dt>
<dd>
<div class="desc"><p>This class represents a child nodes of a node.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.Node.entity"><code class="name">var <span class="ident">entity</span></code></dt>
<dd>
<div class="desc"><p>An entity value.</p></div>
</dd>
<dt id="pyracmon.Node.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the container name, which is same as the name of template property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the container name, which is same as the name of template property.
    &#34;&#34;&#34;
    return self.prop.name</code></pre>
</details>
</dd>
<dt id="pyracmon.Node.prop"><code class="name">var <span class="ident">prop</span></code></dt>
<dd>
<div class="desc"><p>Template property.</p></div>
</dd>
<dt id="pyracmon.Node.view"><code class="name">var <span class="ident">view</span> : <a title="pyracmon.graph.graph.NodeView" href="graph/graph.html#pyracmon.graph.graph.NodeView">NodeView</a></code></dt>
<dd>
<div class="desc"><p>Returns an unmodifiable view of this node.</p>
<p>The view object works as the accessor to entity and child nodes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def view(self) -&gt; NodeView:
    &#34;&#34;&#34;
    Returns an unmodifiable view of this node.

    The view object works as the accessor to entity and child nodes.
    &#34;&#34;&#34;
    if self._view is None:
        node = self
        class _NodeView(NodeView):
            def __call__(self, alt: Any = None) -&gt; Any:
                &#34;&#34;&#34;Returns an entity of this node.&#34;&#34;&#34;
                return node.entity
            def __getattr__(self, key: str) -&gt; ContainerView:
                &#34;&#34;&#34;Returns a view of child nodes by its name.&#34;&#34;&#34;
                return node.children[key].view
            def __iter__(self) -&gt; Iterator[tuple[str, ContainerView]]:
                &#34;&#34;&#34;Iterate key-value pairs of child nodes.&#34;&#34;&#34;
                return map(lambda nc: (nc[0], nc[1].view), node.children.items())
        self._view = _NodeView()
    return self._view</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.Node.add_child"><code class="name flex">
<span>def <span class="ident">add_child</span></span>(<span>self, child: <a title="pyracmon.Node" href="#pyracmon.Node">Node</a>) ‑> typing_extensions.Self</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a child node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>child</code></strong></dt>
<dd>Child node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_child(self, child: &#39;Node&#39;) -&gt; Self:
    &#34;&#34;&#34;
    Adds a child node.

    Args:
        child: Child node.
    Returns:
        This instance.
    &#34;&#34;&#34;
    if child.prop.template != self.prop.template:
        raise ValueError(f&#34;Nodes from different graph template can&#39;t be associated.&#34;)
    self.children[child.prop.name].append(child)
    child.parents.add(self)
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.Node.has_child"><code class="name flex">
<span>def <span class="ident">has_child</span></span>(<span>self, child: <a title="pyracmon.Node" href="#pyracmon.Node">Node</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks this node contains the node identical to given node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>child</code></strong></dt>
<dd>Node to search.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>True</code> if exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_child(self, child: &#39;Node&#39;) -&gt; bool:
    &#34;&#34;&#34;
    Checks this node contains the node identical to given node.

    Args:
        child: Node to search.
    Returns:
        `True` if exists.
    &#34;&#34;&#34;
    if child.prop.template != self.prop.template:
        return False
    elif child.prop.name in self.children:
        return child in self.children[child.prop.name].keys
    else:
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.NodeContainer"><code class="flex name class">
<span>class <span class="ident">NodeContainer</span></span>
<span>(</span><span>prop: <a title="pyracmon.graph.template.GraphTemplate.Property" href="graph/template.html#pyracmon.graph.template.GraphTemplate.Property">GraphTemplate.Property</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a container of nodes for a template property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeContainer:
    &#34;&#34;&#34;
    This class represents a container of nodes for a template property.
    &#34;&#34;&#34;
    def __init__(self, prop: GraphTemplate.Property):
        #: Template property.
        self.prop = prop
        self.nodes: list[Node] = []
        self.keys: dict[Any, list[int]] = {}
        self._view = None

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the container name, which is same as the name of template property.
        &#34;&#34;&#34;
        return self.prop.name

    @property
    def view(self) -&gt; ContainerView[&#39;NodeContainer&#39;]:
        &#34;&#34;&#34;
        Returns an unmodifiable view of this container.

        The view object works as the accessor to container components.

        ```python
        template = GraphSpac().new_template(a=int, b=str, c=str)
        template.a &lt;&lt; template.b
        graph = new_graph(template).append(a=1, b=&#34;a&#34;).append(a=1, b=&#34;b&#34;).append(a=2, b=&#34;c&#34;)
        container = graph.containers[&#34;a&#34;]
        view = graph.view.a
        assert view() is container                             # invocation
        assert view.b is container.nodes[0].children[&#34;b&#34;].view # attribute
        assert view[1] is container.nodes[1].view              # index
        assert [n() for n in view] == [1, 2]                   # iteration
        assert len(view) == 2                                  # length
        ```
        &#34;&#34;&#34;
        if self._view is None:
            container = self
            class _ContainerView:
                def __bool__(self):
                    &#34;&#34;&#34;Returns whether this container is not empty.&#34;&#34;&#34;
                    return len(container.nodes) != 0
                def __call__(self) -&gt; NodeContainer:
                    &#34;&#34;&#34;Returns a base container.&#34;&#34;&#34;
                    return container
                def __len__(self):
                    &#34;&#34;&#34;Returns the number of nodes.&#34;&#34;&#34;
                    return len(container.nodes)
                def __iter__(self):
                    &#34;&#34;&#34;Iterates views of nodes.&#34;&#34;&#34;
                    return map(lambda n: n.view, container.nodes)
                @overload
                def __getitem__(self, index: int) -&gt; &#39;NodeView&#39;: ...
                @overload
                def __getitem__(self, index: slice) -&gt; Iterable[&#39;NodeView&#39;]: ...
                def __getitem__(self, index: Union[int, slice]) -&gt; Union[&#39;NodeView&#39;, Iterable[&#39;NodeView&#39;]]:
                    &#34;&#34;&#34;Returns a view of a node at the index.&#34;&#34;&#34;
                    if isinstance(index, slice):
                        return [n.view for n in container.nodes[index]]
                    else:
                        return container.nodes[index].view
                def __getattr__(self, key) -&gt; ContainerView:
                    &#34;&#34;&#34;Returns a view of the first node or empty container view if it does not exist.&#34;&#34;&#34;
                    child = next(filter(lambda c: c.name == key, container.prop.children), None)
                    if child:
                        return container.nodes[0].children[key].view if len(container.nodes) &gt; 0 else _EmptyContainerView(child)
                    else:
                        raise KeyError(f&#34;Graph property &#39;{container.prop.name}&#39; does not have a child property &#39;{key}&#39;.&#34;)
            self._view = _ContainerView()
        return self._view

    def append(self, entity: Any, ancestors: MutableMapping[str, list[&#39;Node&#39;]], to_replace: bool = False):
        &#34;&#34;&#34;
        Add an entity to this container.

        Identical node is searched by examining whether this container already contains a node of the identical entity
        and its parent is found in `anscestors` .

        Args:
            entity: An entity to be stored in the node.
            ancestors: Parent nodes mapped by property names.
            to_replace: If `True`, the entity of identical node is replaced. Otherwise, it is not changed.
        &#34;&#34;&#34;
        policy: IdentifyPolicy = self.prop.policy or neverPolicy()

        key = policy.get_identifier(entity)

        parents, identicals = policy.identify(self.prop, [self.nodes[i] for i in self.keys.get(key, [])], ancestors)

        new_nodes = identicals.copy()

        for pn in parents:
            index = len(self.nodes)

            node = Node(self.prop, entity, key, index)
            self.nodes.append(node)
            if key is not None:
                self.keys.setdefault(key, []).append(index)
            new_nodes.append(node)

            if pn is not None:
                pn.add_child(node)

        if to_replace:
            for n in identicals:
                n.entity = entity

        ancestors[self.prop.name] = new_nodes</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyracmon.graph.graph._GraphNodeContainer</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.NodeContainer.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the container name, which is same as the name of template property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the container name, which is same as the name of template property.
    &#34;&#34;&#34;
    return self.prop.name</code></pre>
</details>
</dd>
<dt id="pyracmon.NodeContainer.prop"><code class="name">var <span class="ident">prop</span></code></dt>
<dd>
<div class="desc"><p>Template property.</p></div>
</dd>
<dt id="pyracmon.NodeContainer.view"><code class="name">var <span class="ident">view</span> : <a title="pyracmon.graph.graph.ContainerView" href="graph/graph.html#pyracmon.graph.graph.ContainerView">ContainerView</a>[<a title="pyracmon.graph.graph.NodeContainer" href="graph/graph.html#pyracmon.graph.graph.NodeContainer">NodeContainer</a>]</code></dt>
<dd>
<div class="desc"><p>Returns an unmodifiable view of this container.</p>
<p>The view object works as the accessor to container components.</p>
<pre><code class="language-python">template = GraphSpac().new_template(a=int, b=str, c=str)
template.a &lt;&lt; template.b
graph = new_graph(template).append(a=1, b=&quot;a&quot;).append(a=1, b=&quot;b&quot;).append(a=2, b=&quot;c&quot;)
container = graph.containers[&quot;a&quot;]
view = graph.view.a
assert view() is container                             # invocation
assert view.b is container.nodes[0].children[&quot;b&quot;].view # attribute
assert view[1] is container.nodes[1].view              # index
assert [n() for n in view] == [1, 2]                   # iteration
assert len(view) == 2                                  # length
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def view(self) -&gt; ContainerView[&#39;NodeContainer&#39;]:
    &#34;&#34;&#34;
    Returns an unmodifiable view of this container.

    The view object works as the accessor to container components.

    ```python
    template = GraphSpac().new_template(a=int, b=str, c=str)
    template.a &lt;&lt; template.b
    graph = new_graph(template).append(a=1, b=&#34;a&#34;).append(a=1, b=&#34;b&#34;).append(a=2, b=&#34;c&#34;)
    container = graph.containers[&#34;a&#34;]
    view = graph.view.a
    assert view() is container                             # invocation
    assert view.b is container.nodes[0].children[&#34;b&#34;].view # attribute
    assert view[1] is container.nodes[1].view              # index
    assert [n() for n in view] == [1, 2]                   # iteration
    assert len(view) == 2                                  # length
    ```
    &#34;&#34;&#34;
    if self._view is None:
        container = self
        class _ContainerView:
            def __bool__(self):
                &#34;&#34;&#34;Returns whether this container is not empty.&#34;&#34;&#34;
                return len(container.nodes) != 0
            def __call__(self) -&gt; NodeContainer:
                &#34;&#34;&#34;Returns a base container.&#34;&#34;&#34;
                return container
            def __len__(self):
                &#34;&#34;&#34;Returns the number of nodes.&#34;&#34;&#34;
                return len(container.nodes)
            def __iter__(self):
                &#34;&#34;&#34;Iterates views of nodes.&#34;&#34;&#34;
                return map(lambda n: n.view, container.nodes)
            @overload
            def __getitem__(self, index: int) -&gt; &#39;NodeView&#39;: ...
            @overload
            def __getitem__(self, index: slice) -&gt; Iterable[&#39;NodeView&#39;]: ...
            def __getitem__(self, index: Union[int, slice]) -&gt; Union[&#39;NodeView&#39;, Iterable[&#39;NodeView&#39;]]:
                &#34;&#34;&#34;Returns a view of a node at the index.&#34;&#34;&#34;
                if isinstance(index, slice):
                    return [n.view for n in container.nodes[index]]
                else:
                    return container.nodes[index].view
            def __getattr__(self, key) -&gt; ContainerView:
                &#34;&#34;&#34;Returns a view of the first node or empty container view if it does not exist.&#34;&#34;&#34;
                child = next(filter(lambda c: c.name == key, container.prop.children), None)
                if child:
                    return container.nodes[0].children[key].view if len(container.nodes) &gt; 0 else _EmptyContainerView(child)
                else:
                    raise KeyError(f&#34;Graph property &#39;{container.prop.name}&#39; does not have a child property &#39;{key}&#39;.&#34;)
        self._view = _ContainerView()
    return self._view</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.NodeContainer.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, entity: Any, ancestors: collections.abc.MutableMapping[str, list['<a title="pyracmon.Node" href="#pyracmon.Node">Node</a>']], to_replace: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an entity to this container.</p>
<p>Identical node is searched by examining whether this container already contains a node of the identical entity
and its parent is found in <code>anscestors</code> .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity</code></strong></dt>
<dd>An entity to be stored in the node.</dd>
<dt><strong><code>ancestors</code></strong></dt>
<dd>Parent nodes mapped by property names.</dd>
<dt><strong><code>to_replace</code></strong></dt>
<dd>If <code>True</code>, the entity of identical node is replaced. Otherwise, it is not changed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, entity: Any, ancestors: MutableMapping[str, list[&#39;Node&#39;]], to_replace: bool = False):
    &#34;&#34;&#34;
    Add an entity to this container.

    Identical node is searched by examining whether this container already contains a node of the identical entity
    and its parent is found in `anscestors` .

    Args:
        entity: An entity to be stored in the node.
        ancestors: Parent nodes mapped by property names.
        to_replace: If `True`, the entity of identical node is replaced. Otherwise, it is not changed.
    &#34;&#34;&#34;
    policy: IdentifyPolicy = self.prop.policy or neverPolicy()

    key = policy.get_identifier(entity)

    parents, identicals = policy.identify(self.prop, [self.nodes[i] for i in self.keys.get(key, [])], ancestors)

    new_nodes = identicals.copy()

    for pn in parents:
        index = len(self.nodes)

        node = Node(self.prop, entity, key, index)
        self.nodes.append(node)
        if key is not None:
            self.keys.setdefault(key, []).append(index)
        new_nodes.append(node)

        if pn is not None:
            pn.add_child(node)

    if to_replace:
        for n in identicals:
            n.entity = entity

    ancestors[self.prop.name] = new_nodes</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.NodeContext"><code class="flex name class">
<span>class <span class="ident">NodeContext</span></span>
<span>(</span><span>context: SerializationContext, params: <a title="pyracmon.graph.serialize.NodeParams" href="graph/serialize.html#pyracmon.graph.serialize.NodeParams">NodeParams</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A class containing informations for serialization of a single node.</p>
<p>The instance of this class is passed to the serialization function.
Properties listed below are available to control serialization.</p>
<ul>
<li>context: <code>SerializationContext</code> for the serialization of the graph.</li>
<li>node: <code><a title="pyracmon.Node" href="#pyracmon.Node">Node</a></code> to serialize.</li>
<li>value: Entity value of the <code><a title="pyracmon.Node" href="#pyracmon.Node">Node</a></code> .</li>
<li>params: Arbitrary values which is passed from invoking scope with being bound to the key of node name.</li>
</ul>
<p>Every serializer has to call <code>serialize()</code> to get the result of preceeding serializers,
or make a result direcly from the node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeContext:
    &#34;&#34;&#34;
    A class containing informations for serialization of a single node.

    The instance of this class is passed to the serialization function.
    Properties listed below are available to control serialization.

    - context: `SerializationContext` for the serialization of the graph.
    - node: `Node` to serialize.
    - value: Entity value of the `Node` .
    - params: Arbitrary values which is passed from invoking scope with being bound to the key of node name.

    Every serializer has to call `serialize()` to get the result of preceeding serializers,
    or make a result direcly from the node.
    &#34;&#34;&#34;
    def __init__(self, context: &#39;SerializationContext&#39;, params: NodeParams) -&gt; None:
        #: `SerializationContext` for the serializaion of the graph.`
        self.context = context
        #: Arbitrary values passed by outside for the node.
        self.params = params
        # Set on demand.
        self._node: Optional[Node] = None
        self._iterator: Optional[Iterator[Any]] = None

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self._node = None
        self._iterator = None

    @property
    def node(self) -&gt; Node:
        # Node must be set when passed to serialization function.
        return cast(Node, self._node)

    @property
    def value(self) -&gt; Any:
        return cast(Node, self._node).entity

    def serialize(self) -&gt; Any:
        &#34;&#34;&#34;
        Obtain a value serialized by preceeding serializers.
        &#34;&#34;&#34;
        try:
            return next(cast(Iterator[Any], self._iterator))(self)
        except StopIteration:
            return self.node.entity</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.NodeContext.context"><code class="name">var <span class="ident">context</span></code></dt>
<dd>
<div class="desc"><p><code>SerializationContext</code> for the serializaion of the graph.`</p></div>
</dd>
<dt id="pyracmon.NodeContext.node"><code class="name">var <span class="ident">node</span> : <a title="pyracmon.graph.graph.Node" href="graph/graph.html#pyracmon.graph.graph.Node">Node</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def node(self) -&gt; Node:
    # Node must be set when passed to serialization function.
    return cast(Node, self._node)</code></pre>
</details>
</dd>
<dt id="pyracmon.NodeContext.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"><p>Arbitrary values passed by outside for the node.</p></div>
</dd>
<dt id="pyracmon.NodeContext.value"><code class="name">var <span class="ident">value</span> : Any</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self) -&gt; Any:
    return cast(Node, self._node).entity</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.NodeContext.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Obtain a value serialized by preceeding serializers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self) -&gt; Any:
    &#34;&#34;&#34;
    Obtain a value serialized by preceeding serializers.
    &#34;&#34;&#34;
    try:
        return next(cast(Iterator[Any], self._iterator))(self)
    except StopIteration:
        return self.node.entity</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.NodeView"><code class="flex name class">
<span>class <span class="ident">NodeView</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeView:
    def __call__(self, alt: Any = None) -&gt; Any:
        &#34;&#34;&#34;Returns an entity of this node.&#34;&#34;&#34;
        ...
    def __getattr__(self, key: str) -&gt; ContainerView:
        &#34;&#34;&#34;Returns a view of child nodes by its name.&#34;&#34;&#34;
        ...
    def __iter__(self) -&gt; Iterator[tuple[str, ContainerView]]:
        &#34;&#34;&#34;Iterate key-value pairs of child nodes.&#34;&#34;&#34;
        ...</code></pre>
</details>
</dd>
<dt id="pyracmon.Q"><code class="flex name class">
<span>class <span class="ident">Q</span></span>
<span>(</span><span>**kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>This class provides utility class methods creating conditions.</p>
<p>Using <code>of()</code> is the most simple way to create a condition clause with parameters.</p>
<pre><code class="language-python">&gt;&gt;&gt; Q.of(&quot;a = $_&quot;, 1)
Condition: 'a = $_' -- [1]
</code></pre>
<p>Other utility methods correspond to basic operators defined in SQL.
They takes keyword arguments and create conditions by applying operator to each item respectively.</p>
<pre><code class="language-python">&gt;&gt;&gt; Q.eq(a=1)
Condition: 'a = %s' -- [1]
&gt;&gt;&gt; Q.in_(a=[1, 2, 3])
Condition: 'a IN (%s, %s, %s)' -- [1, 2, 3]
&gt;&gt;&gt; Q.like(a=&quot;abc&quot;)
Condition: 'a LIKE %s' -- [&quot;%abc%&quot;]
</code></pre>
<p>Multiple arguments generates a condition which concatenates conditions with logical operator, by default <code>AND</code> .</p>
<pre><code class="language-python">&gt;&gt;&gt; Q.eq(a=1, b=2)
Condition: 'a = %s AND b = %s' -- [1, 2]
</code></pre>
<p>Those methods also accept table alias which is prepended to columns.</p>
<pre><code class="language-python">&gt;&gt;&gt; Q.eq(&quot;t&quot;, a=1, b=2)
Condition: 't.a = %s AND t.b = %s'
</code></pre>
<p>Additionally, the instance of this class has its own functionality to generate condition.</p>
<p>Each parameter passed to the constructor becomes an instance method of the instance,
which takes a condition clause including placeholders which will take parameters in query execution phase.
<code><a title="pyracmon.connection.Statement.execute" href="connection.html#pyracmon.connection.Statement.execute">Statement.execute()</a></code> allows unified marker <code>$_</code> in spite of DB driver.</p>
<pre><code class="language-python">&gt;&gt;&gt; q = Q(a=1)
&gt;&gt;&gt; q.a(&quot;a = $_&quot;)
Condition: 'a = $_' -- [1]
</code></pre>
<p>Method whose name is not passed to the constructor renders empty condition which has no effect on the query.</p>
<pre><code class="language-python">&gt;&gt;&gt; q.b(&quot;b = $_&quot;)
Condition: '' -- []
</code></pre>
<p>By default, <code>None</code> is equivalent to not being passed. Giving <code>True</code> at the first argument in constructor changes the behavior.</p>
<pre><code class="language-python">&gt;&gt;&gt; q = Q(a=1, b=None)
&gt;&gt;&gt; q.b(&quot;b = $_&quot;)
Condition: '' -- []
&gt;&gt;&gt; q = Q(True, a=1, b=None)
&gt;&gt;&gt; q.b(&quot;b = $_&quot;)
Condition: 'b = $_' -- [None]
</code></pre>
<p>This feature simplifies a query construction in cases some parameters are absent.</p>
<pre><code class="language-python">&gt;&gt;&gt; def search(db, q):
&gt;&gt;&gt;     w, params = where(q.a(&quot;a = $_&quot;) &amp; q.b(&quot;b = $_&quot;))
&gt;&gt;&gt;     db.stmt().execute(f&quot;SELECT * FROM table {w}&quot;, *params)
&gt;&gt;&gt; 
&gt;&gt;&gt; search(db, Q(a=1))      # SELECT * FROM table WHERE a = 1
&gt;&gt;&gt; search(db, Q(a=1, b=2)) # SELECT * FROM table WHERE a = 1 AND b = 2
&gt;&gt;&gt; search(db, Q())         # SELECT * FROM table
</code></pre>
<p>Initializes an instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_include_none_</code></strong></dt>
<dd>Whether include attributes whose value is <code>None</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Denotes pairs of attribute name and parameter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Q:
    &#34;&#34;&#34;
    This class provides utility class methods creating conditions.

    Using `of()` is the most simple way to create a condition clause with parameters.

    ```python
    &gt;&gt;&gt; Q.of(&#34;a = $_&#34;, 1)
    Condition: &#39;a = $_&#39; -- [1]
    ```

    Other utility methods correspond to basic operators defined in SQL.
    They takes keyword arguments and create conditions by applying operator to each item respectively.

    ```python
    &gt;&gt;&gt; Q.eq(a=1)
    Condition: &#39;a = %s&#39; -- [1]
    &gt;&gt;&gt; Q.in_(a=[1, 2, 3])
    Condition: &#39;a IN (%s, %s, %s)&#39; -- [1, 2, 3]
    &gt;&gt;&gt; Q.like(a=&#34;abc&#34;)
    Condition: &#39;a LIKE %s&#39; -- [&#34;%abc%&#34;]
    ```

    Multiple arguments generates a condition which concatenates conditions with logical operator, by default `AND` .

    ```python
    &gt;&gt;&gt; Q.eq(a=1, b=2)
    Condition: &#39;a = %s AND b = %s&#39; -- [1, 2]
    ```

    Those methods also accept table alias which is prepended to columns.

    ```python
    &gt;&gt;&gt; Q.eq(&#34;t&#34;, a=1, b=2)
    Condition: &#39;t.a = %s AND t.b = %s&#39;
    ```

    Additionally, the instance of this class has its own functionality to generate condition.

    Each parameter passed to the constructor becomes an instance method of the instance,
    which takes a condition clause including placeholders which will take parameters in query execution phase.
    `pyracmon.connection.Statement.execute` allows unified marker `$_` in spite of DB driver.

    ```python
    &gt;&gt;&gt; q = Q(a=1)
    &gt;&gt;&gt; q.a(&#34;a = $_&#34;)
    Condition: &#39;a = $_&#39; -- [1]
    ```

    Method whose name is not passed to the constructor renders empty condition which has no effect on the query.

    ```python
    &gt;&gt;&gt; q.b(&#34;b = $_&#34;)
    Condition: &#39;&#39; -- []
    ```

    By default, `None` is equivalent to not being passed. Giving `True` at the first argument in constructor changes the behavior.

    ```python
    &gt;&gt;&gt; q = Q(a=1, b=None)
    &gt;&gt;&gt; q.b(&#34;b = $_&#34;)
    Condition: &#39;&#39; -- []
    &gt;&gt;&gt; q = Q(True, a=1, b=None)
    &gt;&gt;&gt; q.b(&#34;b = $_&#34;)
    Condition: &#39;b = $_&#39; -- [None]
    ```

    This feature simplifies a query construction in cases some parameters are absent.

    ```python
    &gt;&gt;&gt; def search(db, q):
    &gt;&gt;&gt;     w, params = where(q.a(&#34;a = $_&#34;) &amp; q.b(&#34;b = $_&#34;))
    &gt;&gt;&gt;     db.stmt().execute(f&#34;SELECT * FROM table {w}&#34;, *params)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; search(db, Q(a=1))      # SELECT * FROM table WHERE a = 1
    &gt;&gt;&gt; search(db, Q(a=1, b=2)) # SELECT * FROM table WHERE a = 1 AND b = 2
    &gt;&gt;&gt; search(db, Q())         # SELECT * FROM table
    ```
    &#34;&#34;&#34;
    class Attribute(Queryable[str]): # type: ignore
        def __init__(self, value):
            self.value = value

        def __call__(
            self,
            expression: Union[str, Callable[[Any], str]],
            convert: Optional[Union[Callable[[Any], Any], Any]] = None,
        ) -&gt; &#39;Conditional&#39;:
            &#34;&#34;&#34;
            Creates conditional object composed of given expression and the attribute value as parameters.

            Args:
                expression: A clause or a function generating a clause by taking the attribute value.
                convert: A function converting the attribute value to parameters.
                    If this function returns a value which is not a list, a list having only the value is used.
            Returns:
                Condition.
            &#34;&#34;&#34;
            expression = expression if isinstance(expression, str) else expression(self.value)

            if callable(convert):
                params = convert(self.value)
            elif convert is not None:
                params = convert
            else:
                params = [self.value]

            return Conditional(expression, params if isinstance(params, list) else [params])

        @property
        def all(self) -&gt; &#39;Q.Attribute&#39;:
            &#34;&#34;&#34;
            Returns composite attribute which applies conditions to every values iterated from attribute value and join them with `AND`.

            Returns:
                Composite attribute.
            &#34;&#34;&#34;
            return Q.CompositeAttribute(self.value, True)

        @property
        def any(self) -&gt; &#39;Q.Attribute&#39;:
            &#34;&#34;&#34;
            Returns composite attribute which applies conditions to every values iterated from attribute value and join them with `OR`.

            Returns:
                Composite attribute.
            &#34;&#34;&#34;
            return Q.CompositeAttribute(self.value, False)

        def __bool__(self):
            return True

        def __and__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return other if bool(self.value) else Conditional()

        def __or__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return other if not bool(self.value) else Conditional()

        def __getattr__(self, key):
            &#34;&#34;&#34;
            Exposes a method which works similarly to &#39;Q&#39; &#39;s utility method of the same name.

            ```python
            &gt;&gt;&gt; q = Q(a = 1)
            &gt;&gt;&gt; q.a.eq(&#34;col&#34;)
            Condition: &#39;col = $_&#39; -- [1]
            &gt;&gt;&gt;
            &gt;&gt;&gt; q.a.eq(&#34;col&#34;, None, &#34;t&#34;)
            Condition: &#39;t.col = $_&#39; -- [1]
            &gt;&gt;&gt;
            &gt;&gt;&gt; q.a.eq(&#34;col&#34;, lambda x: x*2, &#34;t&#34;)
            Condition: &#39;t.col = $_&#39; -- [2]
            ```
            &#34;&#34;&#34;
            method = getattr(Q, key)
            def invoke(col, convert=None, *args, **kwargs):
                if callable(convert):
                    value = convert(self.value)
                else:
                    value = convert if convert is not None else self.value
                kwargs.update({col: value})
                return method(*args, **kwargs)
            return invoke

    class CompositeAttribute(Attribute):
        def __init__(self, value, and_):
            super().__init__(value)
            self._and = and_

        def __call__(self, expression, convert=None):
            conds = [Q.Attribute(v)(expression, convert) for v in self.value]
            return Conditional.all(conds) if self._and else Conditional.any(conds)

        def __getattr__(self, key):
            method = getattr(Q, key)
            def invoke(col, convert=None, *args, **kwargs):
                def conv(v):
                    if callable(convert):
                        return convert(v)
                    else:
                        # REVIEW Replacing every parameter in the list with the same value is meaningless?
                        return convert if convert is not None else v
                conds = [method(*args, **dict(chain(kwargs.items(), [(col, conv(v))]))) for v in self.value]
                return Conditional.all(conds) if self._and else Conditional.any(conds)
            return invoke

    class NoAttribute(Attribute):
        def __init__(self):
            super().__init__(None)

        def __call__(self, expression, holder=lambda x:x):
            return Conditional()

        @property
        def all(self):
            return self

        @property
        def any(self):
            return self

        def __bool__(self):
            return False

        def __and__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return Conditional()

        def __or__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return Conditional()

        def __getattr__(self, key):
            method = getattr(Q, key)
            def invoke(col, convert=None, *args):
                return Conditional()
            return invoke

    def __init__(self, _include_none_: bool = False, **kwargs: Any):
        &#34;&#34;&#34;
        Initializes an instance.

        Args:
            _include_none_: Whether include attributes whose value is `None`.
            kwargs: Denotes pairs of attribute name and parameter.
        &#34;&#34;&#34;
        self.attributes = dict([(k, v) for k, v in kwargs.items() if _include_none_ or v is not None])

    def __getattr__(self, key) -&gt; Attribute:
        if key in self.attributes:
            return Q.Attribute(self.attributes[key])
        else:
            return Q.NoAttribute()

    @classmethod
    def of(cls, expression: str = &#34;&#34;, *params: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Creates a condition directly from an expression and parameters.

        Args:
            expression: Condition expression.
            params: Parameters used in the condition.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return Conditional(expression, list(params))

    @classmethod
    def eq(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Creates a condition applying `=` operator to columns.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def is_null(col, val):
            if val is None:
                return f&#34;{col} IS NULL&#34;, []
            elif val is True:
                return f&#34;{col}&#34;, []
            elif val is False:
                return f&#34;NOT {col}&#34;, []
            return None
        return _conditional(&#34;=&#34;, _and_, kwargs, is_null, _alias_)

    @classmethod
    def neq(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `!=`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def is_null(col, val):
            if val is None:
                return f&#34;{col} IS NOT NULL&#34;, []
            elif val is True:
                return f&#34;NOT {col}&#34;, []
            elif val is False:
                return f&#34;{col}&#34;, []
            return None
        return _conditional(&#34;!=&#34;, _and_, kwargs, is_null, _alias_)

    @classmethod
    def in_(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Sequence[Any]) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `IN`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def in_list(col, val):
            if len(val) == 0:
                return &#34;1 = 0&#34;, []
            else:
                holder = &#39;, &#39;.join([&#39;$_&#39;] * len(val))
                return f&#34;{col} IN ({holder})&#34;, val
        return _conditional(&#34;IN&#34;, _and_, kwargs, in_list, _alias_)

    @classmethod
    def not_in(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Sequence[Any]) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `NOT IN`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def in_list(col, val):
            if len(val) == 0:
                return &#34;&#34;, []
            else:
                holder = &#39;, &#39;.join([&#39;$_&#39;] * len(val))
                return f&#34;{col} NOT IN ({holder})&#34;, val
        return _conditional(&#34;NOT IN&#34;, _and_, kwargs, in_list, _alias_)

    @classmethod
    def match(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be passed to query without being escaped or enclosed.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def like(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be escaped and enclosed with wildcards (%) to execute partial match.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;%{escape_like(v)}%&#34; for k, v in kwargs.items()}, None, _alias_)

    @classmethod
    def startswith(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be escaped and appended with wildcards (%) to execute prefix match.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;{escape_like(v)}%&#34; for k, v in kwargs.items()}, None, _alias_)

    @classmethod
    def endswith(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be escaped and prepended with wildcards (%) to execute backward match.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;%{escape_like(v)}&#34; for k, v in kwargs.items()}, None, _alias_)

    @classmethod
    def lt(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `&lt;`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&lt;&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def le(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `&lt;=`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&lt;=&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def gt(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `&gt;`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&gt;&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def ge(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `&gt;=`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&gt;=&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyracmon.Q.Attribute"><code class="name">var <span class="ident">Attribute</span></code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
</dd>
<dt id="pyracmon.Q.CompositeAttribute"><code class="name">var <span class="ident">CompositeAttribute</span></code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
</dd>
<dt id="pyracmon.Q.NoAttribute"><code class="name">var <span class="ident">NoAttribute</span></code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.Q.endswith"><code class="name flex">
<span>def <span class="ident">endswith</span></span>(<span>**kwargs: str) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>LIKE</code>. Given parameters will be escaped and prepended with wildcards (%) to execute backward match.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def endswith(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `LIKE`. Given parameters will be escaped and prepended with wildcards (%) to execute backward match.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;%{escape_like(v)}&#34; for k, v in kwargs.items()}, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.eq"><code class="name flex">
<span>def <span class="ident">eq</span></span>(<span>**kwargs: Any) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a condition applying <code>=</code> operator to columns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def eq(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Creates a condition applying `=` operator to columns.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    def is_null(col, val):
        if val is None:
            return f&#34;{col} IS NULL&#34;, []
        elif val is True:
            return f&#34;{col}&#34;, []
        elif val is False:
            return f&#34;NOT {col}&#34;, []
        return None
    return _conditional(&#34;=&#34;, _and_, kwargs, is_null, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.ge"><code class="name flex">
<span>def <span class="ident">ge</span></span>(<span>**kwargs: Any) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>&gt;=</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def ge(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `&gt;=`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;&gt;=&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.gt"><code class="name flex">
<span>def <span class="ident">gt</span></span>(<span>**kwargs: Any) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>&gt;</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def gt(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `&gt;`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;&gt;&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.in_"><code class="name flex">
<span>def <span class="ident">in_</span></span>(<span>**kwargs: collections.abc.Sequence[typing.Any]) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>IN</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def in_(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Sequence[Any]) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `IN`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    def in_list(col, val):
        if len(val) == 0:
            return &#34;1 = 0&#34;, []
        else:
            holder = &#39;, &#39;.join([&#39;$_&#39;] * len(val))
            return f&#34;{col} IN ({holder})&#34;, val
    return _conditional(&#34;IN&#34;, _and_, kwargs, in_list, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.le"><code class="name flex">
<span>def <span class="ident">le</span></span>(<span>**kwargs: Any) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>&lt;=</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def le(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `&lt;=`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;&lt;=&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.like"><code class="name flex">
<span>def <span class="ident">like</span></span>(<span>**kwargs: str) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>LIKE</code>. Given parameters will be escaped and enclosed with wildcards (%) to execute partial match.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def like(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `LIKE`. Given parameters will be escaped and enclosed with wildcards (%) to execute partial match.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;%{escape_like(v)}%&#34; for k, v in kwargs.items()}, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.lt"><code class="name flex">
<span>def <span class="ident">lt</span></span>(<span>**kwargs: Any) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>&lt;</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def lt(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `&lt;`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;&lt;&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>**kwargs: str) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>LIKE</code>. Given parameters will be passed to query without being escaped or enclosed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def match(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `LIKE`. Given parameters will be passed to query without being escaped or enclosed.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;LIKE&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.neq"><code class="name flex">
<span>def <span class="ident">neq</span></span>(<span>**kwargs: Any) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>!=</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def neq(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `!=`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    def is_null(col, val):
        if val is None:
            return f&#34;{col} IS NOT NULL&#34;, []
        elif val is True:
            return f&#34;NOT {col}&#34;, []
        elif val is False:
            return f&#34;{col}&#34;, []
        return None
    return _conditional(&#34;!=&#34;, _and_, kwargs, is_null, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.not_in"><code class="name flex">
<span>def <span class="ident">not_in</span></span>(<span>**kwargs: collections.abc.Sequence[typing.Any]) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>NOT IN</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def not_in(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Sequence[Any]) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `NOT IN`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    def in_list(col, val):
        if len(val) == 0:
            return &#34;&#34;, []
        else:
            holder = &#39;, &#39;.join([&#39;$_&#39;] * len(val))
            return f&#34;{col} NOT IN ({holder})&#34;, val
    return _conditional(&#34;NOT IN&#34;, _and_, kwargs, in_list, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>expression: str = '', *params: Any) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a condition directly from an expression and parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>expression</code></strong></dt>
<dd>Condition expression.</dd>
<dt><strong><code>params</code></strong></dt>
<dd>Parameters used in the condition.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def of(cls, expression: str = &#34;&#34;, *params: Any) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Creates a condition directly from an expression and parameters.

    Args:
        expression: Condition expression.
        params: Parameters used in the condition.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return Conditional(expression, list(params))</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.startswith"><code class="name flex">
<span>def <span class="ident">startswith</span></span>(<span>**kwargs: str) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>LIKE</code>. Given parameters will be escaped and appended with wildcards (%) to execute prefix match.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def startswith(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `LIKE`. Given parameters will be escaped and appended with wildcards (%) to execute prefix match.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;{escape_like(v)}%&#34; for k, v in kwargs.items()}, None, _alias_)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.S"><code class="flex name class">
<span>class <span class="ident">S</span></span>
</code></dt>
<dd>
<div class="desc"><p>An utility class to build <code>NodeSerializer</code> .</p>
<p>This class provides factory class methods to create <code>NodeSerializer</code>
each of which works in the same way as the method of the same name declared on <code>NodeSerializer</code> .</p>
<p>Use them to supply <code>NodeSerializer</code>s to functions to serialize a graph or to create a graph schema
such as <code><a title="pyracmon.graph_dict" href="#pyracmon.graph_dict">graph_dict()</a></code> or <code><a title="pyracmon.graph_schema" href="#pyracmon.graph_schema">graph_schema()</a></code> .</p>
<pre><code class="language-python">graph_dict(
    graph,
    a = S.of(),
    b = S.head(),
)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class S(metaclass=SerializerMeta):
    &#34;&#34;&#34;
    An utility class to build `NodeSerializer` .

    This class provides factory class methods to create `NodeSerializer`
    each of which works in the same way as the method of the same name declared on `NodeSerializer` .

    Use them to supply `NodeSerializer`s to functions to serialize a graph or to create a graph schema
    such as `graph_dict` or `graph_schema` .

    ```python
    graph_dict(
        graph,
        a = S.of(),
        b = S.head(),
    )
    ```
    &#34;&#34;&#34;
    @classmethod
    def of(
        cls,
        namer: Optional[Union[str, Callable[[str], str]]] = None,
        aggregator: Optional[Union[Callable[[list[Node]], Node], Callable[[list[Node]], list[Node]]]] = None,
        *serializers: Serializer,
    ) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Create an instance of `NodeSerializer`.

        Args:
            namer: A string or naming function.
            aggregator: An aggregation function or an index of node to select in node container.
            serializer: A list of *serializer* s.
        Returns:
            Created `NodeSerializer` .
        &#34;&#34;&#34;
        return NodeSerializer(namer, aggregator, *serializers)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.S.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>namer: Union[str, Callable[[str], str], ForwardRef(None)] = None, aggregator: Union[Callable[[list[<a title="pyracmon.graph.graph.Node" href="graph/graph.html#pyracmon.graph.graph.Node">Node</a>]], <a title="pyracmon.graph.graph.Node" href="graph/graph.html#pyracmon.graph.graph.Node">Node</a>], Callable[[list[<a title="pyracmon.graph.graph.Node" href="graph/graph.html#pyracmon.graph.graph.Node">Node</a>]], list[<a title="pyracmon.graph.graph.Node" href="graph/graph.html#pyracmon.graph.graph.Node">Node</a>]], ForwardRef(None)] = None, *serializers: Callable[[ForwardRef('<a title="pyracmon.NodeContext" href="#pyracmon.NodeContext">NodeContext</a>')], Any]) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="graph/serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create an instance of <code>NodeSerializer</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>namer</code></strong></dt>
<dd>A string or naming function.</dd>
<dt><strong><code>aggregator</code></strong></dt>
<dd>An aggregation function or an index of node to select in node container.</dd>
<dt><strong><code>serializer</code></strong></dt>
<dd>A list of <em>serializer</em> s.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Created <code>NodeSerializer</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def of(
    cls,
    namer: Optional[Union[str, Callable[[str], str]]] = None,
    aggregator: Optional[Union[Callable[[list[Node]], Node], Callable[[list[Node]], list[Node]]]] = None,
    *serializers: Serializer,
) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Create an instance of `NodeSerializer`.

    Args:
        namer: A string or naming function.
        aggregator: An aggregation function or an index of node to select in node container.
        serializer: A list of *serializer* s.
    Returns:
        Created `NodeSerializer` .
    &#34;&#34;&#34;
    return NodeSerializer(namer, aggregator, *serializers)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.S.alter"><code class="name flex">
<span>def <span class="ident">alter</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.doc"><code class="name flex">
<span>def <span class="ident">doc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.each"><code class="name flex">
<span>def <span class="ident">each</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.last"><code class="name flex">
<span>def <span class="ident">last</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.name"><code class="name flex">
<span>def <span class="ident">name</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.sub"><code class="name flex">
<span>def <span class="ident">sub</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def g(*args, **kwargs):
    ns = NodeSerializer()
    nf = getattr(ns, n)
    return nf(*args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.Table"><code class="flex name class">
<span>class <span class="ident">Table</span></span>
<span>(</span><span>name: str, columns: list[<a title="pyracmon.model.Column" href="model.html#pyracmon.model.Column">Column</a>], comment: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a schema of a table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Table:
    &#34;&#34;&#34;
    This class represents a schema of a table.
    &#34;&#34;&#34;
    def __init__(self, name: str, columns: list[Column], comment: str = &#34;&#34;):
        #: Table name.
        self.name = name
        #: Columns in the table.
        self.columns = columns
        #: Comment of the table.
        self.comment = comment

    def find(self, name: str) -&gt; Optional[Column]:
        &#34;&#34;&#34;
        Find a column by name.

        Args:
            name: Column name.
        Returns:
            The column if exists, otherwise `None`.
        &#34;&#34;&#34;
        return next(filter(lambda c: c.name == name, self.columns), None)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.Table.columns"><code class="name">var <span class="ident">columns</span></code></dt>
<dd>
<div class="desc"><p>Columns in the table.</p></div>
</dd>
<dt id="pyracmon.Table.comment"><code class="name">var <span class="ident">comment</span></code></dt>
<dd>
<div class="desc"><p>Comment of the table.</p></div>
</dd>
<dt id="pyracmon.Table.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Table name.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.Table.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, name: str) ‑> Optional[<a title="pyracmon.model.Column" href="model.html#pyracmon.model.Column">Column</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Find a column by name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Column name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The column if exists, otherwise <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, name: str) -&gt; Optional[Column]:
    &#34;&#34;&#34;
    Find a column by name.

    Args:
        name: Column name.
    Returns:
        The column if exists, otherwise `None`.
    &#34;&#34;&#34;
    return next(filter(lambda c: c.name == name, self.columns), None)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.Typeable"><code class="flex name class">
<span>class <span class="ident">Typeable</span></span>
</code></dt>
<dd>
<div class="desc"><p>An interface for generic type which is resolved into a concrete type by a type parameter.</p>
<p>Inherit this class and declare static method whose signature is <code>resolve(me, bound, arg, spec) -&gt; type</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; class A(Typeable[T]):
&gt;&gt;&gt;     @staticmethod
&gt;&gt;&gt;     def resolve(me, bound, arg, spec):
&gt;&gt;&gt;         ...
&gt;&gt;&gt;         return some_type
&gt;&gt;&gt;
&gt;&gt;&gt; Typeable.resolve(A[T], int, spec)
</code></pre>
<p>Type resolution starts from <code><a title="pyracmon.Typeable.resolve" href="#pyracmon.Typeable.resolve">Typeable.resolve()</a></code> which invokes the static method with following arguments.</p>
<ul>
<li>Type to resolve itself, in this case, <code>A[T]</code>.</li>
<li>A resolved type which replace <code>T</code>.<ul>
<li><code>arg</code> is the first candidate.</li>
<li>When <code>arg</code> is also <code><a title="pyracmon.Typeable" href="#pyracmon.Typeable">Typeable</a></code> , this resolution flow is applied to it recursively until concrete type if determined.</li>
</ul>
</li>
<li><code>arg</code> is passed through as it is.</li>
<li><code>spec</code> is passed through as it is.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Typeable(Generic[T]):
    &#34;&#34;&#34;
    An interface for generic type which is resolved into a concrete type by a type parameter.

    Inherit this class and declare static method whose signature is `resolve(me, bound, arg, spec) -&gt; type`.

    ```python
    &gt;&gt;&gt; class A(Typeable[T]):
    &gt;&gt;&gt;     @staticmethod
    &gt;&gt;&gt;     def resolve(me, bound, arg, spec):
    &gt;&gt;&gt;         ...
    &gt;&gt;&gt;         return some_type
    &gt;&gt;&gt;
    &gt;&gt;&gt; Typeable.resolve(A[T], int, spec)
    ```

    Type resolution starts from `Typeable.resolve` which invokes the static method with following arguments.

    - Type to resolve itself, in this case, `A[T]`.
    - A resolved type which replace `T`.
        - `arg` is the first candidate.
        - When `arg` is also `Typeable` , this resolution flow is applied to it recursively until concrete type if determined.
    - `arg` is passed through as it is.
    - `spec` is passed through as it is.
    &#34;&#34;&#34;
    @staticmethod
    def resolve(typeable, arg: type, spec: Any) -&gt; type:
        &#34;&#34;&#34;
        Resolve a `Typeable` type into a concrete type by a type for its type parameter.

        Args:
            typeable: `Typeable` type having a generic type parameter.
            arg: Type to replace a type parameter.
            spec: An object containing information for schema generation.
        Returns:
            Resolved type.
        &#34;&#34;&#34;
        if get_origin(typeable) is Typeable:
            raise ValueError(f&#34;Typeable should not be used directly. Use inheriting class instead.&#34;)

        bound = get_args(typeable)[0]

        if isinstance(bound, TypeVar):
            return Typeable.resolve(typeable[arg], arg, spec)
        elif issubgeneric(bound, Typeable):
            bound = Typeable.resolve(bound, arg, spec)
            return typeable.resolve(typeable, bound, arg, spec)
        else:
            return typeable.resolve(typeable, bound, arg, spec)

    @staticmethod
    def is_resolved(typeable: type[&#39;Typeable&#39;]) -&gt; bool:
        &#34;&#34;&#34;
        Checks a type parameter of given `Typeable` is alredy resolved.

        Args:
            typeable: `Typeable` type having a generic type parameter.
        Returns:
            Whether the type parameter is already resolved or not.
        &#34;&#34;&#34;
        bound = get_args(typeable)[0]
        if isinstance(bound, TypeVar):
            return False
        elif issubgeneric(bound, Typeable):
            return Typeable.is_resolved(bound)
        else:
            return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.graph.typing.DynamicType" href="graph/typing.html#pyracmon.graph.typing.DynamicType">DynamicType</a></li>
<li><a title="pyracmon.graph.typing.Extend" href="graph/typing.html#pyracmon.graph.typing.Extend">Extend</a></li>
<li><a title="pyracmon.graph.typing.Shrink" href="graph/typing.html#pyracmon.graph.typing.Shrink">Shrink</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.Typeable.is_resolved"><code class="name flex">
<span>def <span class="ident">is_resolved</span></span>(<span>typeable: type['<a title="pyracmon.Typeable" href="#pyracmon.Typeable">Typeable</a>']) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks a type parameter of given <code><a title="pyracmon.Typeable" href="#pyracmon.Typeable">Typeable</a></code> is alredy resolved.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>typeable</code></strong></dt>
<dd><code><a title="pyracmon.Typeable" href="#pyracmon.Typeable">Typeable</a></code> type having a generic type parameter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the type parameter is already resolved or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_resolved(typeable: type[&#39;Typeable&#39;]) -&gt; bool:
    &#34;&#34;&#34;
    Checks a type parameter of given `Typeable` is alredy resolved.

    Args:
        typeable: `Typeable` type having a generic type parameter.
    Returns:
        Whether the type parameter is already resolved or not.
    &#34;&#34;&#34;
    bound = get_args(typeable)[0]
    if isinstance(bound, TypeVar):
        return False
    elif issubgeneric(bound, Typeable):
        return Typeable.is_resolved(bound)
    else:
        return True</code></pre>
</details>
</dd>
<dt id="pyracmon.Typeable.resolve"><code class="name flex">
<span>def <span class="ident">resolve</span></span>(<span>typeable, arg: type, spec: Any) ‑> type</span>
</code></dt>
<dd>
<div class="desc"><p>Resolve a <code><a title="pyracmon.Typeable" href="#pyracmon.Typeable">Typeable</a></code> type into a concrete type by a type for its type parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>typeable</code></strong></dt>
<dd><code><a title="pyracmon.Typeable" href="#pyracmon.Typeable">Typeable</a></code> type having a generic type parameter.</dd>
<dt><strong><code>arg</code></strong></dt>
<dd>Type to replace a type parameter.</dd>
<dt><strong><code>spec</code></strong></dt>
<dd>An object containing information for schema generation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Resolved type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def resolve(typeable, arg: type, spec: Any) -&gt; type:
    &#34;&#34;&#34;
    Resolve a `Typeable` type into a concrete type by a type for its type parameter.

    Args:
        typeable: `Typeable` type having a generic type parameter.
        arg: Type to replace a type parameter.
        spec: An object containing information for schema generation.
    Returns:
        Resolved type.
    &#34;&#34;&#34;
    if get_origin(typeable) is Typeable:
        raise ValueError(f&#34;Typeable should not be used directly. Use inheriting class instead.&#34;)

    bound = get_args(typeable)[0]

    if isinstance(bound, TypeVar):
        return Typeable.resolve(typeable[arg], arg, spec)
    elif issubgeneric(bound, Typeable):
        bound = Typeable.resolve(bound, arg, spec)
        return typeable.resolve(typeable, bound, arg, spec)
    else:
        return typeable.resolve(typeable, bound, arg, spec)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyracmon.batch" href="batch.html">pyracmon.batch</a></code></li>
<li><code><a title="pyracmon.clause" href="clause.html">pyracmon.clause</a></code></li>
<li><code><a title="pyracmon.config" href="config.html">pyracmon.config</a></code></li>
<li><code><a title="pyracmon.connection" href="connection.html">pyracmon.connection</a></code></li>
<li><code><a title="pyracmon.context" href="context.html">pyracmon.context</a></code></li>
<li><code><a title="pyracmon.dbapi" href="dbapi.html">pyracmon.dbapi</a></code></li>
<li><code><a title="pyracmon.dialect" href="dialect/index.html">pyracmon.dialect</a></code></li>
<li><code><a title="pyracmon.graph" href="graph/index.html">pyracmon.graph</a></code></li>
<li><code><a title="pyracmon.marker" href="marker.html">pyracmon.marker</a></code></li>
<li><code><a title="pyracmon.mixin" href="mixin.html">pyracmon.mixin</a></code></li>
<li><code><a title="pyracmon.model" href="model.html">pyracmon.model</a></code></li>
<li><code><a title="pyracmon.model_graph" href="model_graph.html">pyracmon.model_graph</a></code></li>
<li><code><a title="pyracmon.query" href="query.html">pyracmon.query</a></code></li>
<li><code><a title="pyracmon.query_graph" href="query_graph.html">pyracmon.query_graph</a></code></li>
<li><code><a title="pyracmon.select" href="select.html">pyracmon.select</a></code></li>
<li><code><a title="pyracmon.sql" href="sql.html">pyracmon.sql</a></code></li>
<li><code><a title="pyracmon.stub" href="stub.html">pyracmon.stub</a></code></li>
<li><code><a title="pyracmon.testing" href="testing/index.html">pyracmon.testing</a></code></li>
<li><code><a title="pyracmon.util" href="util.html">pyracmon.util</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="pyracmon.append_rows" href="#pyracmon.append_rows">append_rows</a></code></li>
<li><code><a title="pyracmon.connect" href="#pyracmon.connect">connect</a></code></li>
<li><code><a title="pyracmon.declare_models" href="#pyracmon.declare_models">declare_models</a></code></li>
<li><code><a title="pyracmon.define_model" href="#pyracmon.define_model">define_model</a></code></li>
<li><code><a title="pyracmon.document_type" href="#pyracmon.document_type">document_type</a></code></li>
<li><code><a title="pyracmon.escape_like" href="#pyracmon.escape_like">escape_like</a></code></li>
<li><code><a title="pyracmon.graph_dict" href="#pyracmon.graph_dict">graph_dict</a></code></li>
<li><code><a title="pyracmon.graph_schema" href="#pyracmon.graph_schema">graph_schema</a></code></li>
<li><code><a title="pyracmon.graph_template" href="#pyracmon.graph_template">graph_template</a></code></li>
<li><code><a title="pyracmon.holders" href="#pyracmon.holders">holders</a></code></li>
<li><code><a title="pyracmon.new_graph" href="#pyracmon.new_graph">new_graph</a></code></li>
<li><code><a title="pyracmon.order_by" href="#pyracmon.order_by">order_by</a></code></li>
<li><code><a title="pyracmon.ranged_by" href="#pyracmon.ranged_by">ranged_by</a></code></li>
<li><code><a title="pyracmon.read_row" href="#pyracmon.read_row">read_row</a></code></li>
<li><code><a title="pyracmon.values" href="#pyracmon.values">values</a></code></li>
<li><code><a title="pyracmon.walk_schema" href="#pyracmon.walk_schema">walk_schema</a></code></li>
<li><code><a title="pyracmon.where" href="#pyracmon.where">where</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyracmon.CRUDMixin" href="#pyracmon.CRUDMixin">CRUDMixin</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.CRUDMixin.count" href="#pyracmon.CRUDMixin.count">count</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.delete" href="#pyracmon.CRUDMixin.delete">delete</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.delete_many" href="#pyracmon.CRUDMixin.delete_many">delete_many</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.delete_where" href="#pyracmon.CRUDMixin.delete_where">delete_where</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.fetch" href="#pyracmon.CRUDMixin.fetch">fetch</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.fetch_many" href="#pyracmon.CRUDMixin.fetch_many">fetch_many</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.fetch_one" href="#pyracmon.CRUDMixin.fetch_one">fetch_one</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.fetch_where" href="#pyracmon.CRUDMixin.fetch_where">fetch_where</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.insert" href="#pyracmon.CRUDMixin.insert">insert</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.insert_many" href="#pyracmon.CRUDMixin.insert_many">insert_many</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.last_sequences" href="#pyracmon.CRUDMixin.last_sequences">last_sequences</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.support_returning" href="#pyracmon.CRUDMixin.support_returning">support_returning</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.update" href="#pyracmon.CRUDMixin.update">update</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.update_many" href="#pyracmon.CRUDMixin.update_many">update_many</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.update_where" href="#pyracmon.CRUDMixin.update_where">update_where</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.Column" href="#pyracmon.Column">Column</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.Column.comment" href="#pyracmon.Column.comment">comment</a></code></li>
<li><code><a title="pyracmon.Column.fk" href="#pyracmon.Column.fk">fk</a></code></li>
<li><code><a title="pyracmon.Column.incremental" href="#pyracmon.Column.incremental">incremental</a></code></li>
<li><code><a title="pyracmon.Column.name" href="#pyracmon.Column.name">name</a></code></li>
<li><code><a title="pyracmon.Column.nullable" href="#pyracmon.Column.nullable">nullable</a></code></li>
<li><code><a title="pyracmon.Column.pk" href="#pyracmon.Column.pk">pk</a></code></li>
<li><code><a title="pyracmon.Column.ptype" href="#pyracmon.Column.ptype">ptype</a></code></li>
<li><code><a title="pyracmon.Column.type_info" href="#pyracmon.Column.type_info">type_info</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.Conditional" href="#pyracmon.Conditional">Conditional</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.Conditional.all" href="#pyracmon.Conditional.all">all</a></code></li>
<li><code><a title="pyracmon.Conditional.any" href="#pyracmon.Conditional.any">any</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.Connection" href="#pyracmon.Connection">Connection</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.Connection.api" href="#pyracmon.Connection.api">api</a></code></li>
<li><code><a title="pyracmon.Connection.close" href="#pyracmon.Connection.close">close</a></code></li>
<li><code><a title="pyracmon.Connection.commit" href="#pyracmon.Connection.commit">commit</a></code></li>
<li><code><a title="pyracmon.Connection.conn" href="#pyracmon.Connection.conn">conn</a></code></li>
<li><code><a title="pyracmon.Connection.context" href="#pyracmon.Connection.context">context</a></code></li>
<li><code><a title="pyracmon.Connection.cursor" href="#pyracmon.Connection.cursor">cursor</a></code></li>
<li><code><a title="pyracmon.Connection.identifier" href="#pyracmon.Connection.identifier">identifier</a></code></li>
<li><code><a title="pyracmon.Connection.rollback" href="#pyracmon.Connection.rollback">rollback</a></code></li>
<li><code><a title="pyracmon.Connection.stmt" href="#pyracmon.Connection.stmt">stmt</a></code></li>
<li><code><a title="pyracmon.Connection.use" href="#pyracmon.Connection.use">use</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.ConnectionContext" href="#pyracmon.ConnectionContext">ConnectionContext</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.ConnectionContext.config" href="#pyracmon.ConnectionContext.config">config</a></code></li>
<li><code><a title="pyracmon.ConnectionContext.configure" href="#pyracmon.ConnectionContext.configure">configure</a></code></li>
<li><code><a title="pyracmon.ConnectionContext.execute" href="#pyracmon.ConnectionContext.execute">execute</a></code></li>
<li><code><a title="pyracmon.ConnectionContext.executemany" href="#pyracmon.ConnectionContext.executemany">executemany</a></code></li>
<li><code><a title="pyracmon.ConnectionContext.identifier" href="#pyracmon.ConnectionContext.identifier">identifier</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.ContainerView" href="#pyracmon.ContainerView">ContainerView</a></code></h4>
</li>
<li>
<h4><code><a title="pyracmon.Expression" href="#pyracmon.Expression">Expression</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.Expression.expression" href="#pyracmon.Expression.expression">expression</a></code></li>
<li><code><a title="pyracmon.Expression.params" href="#pyracmon.Expression.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.Graph" href="#pyracmon.Graph">Graph</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.Graph.append" href="#pyracmon.Graph.append">append</a></code></li>
<li><code><a title="pyracmon.Graph.containers" href="#pyracmon.Graph.containers">containers</a></code></li>
<li><code><a title="pyracmon.Graph.replace" href="#pyracmon.Graph.replace">replace</a></code></li>
<li><code><a title="pyracmon.Graph.roots" href="#pyracmon.Graph.roots">roots</a></code></li>
<li><code><a title="pyracmon.Graph.template" href="#pyracmon.Graph.template">template</a></code></li>
<li><code><a title="pyracmon.Graph.view" href="#pyracmon.Graph.view">view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.GraphSchema" href="#pyracmon.GraphSchema">GraphSchema</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.GraphSchema.schema" href="#pyracmon.GraphSchema.schema">schema</a></code></li>
<li><code><a title="pyracmon.GraphSchema.schema_of" href="#pyracmon.GraphSchema.schema_of">schema_of</a></code></li>
<li><code><a title="pyracmon.GraphSchema.serialize" href="#pyracmon.GraphSchema.serialize">serialize</a></code></li>
<li><code><a title="pyracmon.GraphSchema.serializers" href="#pyracmon.GraphSchema.serializers">serializers</a></code></li>
<li><code><a title="pyracmon.GraphSchema.spec" href="#pyracmon.GraphSchema.spec">spec</a></code></li>
<li><code><a title="pyracmon.GraphSchema.template" href="#pyracmon.GraphSchema.template">template</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.GraphView" href="#pyracmon.GraphView">GraphView</a></code></h4>
</li>
<li>
<h4><code><a title="pyracmon.Model" href="#pyracmon.Model">Model</a></code></h4>
</li>
<li>
<h4><code><a title="pyracmon.Node" href="#pyracmon.Node">Node</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.Node.Children" href="#pyracmon.Node.Children">Children</a></code></li>
<li><code><a title="pyracmon.Node.add_child" href="#pyracmon.Node.add_child">add_child</a></code></li>
<li><code><a title="pyracmon.Node.entity" href="#pyracmon.Node.entity">entity</a></code></li>
<li><code><a title="pyracmon.Node.has_child" href="#pyracmon.Node.has_child">has_child</a></code></li>
<li><code><a title="pyracmon.Node.name" href="#pyracmon.Node.name">name</a></code></li>
<li><code><a title="pyracmon.Node.prop" href="#pyracmon.Node.prop">prop</a></code></li>
<li><code><a title="pyracmon.Node.view" href="#pyracmon.Node.view">view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.NodeContainer" href="#pyracmon.NodeContainer">NodeContainer</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.NodeContainer.append" href="#pyracmon.NodeContainer.append">append</a></code></li>
<li><code><a title="pyracmon.NodeContainer.name" href="#pyracmon.NodeContainer.name">name</a></code></li>
<li><code><a title="pyracmon.NodeContainer.prop" href="#pyracmon.NodeContainer.prop">prop</a></code></li>
<li><code><a title="pyracmon.NodeContainer.view" href="#pyracmon.NodeContainer.view">view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.NodeContext" href="#pyracmon.NodeContext">NodeContext</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.NodeContext.context" href="#pyracmon.NodeContext.context">context</a></code></li>
<li><code><a title="pyracmon.NodeContext.node" href="#pyracmon.NodeContext.node">node</a></code></li>
<li><code><a title="pyracmon.NodeContext.params" href="#pyracmon.NodeContext.params">params</a></code></li>
<li><code><a title="pyracmon.NodeContext.serialize" href="#pyracmon.NodeContext.serialize">serialize</a></code></li>
<li><code><a title="pyracmon.NodeContext.value" href="#pyracmon.NodeContext.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.NodeView" href="#pyracmon.NodeView">NodeView</a></code></h4>
</li>
<li>
<h4><code><a title="pyracmon.Q" href="#pyracmon.Q">Q</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.Q.Attribute" href="#pyracmon.Q.Attribute">Attribute</a></code></li>
<li><code><a title="pyracmon.Q.CompositeAttribute" href="#pyracmon.Q.CompositeAttribute">CompositeAttribute</a></code></li>
<li><code><a title="pyracmon.Q.NoAttribute" href="#pyracmon.Q.NoAttribute">NoAttribute</a></code></li>
<li><code><a title="pyracmon.Q.endswith" href="#pyracmon.Q.endswith">endswith</a></code></li>
<li><code><a title="pyracmon.Q.eq" href="#pyracmon.Q.eq">eq</a></code></li>
<li><code><a title="pyracmon.Q.ge" href="#pyracmon.Q.ge">ge</a></code></li>
<li><code><a title="pyracmon.Q.gt" href="#pyracmon.Q.gt">gt</a></code></li>
<li><code><a title="pyracmon.Q.in_" href="#pyracmon.Q.in_">in_</a></code></li>
<li><code><a title="pyracmon.Q.le" href="#pyracmon.Q.le">le</a></code></li>
<li><code><a title="pyracmon.Q.like" href="#pyracmon.Q.like">like</a></code></li>
<li><code><a title="pyracmon.Q.lt" href="#pyracmon.Q.lt">lt</a></code></li>
<li><code><a title="pyracmon.Q.match" href="#pyracmon.Q.match">match</a></code></li>
<li><code><a title="pyracmon.Q.neq" href="#pyracmon.Q.neq">neq</a></code></li>
<li><code><a title="pyracmon.Q.not_in" href="#pyracmon.Q.not_in">not_in</a></code></li>
<li><code><a title="pyracmon.Q.of" href="#pyracmon.Q.of">of</a></code></li>
<li><code><a title="pyracmon.Q.startswith" href="#pyracmon.Q.startswith">startswith</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.S" href="#pyracmon.S">S</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.S.alter" href="#pyracmon.S.alter">alter</a></code></li>
<li><code><a title="pyracmon.S.at" href="#pyracmon.S.at">at</a></code></li>
<li><code><a title="pyracmon.S.doc" href="#pyracmon.S.doc">doc</a></code></li>
<li><code><a title="pyracmon.S.each" href="#pyracmon.S.each">each</a></code></li>
<li><code><a title="pyracmon.S.fold" href="#pyracmon.S.fold">fold</a></code></li>
<li><code><a title="pyracmon.S.head" href="#pyracmon.S.head">head</a></code></li>
<li><code><a title="pyracmon.S.last" href="#pyracmon.S.last">last</a></code></li>
<li><code><a title="pyracmon.S.merge" href="#pyracmon.S.merge">merge</a></code></li>
<li><code><a title="pyracmon.S.name" href="#pyracmon.S.name">name</a></code></li>
<li><code><a title="pyracmon.S.of" href="#pyracmon.S.of">of</a></code></li>
<li><code><a title="pyracmon.S.select" href="#pyracmon.S.select">select</a></code></li>
<li><code><a title="pyracmon.S.sub" href="#pyracmon.S.sub">sub</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.Table" href="#pyracmon.Table">Table</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.Table.columns" href="#pyracmon.Table.columns">columns</a></code></li>
<li><code><a title="pyracmon.Table.comment" href="#pyracmon.Table.comment">comment</a></code></li>
<li><code><a title="pyracmon.Table.find" href="#pyracmon.Table.find">find</a></code></li>
<li><code><a title="pyracmon.Table.name" href="#pyracmon.Table.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.Typeable" href="#pyracmon.Typeable">Typeable</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.Typeable.is_resolved" href="#pyracmon.Typeable.is_resolved">is_resolved</a></code></li>
<li><code><a title="pyracmon.Typeable.resolve" href="#pyracmon.Typeable.resolve">resolve</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>