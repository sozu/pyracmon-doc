<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyracmon API documentation</title>
<meta name="description" content="Base module of pyracmon exporting commonly used objects.
Use `*` simply to import them …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>pyracmon</code></h1>
</header>
<section id="section-intro">
<p>Base module of pyracmon exporting commonly used objects.
Use <code>*</code> simply to import them.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from pyracmon import *
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Base module of pyracmon exporting commonly used objects.  Use `*` simply to import them.

&gt;&gt;&gt; from pyracmon import *
&#34;&#34;&#34;
import sys
import types
from typing import *
from pyracmon.config import pyracmon, default_config
from pyracmon.connection import connect, Connection
from pyracmon.context import ConnectionContext
from pyracmon.graph.serialize import NodeSerializer
from pyracmon.mixin import CRUDMixin
from pyracmon.select import read_row
from pyracmon.model import define_model, Table, Column, Model
from pyracmon.model_graph import GraphEntityMixin
from pyracmon.query import Q, Expression, Conditional, escape_like, where, order_by, ranged_by
from pyracmon.graph import new_graph, S
from pyracmon.graph.graph import Graph, GraphView, NodeContainer, ContainerView, Node, NodeView, NodeChildrenView
from pyracmon.graph.spec import GraphSpec
from pyracmon.graph.template import GraphTemplate
from pyracmon.graph.schema import TypedDict, document_type, Typeable, walk_schema, GraphSchema


__all__ = [
    &#34;pyracmon&#34;,
    &#34;connect&#34;,
    &#34;Connection&#34;,
    &#34;ConnectionContext&#34;,
    &#34;CRUDMixin&#34;,
    &#34;read_row&#34;,
    &#34;define_model&#34;,
    &#34;Table&#34;,
    &#34;Column&#34;,
    &#34;Q&#34;,
    &#34;Expression&#34;,
    &#34;Conditional&#34;,
    &#34;where&#34;,
    &#34;escape_like&#34;,
    &#34;order_by&#34;,
    &#34;ranged_by&#34;,
    &#34;new_graph&#34;,
    &#34;S&#34;,
    &#34;Graph&#34;,
    &#34;GraphView&#34;,
    &#34;NodeContainer&#34;,
    &#34;ContainerView&#34;,
    &#34;Node&#34;,
    &#34;NodeView&#34;,
    &#34;NodeChildrenView&#34;,
    &#34;TypedDict&#34;,
    &#34;document_type&#34;,
    &#34;Typeable&#34;,
    &#34;walk_schema&#34;,
    &#34;GraphSchema&#34;,
    &#34;Model&#34;,
    &#34;declare_models&#34;,
    &#34;graph_template&#34;,
    &#34;graph_dict&#34;,
    &#34;graph_schema&#34;,
]


def declare_models(
    dialect: types.ModuleType,
    db: Connection,
    module: Union[types.ModuleType, str] = __name__,
    mixins: List[type] = [],
    excludes: List[str] = None,
    includes: List[str] = None,
) -&gt; List[Type[Model]]:
    &#34;&#34;&#34;
    Declare model types read from database into the specified module.

    Args:
        dialect: A module exporting `read_schema` function and `mixins` classes.
            `pyracmon.dialect.postgresql` and `pyracmon.dialect.mysql` are available.
        db: Connection already connected to database.
        module: A module or module name where the declarations are located.
        mixins: Additional mixin classes for declaring model types.
        excludes: Excluding table names.
        includes: Including table names. When this argument is omitted, all tables except for specified in `excludes` are declared.
    Returns:
        Declared model types.
    &#34;&#34;&#34;
    tables = dialect.read_schema(db, excludes, includes)
    models = []
    for t in tables:
        m = define_model(t, mixins + dialect.mixins + [CRUDMixin, GraphEntityMixin, Model])
        if isinstance(module, types.ModuleType):
            module.__dict__[t.name] = m
        else:
            sys.modules[module].__dict__[t.name] = m
        models.append(m)
    return models


def graph_template(*bases: GraphTemplate, **definitions: type) -&gt; GraphTemplate:
    &#34;&#34;&#34;
    Create a graph template on the default `GraphSpec` predefined to handle model object in appropriate ways.

    See `pyracmon.graph.GraphSpec.new_template` for the detail of definitions.

    Args:
        bases: Base templates whose properties and relations are merged into new template.
        definitions: Definitions of template properties.
    Returns:
        Graph template.
    &#34;&#34;&#34;
    return default_config().graph_spec.new_template(*bases, **definitions)


def graph_dict(graph: GraphView, **settings: NodeSerializer) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Serialize a graph into a `dict` under the default specification.

    See `pyracmon.graph.GraphSpec.to_dict` for the detail of serialization settings.

    Args:
        graph: A view of the graph.
        settings: Serialization settings.
    Returns:
        Serialization result.
    &#34;&#34;&#34;
    return default_config().graph_spec.to_dict(graph, **settings)


def graph_schema(template: GraphTemplate, **settings: NodeSerializer) -&gt; GraphSchema:
    &#34;&#34;&#34;
    Creates `GraphSchema` under the default specifications.

    `GraphSchema` represents the structure of `dict` serialized a graph of the template with given serialization settings.
    Use this, for example, to document REST API which responds serialized graph in JSON format. 

    See `pyracmon.graph.GraphSpec.to_schema` for the detail of serialization settings.

    Args:
        template: A template of serializing graph.
        settings: Serialization settings.
    Returns:
        Schema of serialization result.
    &#34;&#34;&#34;
    return default_config().graph_spec.to_schema(template, **settings)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="pyracmon.config" href="config.html">pyracmon.config</a></code></dt>
<dd>
<div class="desc"><p>This module exports types and functions for configurations …</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.connection" href="connection.html">pyracmon.connection</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.context" href="context.html">pyracmon.context</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.dialect" href="dialect/index.html">pyracmon.dialect</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.graph" href="graph/index.html">pyracmon.graph</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.marker" href="marker.html">pyracmon.marker</a></code></dt>
<dd>
<div class="desc"><p>This module provides the abstration mechanism for marker creation used to embed parameters in a query …</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.mixin" href="mixin.html">pyracmon.mixin</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.model" href="model.html">pyracmon.model</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.model_graph" href="model_graph.html">pyracmon.model_graph</a></code></dt>
<dd>
<div class="desc"><p>This module provides graph specifications to deal with model types …</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.query" href="query.html">pyracmon.query</a></code></dt>
<dd>
<div class="desc"><p>This module exports types and functions for query construction …</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.select" href="select.html">pyracmon.select</a></code></dt>
<dd>
<div class="desc"><p>This module exports types and functions used for <code>SELECT</code> queries …</p></div>
</dd>
<dt><code class="name"><a title="pyracmon.sql" href="sql.html">pyracmon.sql</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.testing" href="testing/index.html">pyracmon.testing</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="pyracmon.util" href="util.html">pyracmon.util</a></code></dt>
<dd>
<div class="desc"><p>Utility types and functions for internal use.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyracmon.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>api: module, *args: Any, **kwargs: Any) ‑> <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a></span>
</code></dt>
<dd>
<div class="desc"><p>Connects to DB by passing arguments to DB-API 2.0 module.</p>
<p>Every optional argument is passed to <code>api.connect</code> and returns the <code><a title="pyracmon.Connection" href="#pyracmon.Connection">Connection</a></code> object which wraps obtained DB connection.</p>
<p>Here shows an example connecting to database and executing query.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; import psycopg2
&gt;&gt;&gt; from pyracmon import connect
&gt;&gt;&gt; db = connect(psycopg2, host=&quot;localhost&quot;, port=5432, dbname=&quot;pyracmon&quot;, user=&quot;postgres&quot;, password=&quot;postgres&quot;)
&gt;&gt;&gt; c = db.stmt().execute(&quot;SELECT 1&quot;)
&gt;&gt;&gt; assert c.fetchone()[0] == 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>api</code></strong></dt>
<dd>DB-API 2.0 module which exports <code><a title="pyracmon.connect" href="#pyracmon.connect">connect()</a></code> function.</dd>
<dt><strong><code>args</code></strong></dt>
<dd>Positional arguments passed to <code>api.connect</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Keyword arguments passed to <code>api.connect</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Wrapper of DB-API 2.0 connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connect(api: types.ModuleType, *args: Any, **kwargs: Any) -&gt; &#39;Connection&#39;:
    &#34;&#34;&#34;
    Connects to DB by passing arguments to DB-API 2.0 module.

    Every optional argument is passed to `api.connect` and returns the `Connection` object which wraps obtained DB connection.

    Here shows an example connecting to database and executing query.

    &gt;&gt;&gt; import psycopg2
    &gt;&gt;&gt; from pyracmon import connect
    &gt;&gt;&gt; db = connect(psycopg2, host=&#34;localhost&#34;, port=5432, dbname=&#34;pyracmon&#34;, user=&#34;postgres&#34;, password=&#34;postgres&#34;)
    &gt;&gt;&gt; c = db.stmt().execute(&#34;SELECT 1&#34;)
    &gt;&gt;&gt; assert c.fetchone()[0] == 1

    Args:
        api: DB-API 2.0 module which exports `connect` function.
        args: Positional arguments passed to `api.connect`.
        kwargs: Keyword arguments passed to `api.connect`.
    Returns:
        Wrapper of DB-API 2.0 connection.
    &#34;&#34;&#34;
    return Connection(api, api.connect(*args, **kwargs), None)</code></pre>
</details>
</dd>
<dt id="pyracmon.declare_models"><code class="name flex">
<span>def <span class="ident">declare_models</span></span>(<span>dialect: module, db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, module: Union[module, str] = 'pyracmon', mixins: List[type] = [], excludes: List[str] = None, includes: List[str] = None) ‑> List[Type[<a title="pyracmon.model.Model" href="model.html#pyracmon.model.Model">Model</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Declare model types read from database into the specified module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dialect</code></strong></dt>
<dd>A module exporting <code>read_schema</code> function and <code>mixins</code> classes.
<code><a title="pyracmon.dialect.postgresql" href="dialect/postgresql.html">pyracmon.dialect.postgresql</a></code> and <code><a title="pyracmon.dialect.mysql" href="dialect/mysql.html">pyracmon.dialect.mysql</a></code> are available.</dd>
<dt><strong><code>db</code></strong></dt>
<dd>Connection already connected to database.</dd>
<dt><strong><code>module</code></strong></dt>
<dd>A module or module name where the declarations are located.</dd>
<dt><strong><code>mixins</code></strong></dt>
<dd>Additional mixin classes for declaring model types.</dd>
<dt><strong><code>excludes</code></strong></dt>
<dd>Excluding table names.</dd>
<dt><strong><code>includes</code></strong></dt>
<dd>Including table names. When this argument is omitted, all tables except for specified in <code>excludes</code> are declared.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Declared model types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def declare_models(
    dialect: types.ModuleType,
    db: Connection,
    module: Union[types.ModuleType, str] = __name__,
    mixins: List[type] = [],
    excludes: List[str] = None,
    includes: List[str] = None,
) -&gt; List[Type[Model]]:
    &#34;&#34;&#34;
    Declare model types read from database into the specified module.

    Args:
        dialect: A module exporting `read_schema` function and `mixins` classes.
            `pyracmon.dialect.postgresql` and `pyracmon.dialect.mysql` are available.
        db: Connection already connected to database.
        module: A module or module name where the declarations are located.
        mixins: Additional mixin classes for declaring model types.
        excludes: Excluding table names.
        includes: Including table names. When this argument is omitted, all tables except for specified in `excludes` are declared.
    Returns:
        Declared model types.
    &#34;&#34;&#34;
    tables = dialect.read_schema(db, excludes, includes)
    models = []
    for t in tables:
        m = define_model(t, mixins + dialect.mixins + [CRUDMixin, GraphEntityMixin, Model])
        if isinstance(module, types.ModuleType):
            module.__dict__[t.name] = m
        else:
            sys.modules[module].__dict__[t.name] = m
        models.append(m)
    return models</code></pre>
</details>
</dd>
<dt id="pyracmon.define_model"><code class="name flex">
<span>def <span class="ident">define_model</span></span>(<span>table_: <a title="pyracmon.model.Table" href="model.html#pyracmon.model.Table">Table</a>, mixins: List[type] = []) ‑> type</span>
</code></dt>
<dd>
<div class="desc"><p>Create a model type representing a table.</p>
<p>Model type inherits all types in <code>mixins</code> in order.
When the same attribute is defined in multiple mixin types, the former overrides the latter.</p>
<p>Every model type has following attributes:</p>
<table>
<thead>
<tr>
<th align="left">name</th>
<th align="left">type</th>
<th align="left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">name</td>
<td align="left"><code>str</code></td>
<td align="left">Name of the table.</td>
</tr>
<tr>
<td align="left">table</td>
<td align="left"><code><a title="pyracmon.Table" href="#pyracmon.Table">Table</a></code></td>
<td align="left">Table schema.</td>
</tr>
<tr>
<td align="left">columns</td>
<td align="left"><code>List[<a title="pyracmon.Column" href="#pyracmon.Column">Column</a>]</code></td>
<td align="left">List of column schemas.</td>
</tr>
<tr>
<td align="left">column</td>
<td align="left"><code>Any</code></td>
<td align="left">An object whose attribute exposes of column schema of its name.</td>
</tr>
</tbody>
</table>
<p>Model instances are created by passing the constructor keyword arguments holding column names and values.
The constructor does not require all of columns.
Omitted columns don't affect predefined operations such as <code><a title="pyracmon.CRUDMixin.insert" href="#pyracmon.CRUDMixin.insert">CRUDMixin.insert()</a></code> .
If <code>not null</code> constraint exists on the column, it of course denies the insertion.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # CREATE TABLE t1 (col1 int, col2 text, col3 text);
&gt;&gt;&gt; table = define_model(&quot;t1&quot;)
&gt;&gt;&gt; model = table(col1=1, col2=&quot;a&quot;)
</code></pre>
<p>Attributes are also assignable by normal setter. If attribute name is not a valid column name, <code>TypeError</code> raises.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; model.col3 = &quot;b&quot;
</code></pre>
<p>Model instance supports iteration which yields pairs of assigned column schema and its value.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; for c, v in model:
&gt;&gt;&gt;     print(f&quot;{c.name} = {v}&quot;)
col1 = 1
col2 = a
col3 = b
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>table__</code></strong></dt>
<dd>Table schema.</dd>
<dt><strong><code>mixin</code></strong></dt>
<dd>Mixin types providing class methods to the model type.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def define_model(table_: Table, mixins: List[type] = []) -&gt; type:
    &#34;&#34;&#34;
    Create a model type representing a table.

    Model type inherits all types in `mixins` in order.
    When the same attribute is defined in multiple mixin types, the former overrides the latter.

    Every model type has following attributes:

    |name|type|description|
    |:---|:---|:---|
    |name|`str`|Name of the table.|
    |table|`Table`|Table schema.|
    |columns|`List[Column]`|List of column schemas.|
    |column|`Any`|An object whose attribute exposes of column schema of its name.|

    Model instances are created by passing the constructor keyword arguments holding column names and values.
    The constructor does not require all of columns.
    Omitted columns don&#39;t affect predefined operations such as `CRUDMixin.insert` .
    If `not null` constraint exists on the column, it of course denies the insertion.

    &gt;&gt;&gt; # CREATE TABLE t1 (col1 int, col2 text, col3 text);
    &gt;&gt;&gt; table = define_model(&#34;t1&#34;)
    &gt;&gt;&gt; model = table(col1=1, col2=&#34;a&#34;)

    Attributes are also assignable by normal setter. If attribute name is not a valid column name, `TypeError` raises.

    &gt;&gt;&gt; model.col3 = &#34;b&#34;

    Model instance supports iteration which yields pairs of assigned column schema and its value.

    &gt;&gt;&gt; for c, v in model:
    &gt;&gt;&gt;     print(f&#34;{c.name} = {v}&#34;)
    col1 = 1
    col2 = a
    col3 = b

    Args:
        table__: Table schema.
        mixin: Mixin types providing class methods to the model type.
    Returns:
        Model type.
    &#34;&#34;&#34;
    column_names = {c.name for c in table_.columns}

    class Meta(type):
        name = table_.name
        table = table_
        columns = table_.columns

        @classmethod
        def shrink(cls, excludes, includes=None):
            &#34;&#34;&#34;
            Creates new model type containing subset of columns.

            Parameters
            ----------
            excludes: [str]
                Column names to exclude.
            includes: [str]
                Column names to include.

            Returns
            -------
            type
                Created model type.
            &#34;&#34;&#34;
            cols = [c for c in cls.columns if (not includes or c.name in includes) and c.name not in excludes]
            return define_model(Table(cls.name, cols, cls.table.comment), mixins)

    class Columns:
        def __init__(self):
            for c in table_.columns:
                setattr(self, c.name, c)

    setattr(Meta, &#34;column&#34;, Columns())

    class Base(metaclass=Meta):
        pass

    class Model(type(&#34;ModelBase&#34;, tuple([Base] + mixins), {})):
        def __init__(self, **kwargs):
            for k, v in kwargs.items():
                setattr(self, k, v)

        def __repr__(self):
            cls = type(self)
            return f&#34;{cls.name}({&#39;, &#39;.join([f&#39;{c.name}={repr(getattr(self, c.name))}&#39; for c in cls.columns if hasattr(self, c.name)])})&#34;

        def __str__(self):
            cls = type(self)
            return f&#34;{cls.name}({&#39;, &#39;.join([f&#39;{c.name}={str(getattr(self, c.name))}&#39; for c in cls.columns if hasattr(self, c.name)])})&#34;

        def __iter__(self):
            cls = type(self)
            return map(lambda c: (c, getattr(self, c.name)), filter(lambda c: hasattr(self, c.name), cls.columns))

        def __setattr__(self, key, value):
            if key not in column_names:
                raise TypeError(f&#34;{key} is not a column of {type(self).name}&#34;)
            object.__setattr__(self, key, value)

        def __getitem__(self, key):
            return getattr(self, key)

        def __contains__(self, key):
            return hasattr(self, key)

        def __eq__(self, other):
            cls = type(self)
            if cls != type(other):
                return False
            for k in column_names:
                if hasattr(self, k) ^ hasattr(other, k):
                    return False
                if getattr(self, k, None) != getattr(other, k, None):
                    return False
            return True

    return Model</code></pre>
</details>
</dd>
<dt id="pyracmon.document_type"><code class="name flex">
<span>def <span class="ident">document_type</span></span>(<span>t: type, doc: str) ‑> Type[typing_extensions.Annotated]</span>
</code></dt>
<dd>
<div class="desc"><p>Supplies a document to a type.</p>
<p>:param t: A type.
:param doc: A document.
:returns: Documented type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def document_type(t: type, doc: str) -&gt; Type[Annotated]:
    &#34;&#34;&#34;
    Supplies a document to a type.

    :param t: A type.
    :param doc: A document.
    :returns: Documented type.
    &#34;&#34;&#34;
    return annotate(t, doc)</code></pre>
</details>
</dd>
<dt id="pyracmon.escape_like"><code class="name flex">
<span>def <span class="ident">escape_like</span></span>(<span>v: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Escape a string for the use in <code>LIKE</code> condition.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>v</code></strong></dt>
<dd>A string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Escaped string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def escape_like(v: str) -&gt; str:
    &#34;&#34;&#34;
    Escape a string for the use in `LIKE` condition.

    Args:
        v: A string.
    Returns:
        Escaped string.
    &#34;&#34;&#34;
    def esc(c):
        if c == &#34;\\&#34;:
            return r&#34;\\\\&#34;
        elif c == &#34;%&#34;:
            return r&#34;\%&#34;
        elif c == &#34;_&#34;:
            return r&#34;\_&#34;
        else:
            return c
    return &#39;&#39;.join(map(esc, v))</code></pre>
</details>
</dd>
<dt id="pyracmon.graph_dict"><code class="name flex">
<span>def <span class="ident">graph_dict</span></span>(<span>graph: <a title="pyracmon.graph.graph.GraphView" href="graph/graph.html#pyracmon.graph.graph.GraphView">GraphView</a>, **settings: <a title="pyracmon.graph.serialize.NodeSerializer" href="graph/serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize a graph into a <code>dict</code> under the default specification.</p>
<p>See <code><a title="pyracmon.graph.GraphSpec.to_dict" href="graph/index.html#pyracmon.graph.GraphSpec.to_dict">GraphSpec.to_dict()</a></code> for the detail of serialization settings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>A view of the graph.</dd>
<dt><strong><code>settings</code></strong></dt>
<dd>Serialization settings.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Serialization result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graph_dict(graph: GraphView, **settings: NodeSerializer) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Serialize a graph into a `dict` under the default specification.

    See `pyracmon.graph.GraphSpec.to_dict` for the detail of serialization settings.

    Args:
        graph: A view of the graph.
        settings: Serialization settings.
    Returns:
        Serialization result.
    &#34;&#34;&#34;
    return default_config().graph_spec.to_dict(graph, **settings)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph_schema"><code class="name flex">
<span>def <span class="ident">graph_schema</span></span>(<span>template: <a title="pyracmon.graph.template.GraphTemplate" href="graph/template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, **settings: <a title="pyracmon.graph.serialize.NodeSerializer" href="graph/serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a>) ‑> <a title="pyracmon.graph.schema.GraphSchema" href="graph/schema.html#pyracmon.graph.schema.GraphSchema">GraphSchema</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates <code><a title="pyracmon.GraphSchema" href="#pyracmon.GraphSchema">GraphSchema</a></code> under the default specifications.</p>
<p><code><a title="pyracmon.GraphSchema" href="#pyracmon.GraphSchema">GraphSchema</a></code> represents the structure of <code>dict</code> serialized a graph of the template with given serialization settings.
Use this, for example, to document REST API which responds serialized graph in JSON format. </p>
<p>See <code><a title="pyracmon.graph.GraphSpec.to_schema" href="graph/index.html#pyracmon.graph.GraphSpec.to_schema">GraphSpec.to_schema()</a></code> for the detail of serialization settings.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template</code></strong></dt>
<dd>A template of serializing graph.</dd>
<dt><strong><code>settings</code></strong></dt>
<dd>Serialization settings.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Schema of serialization result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graph_schema(template: GraphTemplate, **settings: NodeSerializer) -&gt; GraphSchema:
    &#34;&#34;&#34;
    Creates `GraphSchema` under the default specifications.

    `GraphSchema` represents the structure of `dict` serialized a graph of the template with given serialization settings.
    Use this, for example, to document REST API which responds serialized graph in JSON format. 

    See `pyracmon.graph.GraphSpec.to_schema` for the detail of serialization settings.

    Args:
        template: A template of serializing graph.
        settings: Serialization settings.
    Returns:
        Schema of serialization result.
    &#34;&#34;&#34;
    return default_config().graph_spec.to_schema(template, **settings)</code></pre>
</details>
</dd>
<dt id="pyracmon.graph_template"><code class="name flex">
<span>def <span class="ident">graph_template</span></span>(<span>*bases: <a title="pyracmon.graph.template.GraphTemplate" href="graph/template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, **definitions: type) ‑> <a title="pyracmon.graph.template.GraphTemplate" href="graph/template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a graph template on the default <code>GraphSpec</code> predefined to handle model object in appropriate ways.</p>
<p>See <code><a title="pyracmon.graph.GraphSpec.new_template" href="graph/index.html#pyracmon.graph.GraphSpec.new_template">GraphSpec.new_template()</a></code> for the detail of definitions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bases</code></strong></dt>
<dd>Base templates whose properties and relations are merged into new template.</dd>
<dt><strong><code>definitions</code></strong></dt>
<dd>Definitions of template properties.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Graph template.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graph_template(*bases: GraphTemplate, **definitions: type) -&gt; GraphTemplate:
    &#34;&#34;&#34;
    Create a graph template on the default `GraphSpec` predefined to handle model object in appropriate ways.

    See `pyracmon.graph.GraphSpec.new_template` for the detail of definitions.

    Args:
        bases: Base templates whose properties and relations are merged into new template.
        definitions: Definitions of template properties.
    Returns:
        Graph template.
    &#34;&#34;&#34;
    return default_config().graph_spec.new_template(*bases, **definitions)</code></pre>
</details>
</dd>
<dt id="pyracmon.new_graph"><code class="name flex">
<span>def <span class="ident">new_graph</span></span>(<span>template: <a title="pyracmon.graph.template.GraphTemplate" href="graph/template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, *bases: <a title="pyracmon.graph.graph.Graph" href="graph/graph.html#pyracmon.graph.graph.Graph">Graph</a>) ‑> <a title="pyracmon.graph.graph.Graph" href="graph/graph.html#pyracmon.graph.graph.Graph">Graph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a graph from a template.</p>
<p>Use this function instead of invoking constructor directly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>template</code></strong></dt>
<dd>A template of a graph.</dd>
<dt><strong><code>bases</code></strong></dt>
<dd>Other graphs whose nodes are appended to created graph.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Created graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_graph(template: GraphTemplate, *bases: Graph) -&gt; Graph:
    &#34;&#34;&#34;
    Create a graph from a template.

    Use this function instead of invoking constructor directly.

    Args:
        template: A template of a graph.
        bases: Other graphs whose nodes are appended to created graph.
    Returns:
        Created graph.
    &#34;&#34;&#34;
    graph = Graph(template)

    for b in bases:
        graph += b

    return graph</code></pre>
</details>
</dd>
<dt id="pyracmon.order_by"><code class="name flex">
<span>def <span class="ident">order_by</span></span>(<span>columns: Dict[str, bool], **defaults: bool) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generates <code>ORDER BY</code> clause from columns and directions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>columns</code></strong></dt>
<dd>Columns and directions. Iteration order is kept in rendered clause.</dd>
<dt><strong><code>defaults</code></strong></dt>
<dd>Column names and directions appended to the clause when the column is not specified in <code>columns</code> argument.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>ORDER BY</code> clause.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_by(columns: Dict[str, bool], **defaults: bool) -&gt; str:
    &#34;&#34;&#34;
    Generates `ORDER BY` clause from columns and directions.

    Args:
        columns: Columns and directions. Iteration order is kept in rendered clause.
        defaults: Column names and directions appended to the clause when the column is not specified in `columns` argument.
    Returns:
        `ORDER BY` clause.
    &#34;&#34;&#34;
    columns = dict(columns, **{c:v for c,v in defaults.items() if c not in columns})
    def col(cd):
        return f&#34;{cd[0]} ASC&#34; if cd[1] else f&#34;{cd[0]} DESC&#34;
    return &#39;&#39; if len(columns) == 0 else f&#34;ORDER BY {&#39;, &#39;.join(map(col, columns.items()))}&#34;</code></pre>
</details>
</dd>
<dt id="pyracmon.pyracmon"><code class="name flex">
<span>def <span class="ident">pyracmon</span></span>(<span>**kwargs: Any) ‑> <a title="pyracmon.config.PyracmonConfiguration" href="config.html#pyracmon.config.PyracmonConfiguration">PyracmonConfiguration</a></span>
</code></dt>
<dd>
<div class="desc"><p>Starts <code>with</code> block to change global configurations.</p>
<p>Attributes set to the target object is reflected to the global configuration when the block fininshed successfully.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; assert default_config().name == &quot;default&quot;
&gt;&gt;&gt; with pyracmon() as cfg:
&gt;&gt;&gt;     cfg.name = &quot;my_config&quot;
&gt;&gt;&gt;     ...
&gt;&gt;&gt; assert default_config().name == &quot;my_config&quot;
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Reserved for future use. Currently, this argument has no effect.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Target of <code>with</code> block.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pyracmon(**kwargs: Any) -&gt; PyracmonConfiguration:
    &#34;&#34;&#34;
    Starts `with` block to change global configurations.

    Attributes set to the target object is reflected to the global configuration when the block fininshed successfully.

    &gt;&gt;&gt; assert default_config().name == &#34;default&#34;
    &gt;&gt;&gt; with pyracmon() as cfg:
    &gt;&gt;&gt;     cfg.name = &#34;my_config&#34;
    &gt;&gt;&gt;     ...
    &gt;&gt;&gt; assert default_config().name == &#34;my_config&#34;

    Args:
        kwargs: Reserved for future use. Currently, this argument has no effect.
    Returns:
        Target of `with` block.
    &#34;&#34;&#34;
    class Configurable:
        def __init__(self):
            self.config = default_config().derive()

        def __enter__(self):
            return self.config

        def __exit__(self, exc_type, exc_value, traceback):
            if not exc_value:
                target = default_config()

                for k in vars(target):
                    v = getattr(self.config, k)
                    if isinstance(v, Configurable):
                        getattr(target, k).replace(v)
                    elif v is not None:
                        setattr(target, k, v)
            return False

    return Configurable()</code></pre>
</details>
</dd>
<dt id="pyracmon.ranged_by"><code class="name flex">
<span>def <span class="ident">ranged_by</span></span>(<span>limit: Optional[int] = None, offset: Optional[int] = None) ‑> Tuple[str, List[Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates <code>LIMIT</code> and <code>OFFSET</code> clause using marker.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>limit</code></strong></dt>
<dd>Limit value. <code>None</code> means no limitation.</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>Offset value. <code>None</code> means <code>0</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple of <code>LIMIT</code> and <code>OFFSET</code> clause and parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ranged_by(limit: Optional[int] = None, offset: Optional[int] = None) -&gt; Tuple[str, List[Any]]:
    &#34;&#34;&#34;
    Generates `LIMIT` and `OFFSET` clause using marker.

    Args:
        limit: Limit value. `None` means no limitation.
        offset: Offset value. `None` means `0`.
    Returns:
        Tuple of `LIMIT` and `OFFSET` clause and parameters.
    &#34;&#34;&#34;
    clause, params = [], []

    if limit is not None:
        clause.append(&#34;LIMIT $_&#34;)
        params.append(limit)

    if offset is not None:
        clause.append(&#34;OFFSET $_&#34;)
        params.append(offset)

    return &#39; &#39;.join(clause) if clause else &#39;&#39;, params</code></pre>
</details>
</dd>
<dt id="pyracmon.read_row"><code class="name flex">
<span>def <span class="ident">read_row</span></span>(<span>row, *selections: Union[<a title="pyracmon.select.Selection" href="select.html#pyracmon.select.Selection">Selection</a>, str, Tuple[()]], allow_redundancy: bool = False) ‑> <a title="pyracmon.select.RowValues" href="select.html#pyracmon.select.RowValues">RowValues</a></span>
</code></dt>
<dd>
<div class="desc"><p>Read values in a row according to given selections.</p>
<p>This function returns <code>RowValues</code> where each value is created by each selection respectively.
The type of the selection determines how values in the row are handled:</p>
<ul>
<li><code>Selection</code> consumes as many values as the number of columns in it and creates a model instance.</li>
<li>Empty tuple or a string consumes a value, which is stored in <code>RowValues</code> as it is.</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>selections</code></strong></dt>
<dd>List of selections.</dd>
<dt><strong><code>allow_redundancy</code></strong></dt>
<dd>If <code>False</code>, <code>ValueError</code> is thrown when not all values in a row are consumed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Values read from the row accoding to the selections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_row(row, *selections: Union[Selection, str, Tuple[()]], allow_redundancy: bool = False) -&gt; RowValues:
    &#34;&#34;&#34;
    Read values in a row according to given selections.

    This function returns `RowValues` where each value is created by each selection respectively.
    The type of the selection determines how values in the row are handled:

    - `Selection` consumes as many values as the number of columns in it and creates a model instance.
    - Empty tuple or a string consumes a value, which is stored in `RowValues` as it is.

    Args:
        selections: List of selections.
        allow_redundancy: If `False`, `ValueError` is thrown when not all values in a row are consumed.
    Returns:
        Values read from the row accoding to the selections.
    &#34;&#34;&#34;
    result = RowValues(selections)

    for s in selections:
        if isinstance(s, Selection):
            result.append(s.consume(row))
            row = row[len(s):]
        elif callable(s):
            result.append(s(row[0]))
            row = row[1:]
        elif s == () or isinstance(s, str):
            result.append(row[0])
            row = row[1:]
        else:
            raise ValueError(&#34;Unavailable value is given to read_row().&#34;)

    if not allow_redundancy and len(row) &gt; 0:
        raise ValueError(&#34;Not all elements in row is consumed.&#34;)

    return result</code></pre>
</details>
</dd>
<dt id="pyracmon.walk_schema"><code class="name flex">
<span>def <span class="ident">walk_schema</span></span>(<span>td, with_doc=False) ‑> Dict[str, Union[type, typing_extensions.Annotated]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary as a result of walking a schema object from its root.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>td</code></strong></dt>
<dd>A schema represented by <code><a title="pyracmon.TypedDict" href="#pyracmon.TypedDict">TypedDict</a></code>.</dd>
<dt><strong><code>with_doc</code></strong></dt>
<dd>Flag to include documentations into result.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Key value representation of the schema. If <code>with_doc</code> is <code>True</code>, each value is <code>Annotated</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def walk_schema(td, with_doc=False) -&gt; Dict[str, Union[type, Annotated]]:
    &#34;&#34;&#34;
    Returns a dictionary as a result of walking a schema object from its root.

    Args:
        td: A schema represented by `TypedDict`.
        with_doc: Flag to include documentations into result.
    Returns:
        Key value representation of the schema. If `with_doc` is `True`, each value is `Annotated`.
    &#34;&#34;&#34;
    if &#39;__annotations__&#39; not in td.__dict__:
        return {}

    result = {}

    def put(k, t, doc):
        if with_doc:
            result[k] = (t, doc)
        else:
            result[k] = t

    def expand(t):
        return (get_args(t)[0], lambda x:[x]) if issubgeneric(t, List) else (t, lambda x:x)

    for k, t in get_annotated_hints(td).items():
        t, doc = _decompose_document(t)

        t, conv = expand(t)

        if is_typed_dict(t):
            put(k, conv(walk_schema(t, with_doc)), doc)
        else:
            put(k, conv(t), doc)
    
    return result</code></pre>
</details>
</dd>
<dt id="pyracmon.where"><code class="name flex">
<span>def <span class="ident">where</span></span>(<span>condition: <a title="pyracmon.Conditional" href="#pyracmon.Conditional">Conditional</a>) ‑> Tuple[str, List[Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a <code>WHERE</code> clause and parameters representing given condition.</p>
<p>If the condition is empty, returned clause is an empty string which does not contain <code>WHERE</code> keyword.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>condition</code></strong></dt>
<dd>Condition object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple of <code>WHERE</code> clause and parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def where(condition: &#39;Conditional&#39;) -&gt; Tuple[str, List[Any]]:
    &#34;&#34;&#34;
    Generates a `WHERE` clause and parameters representing given condition.

    If the condition is empty, returned clause is an empty string which does not contain `WHERE` keyword.

    Args:
        condition: Condition object.
    Returns:
        Tuple of `WHERE` clause and parameters.
    &#34;&#34;&#34;
    return (&#39;&#39;, []) if condition.expression == &#39;&#39; else (f&#39;WHERE {condition.expression}&#39;, condition.params)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyracmon.CRUDMixin"><code class="flex name class">
<span>class <span class="ident">CRUDMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Default mixin providing class methods available on all model types.</p>
<p>Every method takes the DB connection object as its first argument.</p>
<p>Following arguments are shared in some methods. Some of them have variations in their forms which are available commonly in every method.</p>
<p><strong>pks</strong></p>
<ul>
<li><code>Dict[str, Any]</code><ul>
<li>Values of multiple primary keys. Key of <code>dict</code> corresponds to column name.</li>
</ul>
</li>
<li><code>Any</code><ul>
<li>A value of primary key. </li>
</ul>
</li>
</ul>
<p><strong>record</strong></p>
<ul>
<li><code><a title="pyracmon.Model" href="#pyracmon.Model">Model</a></code><ul>
<li>A model object representing a record. Only existing columns affects the operation.</li>
</ul>
</li>
<li><code>Dict[str, Any]</code><ul>
<li>A <code>dict</code> where column name is mapped to its value. Only existing columns affects the operation.</li>
</ul>
</li>
</ul>
<p><strong>condition</strong></p>
<ul>
<li><code><a title="pyracmon.Conditional" href="#pyracmon.Conditional">Conditional</a></code><ul>
<li>Query condition to select rows to fetch, update or delete.</li>
</ul>
</li>
</ul>
<p><strong>qualifier</strong></p>
<ul>
<li><code>Dict[str, Callable[[str], str]]</code><ul>
<li>Functions to convert query expressions for columns. Each function takes default expression and should return actual expression.</li>
</ul>
</li>
</ul>
<p><strong>lock</strong></p>
<ul>
<li><code>Any</code><ul>
<li>This is reserved argument for locking statement but works just as the postfix of the query currently.</li>
<li>The usage will be changed in future version.</li>
</ul>
</li>
</ul>
<p>Qualifier is used typically to convert or replace placeholder marker in insert/update query.
By default, those queries contain markers like <code>insert into t (c1, c2) values (?, ?)</code> (<code><a title="pyracmon.Q" href="#pyracmon.Q">Q</a></code> parameter style).
We need sometimes qualify markers to apply DB function, calculation, type cast and so on. This feature enables them like below.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.insert(db, dict(c1=1, c2=None), dict(c1=lambda x: f&quot;{x}+1&quot;, c2=lambda x: &quot;now()&quot;))
&gt;&gt;&gt; # SQL: INSERT INTO t (c1, c2) VALUES (?+1, now())
</code></pre>
<p>Be aware that when model object is used for the second argument, its column values may differ from actual values in DB after query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CRUDMixin(SelectMixin):
    &#34;&#34;&#34;
    Default mixin providing class methods available on all model types.

    Every method takes the DB connection object as its first argument.

    Following arguments are shared in some methods. Some of them have variations in their forms which are available commonly in every method.

    **pks**

    - `Dict[str, Any]`
        - Values of multiple primary keys. Key of `dict` corresponds to column name.
    - `Any`
        - A value of primary key. 

    **record**
    
    - `Model`
        - A model object representing a record. Only existing columns affects the operation.
    - `Dict[str, Any]`
        - A `dict` where column name is mapped to its value. Only existing columns affects the operation.

    **condition**

    - `Conditional`
        - Query condition to select rows to fetch, update or delete.

    **qualifier**

    - `Dict[str, Callable[[str], str]]`
        - Functions to convert query expressions for columns. Each function takes default expression and should return actual expression.

    **lock**

    - `Any`
        - This is reserved argument for locking statement but works just as the postfix of the query currently.
        - The usage will be changed in future version.

    Qualifier is used typically to convert or replace placeholder marker in insert/update query.
    By default, those queries contain markers like `insert into t (c1, c2) values (?, ?)` (`Q` parameter style).
    We need sometimes qualify markers to apply DB function, calculation, type cast and so on. This feature enables them like below.

    &gt;&gt;&gt; t.insert(db, dict(c1=1, c2=None), dict(c1=lambda x: f&#34;{x}+1&#34;, c2=lambda x: &#34;now()&#34;))
    &gt;&gt;&gt; # SQL: INSERT INTO t (c1, c2) VALUES (?+1, now())

    Be aware that when model object is used for the second argument, its column values may differ from actual values in DB after query.
    &#34;&#34;&#34;
    @classmethod
    def count(cls, db: Connection, condition: Conditional = Q.of()) -&gt; int:
        &#34;&#34;&#34;
        Count rows which satisfies the condition.

        &gt;&gt;&gt; t.count(db, Q.eq(c1=1))
        &gt;&gt;&gt; # SQL: SELECT COUNT(*) FROM t WHERE c1 = 1

        Args:
            db: DB connection.
            condition: Query condition.
        Returns:
            The number of rows.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        c = db.stmt().execute(f&#34;SELECT COUNT(*) FROM {cls.name}{_spacer(wc)}&#34;, *wp)
        return c.fetchone()[0]

    @classmethod
    def fetch(cls, db: Connection, pks: PKS, lock: Optional[Any] = None) -&gt; Optional[Model]:
        &#34;&#34;&#34;
        Fetch a record by primary key(s).

        &gt;&gt;&gt; t.fetch(db, 1)
        &gt;&gt;&gt; # SQL: SELECT * FROM t WHERE id = 1

        Args:
            db: DB connection.
            pks: Primary key value(s).
            lock: Locking statement.
        Returns:
            A model object if exists, otherwise `None`.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)
        cond = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
        wc, wp = where(cond)
        s = cls.select()
        c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}&#34;, *wp)
        row = c.fetchone()
        return read_row(row, s)[0] if row else None

    @classmethod
    def fetch_where(
        cls,
        db: Connection,
        condition: Conditional = Q.of(),
        orders: Dict[str, bool] = {},
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        lock: Optional[Any] = None,
    ) -&gt; List[Model]:
        &#34;&#34;&#34;
        Fetch records which satisfy the condition.

        &gt;&gt;&gt; t.fetch_where(db, Q.eq(c1=1), dict(c2=True), 10, 5)
        &gt;&gt;&gt; # SQL: SELECT * FROM t WHERE c1 = 1 ORDER BY c2 ASC LIMIT 10 OFFSET 5

        Args:
            db: DB connection.
            condition: Query condition.
            orders: Ordering specification where key is column name and value denotes whether the order is ascending or not.
            limit: Maximum nuber of rows to fetch. If `None`, all rows are returned.
            offset: The number of rows to skip.
            lock: Locking statement.
        Returns:
            Model objects.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        rc, rp = ranged_by(limit, offset)
        s = cls.select()
        c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(order_by(orders))}{_spacer(rc)}{_spacer(lock)}&#34;, *(wp + rp))
        return [read_row(row, s)[0] for row in c.fetchall()]

    @classmethod
    def fetch_one(
        cls,
        db: Connection,
        condition: Conditional = Q.of(),
        lock: Optional[Any] = None,
    ) -&gt; Optional[Model]:
        &#34;&#34;&#34;
        Fetch a record which satisfies the condition.

        `ValueError` raises When multiple records are found.
        Use this method for queries which certainly returns a single row, such as search by unique key.

        &gt;&gt;&gt; t.fetch_one(db, Q.eq(c1=1)), 5)
        &gt;&gt;&gt; # SQL: SELECT * FROM t WHERE c1 = 1

        Args:
            db: DB connection.
            condition: Query condition.
            lock: Locking statement.
        Returns:
            Model objects If exists, otherwise `None`.
        &#34;&#34;&#34;
        rs = cls.fetch_where(db, condition, lock=lock)

        if not rs:
            return None
        elif len(rs) == 1:
            return rs[0]
        else:
            raise ValueError(f&#34;{len(rs)} records are found on the invocation of fetch_one().&#34;)

    @classmethod
    def insert(cls, db: Connection, record: Record, qualifier: Qualifier = {}) -&gt; Model:
        &#34;&#34;&#34;
        Insert a record.

        Returned model object contains auto incremental column even if they are not set beforehand.
        On the contrary, default value generated in database side is not set.

        &gt;&gt;&gt; t.insert(db, dict(c1=1, c2=2))
        &gt;&gt;&gt; # SQL: INSERT INTO t (c1, c2) VALUES (1, 2)

        Args:
            db: DB connection.
            record: Object contains column values.
            qualifier: Functions qualifying placeholder markers.
        Returns:
            Model of inserted record.
        &#34;&#34;&#34;
        record = record if isinstance(record, cls) else cls(**record)
        value_dict = model_values(cls, record)
        check_columns(cls, value_dict)
        cols, vals = list(value_dict.keys()), list(value_dict.values())
        qualifier = key_to_index(qualifier, cols)

        db.stmt().execute(f&#34;INSERT INTO {cls.name} ({&#39;, &#39;.join(cols)}) VALUES {values(len(cols), 1, qualifier)}&#34;, *vals)

        for c, v in cls.last_sequences(db, 1):
            setattr(record, c.name, v)

        return record

    @classmethod
    def update(cls, db: Connection, pks: PKS, record: Record, qualifier: Qualifier = {}) -&gt; bool:
        &#34;&#34;&#34;
        Update a record by primary key(s).

        This method only updates columns which are found in `record` except for primary key(s).

        &gt;&gt;&gt; t.update(db, 1, dict(c1=1, c2=2))
        &gt;&gt;&gt; # SQL: UPDATE t SET c1 = 1, c2 = 2 WHERE id = 1

        Args:
            db: DB connection.
            pks: Primary key value(s).
            record: Object contains column values.
            qualifier: Functions qualifying placeholder markers.
        Returns:
            Whether the record exists and updated.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)
        return cls.update_where(db, record, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)]), qualifier) == 1

    @classmethod
    def update_where(
        cls,
        db: Connection,
        record: Record,
        condition: Conditional,
        qualifier: Qualifier = {},
        allow_all: bool = True,
    ) -&gt; int:
        &#34;&#34;&#34;
        Update records which satisfy the condition.

        &gt;&gt;&gt; t.update(db, dict(c2=2), Q.eq(c1=1))
        &gt;&gt;&gt; # SQL: UPDATE t SET c2 = 2 WHERE c1 = 1

        Args:
            db: DB connection.
            record: Object contains column values.
            condition: Query condition.
            qualifier: Functions qualifying placeholder markers.
            allow_all: If `False`, empty condition raises `ValueError`.
        Returns:
            The number of affected rows.
        &#34;&#34;&#34;
        value_dict = model_values(cls, record, excludes_pk=True)
        check_columns(cls, value_dict)
        cols, vals = list(value_dict.keys()), list(value_dict.values())
        qualifier = key_to_index(qualifier, cols)

        def set_col(acc, icv):
            i, (c, v) = icv
            if isinstance(v, Expression):
                clause = f&#34;{c} = {qualifier.get(i, lambda x:x)(v.expression)}&#34;
                params = v.params
            else:
                clause = f&#34;{c} = {qualifier.get(i, lambda x:x)(&#39;$_&#39;)}&#34;
                params = [v]
            acc[0].append(clause)
            acc[1].extend(params)
            return acc

        setters, params = reduce(set_col, enumerate(zip(cols, vals)), ([], []))

        wc, wp = where(condition)
        if wc == &#34;&#34; and not allow_all:
            raise ValueError(&#34;Update query to update all records is not allowed.&#34;)

        c = db.stmt().execute(f&#34;UPDATE {cls.name} SET {&#39;, &#39;.join(setters)}{_spacer(wc)}&#34;, *(params + wp))

        return getattr(c, &#34;rowcount&#34;, None)

    @classmethod
    def delete(cls, db: Connection, pks: PKS) -&gt; bool:
        &#34;&#34;&#34;
        Delete a record by primary key(s).

        &gt;&gt;&gt; t.delete(db, 1)
        &gt;&gt;&gt; # SQL: DELETE FROM t WHERE id = 1

        Args:
            db: DB connection.
            pks: Primary key value(s).
        Returns:
            Whether the record exists and deleted.
        &#34;&#34;&#34;
        cols, vals = parse_pks(cls, pks)
        return cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])) == 1

    @classmethod
    def delete_where(cls, db: Connection, condition: Conditional, allow_all: bool = True) -&gt; int:
        &#34;&#34;&#34;
        Delete records which satisfy the condition.

        &gt;&gt;&gt; t.delete(db, Q.eq(c1=1))
        &gt;&gt;&gt; # SQL: DELETE FROM t WHERE c1 = 1

        Args:
            db: DB connection.
            condition: Query condition.
            allow_all: If `False`, empty condition raises `ValueError`.
        Returns:
            The number of affected rows.
        &#34;&#34;&#34;
        wc, wp = where(condition)
        if wc == &#34;&#34; and not allow_all:
            raise ValueError(&#34;Delete query to delete all records is not allowed.&#34;)

        c = db.stmt().execute(f&#34;DELETE FROM {cls.name}{_spacer(wc)}&#34;, *wp)

        return getattr(c, &#34;rowcount&#34;, None)

    @classmethod
    def last_sequences(cls, db: Connection, num: int) -&gt; List[Tuple[Column, int]]:
        &#34;&#34;&#34;
        Returns the sequential (auto incremental) values of a table generated by the latest insertion.

        Result contains every sequential columns and their values.
        When the latest query inserts multiple rows, only the last (= biggest) value is returned.

        This method should be overridden by another mixin class defined in dialect module.

        Args:
            db: DB connection.
            num: The number of records inserted by the latest query.
        Returns:
            List of pairs of column and its values.
        &#34;&#34;&#34;
        return []</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.select.SelectMixin" href="select.html#pyracmon.select.SelectMixin">SelectMixin</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.CRUDMixin.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition: <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a> = Condition: '' -- []) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Count rows which satisfies the condition.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.count(db, Q.eq(c1=1))
&gt;&gt;&gt; # SQL: SELECT COUNT(*) FROM t WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of rows.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def count(cls, db: Connection, condition: Conditional = Q.of()) -&gt; int:
    &#34;&#34;&#34;
    Count rows which satisfies the condition.

    &gt;&gt;&gt; t.count(db, Q.eq(c1=1))
    &gt;&gt;&gt; # SQL: SELECT COUNT(*) FROM t WHERE c1 = 1

    Args:
        db: DB connection.
        condition: Query condition.
    Returns:
        The number of rows.
    &#34;&#34;&#34;
    wc, wp = where(condition)
    c = db.stmt().execute(f&#34;SELECT COUNT(*) FROM {cls.name}{_spacer(wc)}&#34;, *wp)
    return c.fetchone()[0]</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, pks: Union[Any, Dict[str, Any]]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a record by primary key(s).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.delete(db, 1)
&gt;&gt;&gt; # SQL: DELETE FROM t WHERE id = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>pks</code></strong></dt>
<dd>Primary key value(s).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the record exists and deleted.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete(cls, db: Connection, pks: PKS) -&gt; bool:
    &#34;&#34;&#34;
    Delete a record by primary key(s).

    &gt;&gt;&gt; t.delete(db, 1)
    &gt;&gt;&gt; # SQL: DELETE FROM t WHERE id = 1

    Args:
        db: DB connection.
        pks: Primary key value(s).
    Returns:
        Whether the record exists and deleted.
    &#34;&#34;&#34;
    cols, vals = parse_pks(cls, pks)
    return cls.delete_where(db, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])) == 1</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.delete_where"><code class="name flex">
<span>def <span class="ident">delete_where</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition: <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a>, allow_all: bool = True) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Delete records which satisfy the condition.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.delete(db, Q.eq(c1=1))
&gt;&gt;&gt; # SQL: DELETE FROM t WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>allow_all</code></strong></dt>
<dd>If <code>False</code>, empty condition raises <code>ValueError</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of affected rows.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete_where(cls, db: Connection, condition: Conditional, allow_all: bool = True) -&gt; int:
    &#34;&#34;&#34;
    Delete records which satisfy the condition.

    &gt;&gt;&gt; t.delete(db, Q.eq(c1=1))
    &gt;&gt;&gt; # SQL: DELETE FROM t WHERE c1 = 1

    Args:
        db: DB connection.
        condition: Query condition.
        allow_all: If `False`, empty condition raises `ValueError`.
    Returns:
        The number of affected rows.
    &#34;&#34;&#34;
    wc, wp = where(condition)
    if wc == &#34;&#34; and not allow_all:
        raise ValueError(&#34;Delete query to delete all records is not allowed.&#34;)

    c = db.stmt().execute(f&#34;DELETE FROM {cls.name}{_spacer(wc)}&#34;, *wp)

    return getattr(c, &#34;rowcount&#34;, None)</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, pks: Union[Any, Dict[str, Any]], lock: Optional[Any] = None) ‑> Optional[<a title="pyracmon.model.Model" href="model.html#pyracmon.model.Model">Model</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a record by primary key(s).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.fetch(db, 1)
&gt;&gt;&gt; # SQL: SELECT * FROM t WHERE id = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>pks</code></strong></dt>
<dd>Primary key value(s).</dd>
<dt><strong><code>lock</code></strong></dt>
<dd>Locking statement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A model object if exists, otherwise <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fetch(cls, db: Connection, pks: PKS, lock: Optional[Any] = None) -&gt; Optional[Model]:
    &#34;&#34;&#34;
    Fetch a record by primary key(s).

    &gt;&gt;&gt; t.fetch(db, 1)
    &gt;&gt;&gt; # SQL: SELECT * FROM t WHERE id = 1

    Args:
        db: DB connection.
        pks: Primary key value(s).
        lock: Locking statement.
    Returns:
        A model object if exists, otherwise `None`.
    &#34;&#34;&#34;
    cols, vals = parse_pks(cls, pks)
    cond = Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)])
    wc, wp = where(cond)
    s = cls.select()
    c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(lock)}&#34;, *wp)
    row = c.fetchone()
    return read_row(row, s)[0] if row else None</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.fetch_one"><code class="name flex">
<span>def <span class="ident">fetch_one</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition: <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a> = Condition: '' -- [], lock: Optional[Any] = None) ‑> Optional[<a title="pyracmon.model.Model" href="model.html#pyracmon.model.Model">Model</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch a record which satisfies the condition.</p>
<p><code>ValueError</code> raises When multiple records are found.
Use this method for queries which certainly returns a single row, such as search by unique key.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.fetch_one(db, Q.eq(c1=1)), 5)
&gt;&gt;&gt; # SQL: SELECT * FROM t WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>lock</code></strong></dt>
<dd>Locking statement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model objects If exists, otherwise <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fetch_one(
    cls,
    db: Connection,
    condition: Conditional = Q.of(),
    lock: Optional[Any] = None,
) -&gt; Optional[Model]:
    &#34;&#34;&#34;
    Fetch a record which satisfies the condition.

    `ValueError` raises When multiple records are found.
    Use this method for queries which certainly returns a single row, such as search by unique key.

    &gt;&gt;&gt; t.fetch_one(db, Q.eq(c1=1)), 5)
    &gt;&gt;&gt; # SQL: SELECT * FROM t WHERE c1 = 1

    Args:
        db: DB connection.
        condition: Query condition.
        lock: Locking statement.
    Returns:
        Model objects If exists, otherwise `None`.
    &#34;&#34;&#34;
    rs = cls.fetch_where(db, condition, lock=lock)

    if not rs:
        return None
    elif len(rs) == 1:
        return rs[0]
    else:
        raise ValueError(f&#34;{len(rs)} records are found on the invocation of fetch_one().&#34;)</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.fetch_where"><code class="name flex">
<span>def <span class="ident">fetch_where</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, condition: <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a> = Condition: '' -- [], orders: Dict[str, bool] = {}, limit: Optional[int] = None, offset: Optional[int] = None, lock: Optional[Any] = None) ‑> List[<a title="pyracmon.model.Model" href="model.html#pyracmon.model.Model">Model</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch records which satisfy the condition.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.fetch_where(db, Q.eq(c1=1), dict(c2=True), 10, 5)
&gt;&gt;&gt; # SQL: SELECT * FROM t WHERE c1 = 1 ORDER BY c2 ASC LIMIT 10 OFFSET 5
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>orders</code></strong></dt>
<dd>Ordering specification where key is column name and value denotes whether the order is ascending or not.</dd>
<dt><strong><code>limit</code></strong></dt>
<dd>Maximum nuber of rows to fetch. If <code>None</code>, all rows are returned.</dd>
<dt><strong><code>offset</code></strong></dt>
<dd>The number of rows to skip.</dd>
<dt><strong><code>lock</code></strong></dt>
<dd>Locking statement.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fetch_where(
    cls,
    db: Connection,
    condition: Conditional = Q.of(),
    orders: Dict[str, bool] = {},
    limit: Optional[int] = None,
    offset: Optional[int] = None,
    lock: Optional[Any] = None,
) -&gt; List[Model]:
    &#34;&#34;&#34;
    Fetch records which satisfy the condition.

    &gt;&gt;&gt; t.fetch_where(db, Q.eq(c1=1), dict(c2=True), 10, 5)
    &gt;&gt;&gt; # SQL: SELECT * FROM t WHERE c1 = 1 ORDER BY c2 ASC LIMIT 10 OFFSET 5

    Args:
        db: DB connection.
        condition: Query condition.
        orders: Ordering specification where key is column name and value denotes whether the order is ascending or not.
        limit: Maximum nuber of rows to fetch. If `None`, all rows are returned.
        offset: The number of rows to skip.
        lock: Locking statement.
    Returns:
        Model objects.
    &#34;&#34;&#34;
    wc, wp = where(condition)
    rc, rp = ranged_by(limit, offset)
    s = cls.select()
    c = db.stmt().execute(f&#34;SELECT {s} FROM {cls.name}{_spacer(wc)}{_spacer(order_by(orders))}{_spacer(rc)}{_spacer(lock)}&#34;, *(wp + rp))
    return [read_row(row, s)[0] for row in c.fetchall()]</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, record: Union[<a title="pyracmon.model.Model" href="model.html#pyracmon.model.Model">Model</a>, Dict[str, Any]], qualifier: Dict[str, Callable[[str], str]] = {}) ‑> <a title="pyracmon.model.Model" href="model.html#pyracmon.model.Model">Model</a></span>
</code></dt>
<dd>
<div class="desc"><p>Insert a record.</p>
<p>Returned model object contains auto incremental column even if they are not set beforehand.
On the contrary, default value generated in database side is not set.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.insert(db, dict(c1=1, c2=2))
&gt;&gt;&gt; # SQL: INSERT INTO t (c1, c2) VALUES (1, 2)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Object contains column values.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Model of inserted record.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def insert(cls, db: Connection, record: Record, qualifier: Qualifier = {}) -&gt; Model:
    &#34;&#34;&#34;
    Insert a record.

    Returned model object contains auto incremental column even if they are not set beforehand.
    On the contrary, default value generated in database side is not set.

    &gt;&gt;&gt; t.insert(db, dict(c1=1, c2=2))
    &gt;&gt;&gt; # SQL: INSERT INTO t (c1, c2) VALUES (1, 2)

    Args:
        db: DB connection.
        record: Object contains column values.
        qualifier: Functions qualifying placeholder markers.
    Returns:
        Model of inserted record.
    &#34;&#34;&#34;
    record = record if isinstance(record, cls) else cls(**record)
    value_dict = model_values(cls, record)
    check_columns(cls, value_dict)
    cols, vals = list(value_dict.keys()), list(value_dict.values())
    qualifier = key_to_index(qualifier, cols)

    db.stmt().execute(f&#34;INSERT INTO {cls.name} ({&#39;, &#39;.join(cols)}) VALUES {values(len(cols), 1, qualifier)}&#34;, *vals)

    for c, v in cls.last_sequences(db, 1):
        setattr(record, c.name, v)

    return record</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.last_sequences"><code class="name flex">
<span>def <span class="ident">last_sequences</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, num: int) ‑> List[Tuple[<a title="pyracmon.model.Column" href="model.html#pyracmon.model.Column">Column</a>, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the sequential (auto incremental) values of a table generated by the latest insertion.</p>
<p>Result contains every sequential columns and their values.
When the latest query inserts multiple rows, only the last (= biggest) value is returned.</p>
<p>This method should be overridden by another mixin class defined in dialect module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>num</code></strong></dt>
<dd>The number of records inserted by the latest query.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of pairs of column and its values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def last_sequences(cls, db: Connection, num: int) -&gt; List[Tuple[Column, int]]:
    &#34;&#34;&#34;
    Returns the sequential (auto incremental) values of a table generated by the latest insertion.

    Result contains every sequential columns and their values.
    When the latest query inserts multiple rows, only the last (= biggest) value is returned.

    This method should be overridden by another mixin class defined in dialect module.

    Args:
        db: DB connection.
        num: The number of records inserted by the latest query.
    Returns:
        List of pairs of column and its values.
    &#34;&#34;&#34;
    return []</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, pks: Union[Any, Dict[str, Any]], record: Union[<a title="pyracmon.model.Model" href="model.html#pyracmon.model.Model">Model</a>, Dict[str, Any]], qualifier: Dict[str, Callable[[str], str]] = {}) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Update a record by primary key(s).</p>
<p>This method only updates columns which are found in <code>record</code> except for primary key(s).</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.update(db, 1, dict(c1=1, c2=2))
&gt;&gt;&gt; # SQL: UPDATE t SET c1 = 1, c2 = 2 WHERE id = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>pks</code></strong></dt>
<dd>Primary key value(s).</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Object contains column values.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the record exists and updated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def update(cls, db: Connection, pks: PKS, record: Record, qualifier: Qualifier = {}) -&gt; bool:
    &#34;&#34;&#34;
    Update a record by primary key(s).

    This method only updates columns which are found in `record` except for primary key(s).

    &gt;&gt;&gt; t.update(db, 1, dict(c1=1, c2=2))
    &gt;&gt;&gt; # SQL: UPDATE t SET c1 = 1, c2 = 2 WHERE id = 1

    Args:
        db: DB connection.
        pks: Primary key value(s).
        record: Object contains column values.
        qualifier: Functions qualifying placeholder markers.
    Returns:
        Whether the record exists and updated.
    &#34;&#34;&#34;
    cols, vals = parse_pks(cls, pks)
    return cls.update_where(db, record, Conditional.all([Q.eq(**{c: v}) for c, v in zip(cols, vals)]), qualifier) == 1</code></pre>
</details>
</dd>
<dt id="pyracmon.CRUDMixin.update_where"><code class="name flex">
<span>def <span class="ident">update_where</span></span>(<span>db: <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a>, record: Union[<a title="pyracmon.model.Model" href="model.html#pyracmon.model.Model">Model</a>, Dict[str, Any]], condition: <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a>, qualifier: Dict[str, Callable[[str], str]] = {}, allow_all: bool = True) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Update records which satisfy the condition.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; t.update(db, dict(c2=2), Q.eq(c1=1))
&gt;&gt;&gt; # SQL: UPDATE t SET c2 = 2 WHERE c1 = 1
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong></dt>
<dd>DB connection.</dd>
<dt><strong><code>record</code></strong></dt>
<dd>Object contains column values.</dd>
<dt><strong><code>condition</code></strong></dt>
<dd>Query condition.</dd>
<dt><strong><code>qualifier</code></strong></dt>
<dd>Functions qualifying placeholder markers.</dd>
<dt><strong><code>allow_all</code></strong></dt>
<dd>If <code>False</code>, empty condition raises <code>ValueError</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The number of affected rows.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def update_where(
    cls,
    db: Connection,
    record: Record,
    condition: Conditional,
    qualifier: Qualifier = {},
    allow_all: bool = True,
) -&gt; int:
    &#34;&#34;&#34;
    Update records which satisfy the condition.

    &gt;&gt;&gt; t.update(db, dict(c2=2), Q.eq(c1=1))
    &gt;&gt;&gt; # SQL: UPDATE t SET c2 = 2 WHERE c1 = 1

    Args:
        db: DB connection.
        record: Object contains column values.
        condition: Query condition.
        qualifier: Functions qualifying placeholder markers.
        allow_all: If `False`, empty condition raises `ValueError`.
    Returns:
        The number of affected rows.
    &#34;&#34;&#34;
    value_dict = model_values(cls, record, excludes_pk=True)
    check_columns(cls, value_dict)
    cols, vals = list(value_dict.keys()), list(value_dict.values())
    qualifier = key_to_index(qualifier, cols)

    def set_col(acc, icv):
        i, (c, v) = icv
        if isinstance(v, Expression):
            clause = f&#34;{c} = {qualifier.get(i, lambda x:x)(v.expression)}&#34;
            params = v.params
        else:
            clause = f&#34;{c} = {qualifier.get(i, lambda x:x)(&#39;$_&#39;)}&#34;
            params = [v]
        acc[0].append(clause)
        acc[1].extend(params)
        return acc

    setters, params = reduce(set_col, enumerate(zip(cols, vals)), ([], []))

    wc, wp = where(condition)
    if wc == &#34;&#34; and not allow_all:
        raise ValueError(&#34;Update query to update all records is not allowed.&#34;)

    c = db.stmt().execute(f&#34;UPDATE {cls.name} SET {&#39;, &#39;.join(setters)}{_spacer(wc)}&#34;, *(params + wp))

    return getattr(c, &#34;rowcount&#34;, None)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyracmon.select.SelectMixin" href="select.html#pyracmon.select.SelectMixin">SelectMixin</a></b></code>:
<ul class="hlist">
<li><code><a title="pyracmon.select.SelectMixin.select" href="select.html#pyracmon.select.SelectMixin.select">select</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyracmon.Column"><code class="flex name class">
<span>class <span class="ident">Column</span></span>
<span>(</span><span>name: str, ptype: type, type_info: str, pk: bool, fk: Optional[<a title="pyracmon.model.Relations" href="model.html#pyracmon.model.Relations">Relations</a>], incremental: Optional[Any], nullable: bool, comment: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a schema of a column.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Column:
    &#34;&#34;&#34;
    This class represents a schema of a column.
    &#34;&#34;&#34;
    def __init__(
        self,
        name: str,
        ptype: type,
        type_info: str,
        pk: bool,
        fk: Optional[Relations],
        incremental: Optional[Any],
        nullable: bool,
        comment: str = &#34;&#34;,
    ):
        #: Column name.
        self.name = name
        #: Data type in python.
        self.ptype = ptype
        #: Type informations obtained from DB.
        self.type_info = type_info
        #: Is this column a primary key?
        self.pk = pk
        #: Foreign key constraints.
        self.fk = fk
        #: If this column is auto-incremental, this object contains the information of the feature, otherwise, `None`.
        self.incremental = incremental
        #: Can this column contain null?
        self.nullable = nullable
        #: Comment of the column.
        self.comment = comment</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.Column.comment"><code class="name">var <span class="ident">comment</span></code></dt>
<dd>
<div class="desc"><p>Comment of the column.</p></div>
</dd>
<dt id="pyracmon.Column.fk"><code class="name">var <span class="ident">fk</span></code></dt>
<dd>
<div class="desc"><p>Foreign key constraints.</p></div>
</dd>
<dt id="pyracmon.Column.incremental"><code class="name">var <span class="ident">incremental</span></code></dt>
<dd>
<div class="desc"><p>If this column is auto-incremental, this object contains the information of the feature, otherwise, <code>None</code>.</p></div>
</dd>
<dt id="pyracmon.Column.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Column name.</p></div>
</dd>
<dt id="pyracmon.Column.nullable"><code class="name">var <span class="ident">nullable</span></code></dt>
<dd>
<div class="desc"><p>Can this column contain null?</p></div>
</dd>
<dt id="pyracmon.Column.pk"><code class="name">var <span class="ident">pk</span></code></dt>
<dd>
<div class="desc"><p>Is this column a primary key?</p></div>
</dd>
<dt id="pyracmon.Column.ptype"><code class="name">var <span class="ident">ptype</span></code></dt>
<dd>
<div class="desc"><p>Data type in python.</p></div>
</dd>
<dt id="pyracmon.Column.type_info"><code class="name">var <span class="ident">type_info</span></code></dt>
<dd>
<div class="desc"><p>Type informations obtained from DB.</p></div>
</dd>
</dl>
</dd>
<dt id="pyracmon.Conditional"><code class="flex name class">
<span>class <span class="ident">Conditional</span></span>
<span>(</span><span>expression='', params=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a query condition composed of an expression and parameters.</p>
<p>Parameters must be a list where the index of each parameter matches the index of placeholder for it.
The expression accepts only the automatic numbering template parameter <code>$_</code>.</p>
<p>Applying logical operators such as <code>&amp;</code>, <code>|</code> and <code>~</code> generates new condition.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; c1 = Q.of(&quot;a = $_&quot;, 0)
&gt;&gt;&gt; c2 = Q.of(&quot;b &lt; $_&quot;, 1)
&gt;&gt;&gt; c3 = Q.of(&quot;c &gt; $_&quot;, 2)
&gt;&gt;&gt; c = ~(c1 &amp; c2 | c3)
&gt;&gt;&gt; c
Condition: NOT (((a = $_) AND (b &lt; $_)) OR (c &gt; $_)) -- [0, 1, 2]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Conditional(Expression):
    &#34;&#34;&#34;
    Represents a query condition composed of an expression and parameters.

    Parameters must be a list where the index of each parameter matches the index of placeholder for it.
    The expression accepts only the automatic numbering template parameter `$_`.

    Applying logical operators such as `&amp;`, `|` and `~` generates new condition.

    &gt;&gt;&gt; c1 = Q.of(&#34;a = $_&#34;, 0)
    &gt;&gt;&gt; c2 = Q.of(&#34;b &lt; $_&#34;, 1)
    &gt;&gt;&gt; c3 = Q.of(&#34;c &gt; $_&#34;, 2)
    &gt;&gt;&gt; c = ~(c1 &amp; c2 | c3)
    &gt;&gt;&gt; c
    Condition: NOT (((a = $_) AND (b &lt; $_)) OR (c &gt; $_)) -- [0, 1, 2]
    &#34;&#34;&#34;
    @classmethod
    def all(cls, conditionals: Iterable[&#39;Conditional&#39;]) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Concatenates conditional objects with `AND`.

        Args:
            conditionals: Condition objects.
        Returns:
            Concatenated condition object.
        &#34;&#34;&#34;
        return reduce(lambda acc, c: acc &amp; c, conditionals, Conditional())

    @classmethod
    def any(cls, conditionals: Iterable[&#39;Conditional&#39;]) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Concatenates conditional objects with `OR`.

        Args:
            conditionals: Condition objects.
        Returns:
            Concatenated condition object.
        &#34;&#34;&#34;
        return reduce(lambda acc, c: acc | c, conditionals, Conditional())

    def __init__(self, expression=&#34;&#34;, params=None):
        super().__init__(expression, params or [])

    def __repr__(self):
        return f&#34;Condition: &#39;{self.expression}&#39; -- {self.params}&#34;

    def __call__(self, marker):
        &#34;&#34;&#34;
        .. deprecated:: 1.0.0
        &#34;&#34;&#34;
        c, p = Sql(marker, self.expression).render(*self.params)
        if not isinstance(p, list):
            raise ValueError(f&#34;Only list style marker is available.&#34;)
        return Conditional(c, p)

    def __and__(self, other):
        expression = &#34;&#34;
        if self.expression and other.expression:
            expression = f&#34;({self.expression}) AND ({other.expression})&#34;
        elif self.expression:
            expression = self.expression
        elif other.expression:
            expression = other.expression

        return Conditional(expression, self.params + other.params)

    def __or__(self, other):
        expression = &#34;&#34;
        if self.expression and other.expression:
            expression = f&#34;({self.expression}) OR ({other.expression})&#34;
        elif self.expression:
            expression = self.expression
        elif other.expression:
            expression = other.expression

        return Conditional(expression, self.params + other.params)

    def __invert__(self):
        if self.expression:
            return Conditional(f&#34;NOT ({self.expression})&#34;, self.params)
        else:
            return Conditional(f&#34;1 = 0&#34;, [])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.query.Expression" href="query.html#pyracmon.query.Expression">Expression</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.Conditional.all"><code class="name flex">
<span>def <span class="ident">all</span></span>(<span>conditionals: Iterable[ForwardRef('<a title="pyracmon.Conditional" href="#pyracmon.Conditional">Conditional</a>')]) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates conditional objects with <code>AND</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>conditionals</code></strong></dt>
<dd>Condition objects.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Concatenated condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def all(cls, conditionals: Iterable[&#39;Conditional&#39;]) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Concatenates conditional objects with `AND`.

    Args:
        conditionals: Condition objects.
    Returns:
        Concatenated condition object.
    &#34;&#34;&#34;
    return reduce(lambda acc, c: acc &amp; c, conditionals, Conditional())</code></pre>
</details>
</dd>
<dt id="pyracmon.Conditional.any"><code class="name flex">
<span>def <span class="ident">any</span></span>(<span>conditionals: Iterable[ForwardRef('<a title="pyracmon.Conditional" href="#pyracmon.Conditional">Conditional</a>')]) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates conditional objects with <code>OR</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>conditionals</code></strong></dt>
<dd>Condition objects.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Concatenated condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def any(cls, conditionals: Iterable[&#39;Conditional&#39;]) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Concatenates conditional objects with `OR`.

    Args:
        conditionals: Condition objects.
    Returns:
        Concatenated condition object.
    &#34;&#34;&#34;
    return reduce(lambda acc, c: acc | c, conditionals, Conditional())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyracmon.query.Expression" href="query.html#pyracmon.query.Expression">Expression</a></b></code>:
<ul class="hlist">
<li><code><a title="pyracmon.query.Expression.expression" href="query.html#pyracmon.query.Expression.expression">expression</a></code></li>
<li><code><a title="pyracmon.query.Expression.params" href="query.html#pyracmon.query.Expression.params">params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyracmon.Connection"><code class="flex name class">
<span>class <span class="ident">Connection</span></span>
<span>(</span><span>api, conn, context_factory=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper class of DB-API 2.0 Connection.</p>
<p>Every instance works as the proxy object to original connection, therefore any attribute in it is still available.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Connection:
    &#34;&#34;&#34;
    Wrapper class of DB-API 2.0 Connection.

    Every instance works as the proxy object to original connection, therefore any attribute in it is still available.
    &#34;&#34;&#34;
    _characters = string.ascii_letters + string.digits + &#34;.=&#34;

    def __init__(self, api, conn, context_factory=None):
        #: A string which identifies a connection.
        self.identifier = self._gen_identifier()
        self.api = api
        self.conn = conn
        self.context_factory = context_factory
        self._context = None

    def __getattr__(self, name):
        return getattr(self.conn, name)

    def __enter__(self):
        if hasattr(self.conn, &#34;__enter__&#34;):
            self.conn.__enter__()
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        if hasattr(self.conn, &#34;__exit__&#34;):
            self.conn.__exit__(exc_type, exc_value, traceback)
        else:
            if exc_value is None:
                self.conn.rollback()
            else:
                self.conn.commit()
            self.conn.close()

    def _gen_identifier(self):
        t = int(datetime.now().timestamp() * 1000)

        def gen(x):
            base = len(Connection._characters)
            while x &gt;= base:
                x, r = divmod(x, base)
                yield Connection._characters[r]
            yield Connection._characters[x]

        return threading.current_thread().name + &#34;-&#34; + &#39;&#39;.join(gen(t))[::-1]

    @property
    def context(self) -&gt; ConnectionContext:
        &#34;&#34;&#34;
        Context object used for this connection.
        &#34;&#34;&#34;
        if not self._context:
            self._context = (self.context_factory or ConnectionContext)()
            self._context.identifier = self.identifier
        return self._context

    def use(self, factory: Callable[[], ConnectionContext]) -&gt; &#39;Connection&#39;:
        &#34;&#34;&#34;
        Set factory function of `ConnectionContext`.

        Use this method to use your custom context object.

        Args:
            factory: Function returning custom context object.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self.context_factory = factory
        return self

    def stmt(self, context: Optional[ConnectionContext] = None) -&gt; &#39;Statement&#39;:
        &#34;&#34;&#34;
        Creates new statement which provides methods to execute query.

        Args:
            context: Context object used in the statement. If `None`, the context of this connection is used.
        Returns:
            Created statement.
        &#34;&#34;&#34;
        return Statement(self, context or self.context)

    @property
    def helper(self) -&gt; QueryHelper:
        &#34;&#34;&#34;
        .. deprecated:: 1.0.0
        &#34;&#34;&#34;
        return QueryHelper(self.api, None)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.Connection.context"><code class="name">var <span class="ident">context</span> : <a title="pyracmon.context.ConnectionContext" href="context.html#pyracmon.context.ConnectionContext">ConnectionContext</a></code></dt>
<dd>
<div class="desc"><p>Context object used for this connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def context(self) -&gt; ConnectionContext:
    &#34;&#34;&#34;
    Context object used for this connection.
    &#34;&#34;&#34;
    if not self._context:
        self._context = (self.context_factory or ConnectionContext)()
        self._context.identifier = self.identifier
    return self._context</code></pre>
</details>
</dd>
<dt id="pyracmon.Connection.helper"><code class="name">var <span class="ident">helper</span> : <a title="pyracmon.query.QueryHelper" href="query.html#pyracmon.query.QueryHelper">QueryHelper</a></code></dt>
<dd>
<div class="desc"><div class="admonition deprecated">
<p class="admonition-title">Deprecated since version:&ensp;1.0.0</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def helper(self) -&gt; QueryHelper:
    &#34;&#34;&#34;
    .. deprecated:: 1.0.0
    &#34;&#34;&#34;
    return QueryHelper(self.api, None)</code></pre>
</details>
</dd>
<dt id="pyracmon.Connection.identifier"><code class="name">var <span class="ident">identifier</span></code></dt>
<dd>
<div class="desc"><p>A string which identifies a connection.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.Connection.stmt"><code class="name flex">
<span>def <span class="ident">stmt</span></span>(<span>self, context: Optional[<a title="pyracmon.context.ConnectionContext" href="context.html#pyracmon.context.ConnectionContext">ConnectionContext</a>] = None) ‑> <a title="pyracmon.connection.Statement" href="connection.html#pyracmon.connection.Statement">Statement</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates new statement which provides methods to execute query.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong></dt>
<dd>Context object used in the statement. If <code>None</code>, the context of this connection is used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Created statement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stmt(self, context: Optional[ConnectionContext] = None) -&gt; &#39;Statement&#39;:
    &#34;&#34;&#34;
    Creates new statement which provides methods to execute query.

    Args:
        context: Context object used in the statement. If `None`, the context of this connection is used.
    Returns:
        Created statement.
    &#34;&#34;&#34;
    return Statement(self, context or self.context)</code></pre>
</details>
</dd>
<dt id="pyracmon.Connection.use"><code class="name flex">
<span>def <span class="ident">use</span></span>(<span>self, factory: Callable[[], <a title="pyracmon.context.ConnectionContext" href="context.html#pyracmon.context.ConnectionContext">ConnectionContext</a>]) ‑> <a title="pyracmon.connection.Connection" href="connection.html#pyracmon.connection.Connection">Connection</a></span>
</code></dt>
<dd>
<div class="desc"><p>Set factory function of <code><a title="pyracmon.ConnectionContext" href="#pyracmon.ConnectionContext">ConnectionContext</a></code>.</p>
<p>Use this method to use your custom context object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>factory</code></strong></dt>
<dd>Function returning custom context object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def use(self, factory: Callable[[], ConnectionContext]) -&gt; &#39;Connection&#39;:
    &#34;&#34;&#34;
    Set factory function of `ConnectionContext`.

    Use this method to use your custom context object.

    Args:
        factory: Function returning custom context object.
    Returns:
        This instance.
    &#34;&#34;&#34;
    self.context_factory = factory
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.ConnectionContext"><code class="flex name class">
<span>class <span class="ident">ConnectionContext</span></span>
<span>(</span><span>identifier=None, **configurations)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a context of query execution.</p>
<p>You don't need to care this object in most cases except for when you want to change the configuration at a query execution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConnectionContext:
    &#34;&#34;&#34;
    This class represents a context of query execution.

    You don&#39;t need to care this object in most cases except for when you want to change the configuration at a query execution.
    &#34;&#34;&#34;
    def __init__(self, identifier=None, **configurations):
        self.identifier = identifier
        self.config = default_config().derive(**configurations)

    def _message(self, message):
        return f&#34;({self.identifier}) {message}&#34; if self.identifier else message

    def configure(self, **configurations: Any) -&gt; &#39;ConnectionContext&#39;:
        &#34;&#34;&#34;
        Change configurations of this context.

        Args:
            configurations: Configurations. See `pyracmon.config` to know available keys.
        Returns:
            This instance.
        &#34;&#34;&#34;
        self.config.set(**configurations)
        return self

    def execute(self, cursor: &#39;Cursor&#39;, sql: str, params: List[Any]) -&gt; &#39;Cursor&#39;:
        &#34;&#34;&#34;
        Executes a query on a cursor.

        Query logging is also done in this method according to the configuration.

        This method is invoked from `ConnectionContext.execute` internally.
        When you intend to change behaviors of query executions,
        inherit this class, overwrite this method and set factory method for the class by `Connection.use` .

        Args:
            cursor: Cursor object.
            sql: Query string.
            params: Query parameters.
        Returns:
            Given cursor object. Internal state may be changed by the execution of the query.
        &#34;&#34;&#34;
        logger = _logger(self.config)

        if logger:
            sql_log = sql if len(sql) &lt;= self.config.sql_log_length else f&#34;{sql[0:self.config.sql_log_length]}...&#34;

            logger.log(self.config.log_level, self._message(sql_log))

            if self.config.parameter_log:
                logger.log(self.config.log_level, self._message(f&#34;Parameters: {params}&#34;))

        cursor.execute(sql, params)

        return cursor</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.ConnectionContext.configure"><code class="name flex">
<span>def <span class="ident">configure</span></span>(<span>self, **configurations: Any) ‑> <a title="pyracmon.context.ConnectionContext" href="context.html#pyracmon.context.ConnectionContext">ConnectionContext</a></span>
</code></dt>
<dd>
<div class="desc"><p>Change configurations of this context.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>configurations</code></strong></dt>
<dd>Configurations. See <code><a title="pyracmon.config" href="config.html">pyracmon.config</a></code> to know available keys.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def configure(self, **configurations: Any) -&gt; &#39;ConnectionContext&#39;:
    &#34;&#34;&#34;
    Change configurations of this context.

    Args:
        configurations: Configurations. See `pyracmon.config` to know available keys.
    Returns:
        This instance.
    &#34;&#34;&#34;
    self.config.set(**configurations)
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.ConnectionContext.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, cursor: Cursor, sql: str, params: List[Any]) ‑> Cursor</span>
</code></dt>
<dd>
<div class="desc"><p>Executes a query on a cursor.</p>
<p>Query logging is also done in this method according to the configuration.</p>
<p>This method is invoked from <code><a title="pyracmon.ConnectionContext.execute" href="#pyracmon.ConnectionContext.execute">ConnectionContext.execute()</a></code> internally.
When you intend to change behaviors of query executions,
inherit this class, overwrite this method and set factory method for the class by <code><a title="pyracmon.Connection.use" href="#pyracmon.Connection.use">Connection.use()</a></code> .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cursor</code></strong></dt>
<dd>Cursor object.</dd>
<dt><strong><code>sql</code></strong></dt>
<dd>Query string.</dd>
<dt><strong><code>params</code></strong></dt>
<dd>Query parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Given cursor object. Internal state may be changed by the execution of the query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, cursor: &#39;Cursor&#39;, sql: str, params: List[Any]) -&gt; &#39;Cursor&#39;:
    &#34;&#34;&#34;
    Executes a query on a cursor.

    Query logging is also done in this method according to the configuration.

    This method is invoked from `ConnectionContext.execute` internally.
    When you intend to change behaviors of query executions,
    inherit this class, overwrite this method and set factory method for the class by `Connection.use` .

    Args:
        cursor: Cursor object.
        sql: Query string.
        params: Query parameters.
    Returns:
        Given cursor object. Internal state may be changed by the execution of the query.
    &#34;&#34;&#34;
    logger = _logger(self.config)

    if logger:
        sql_log = sql if len(sql) &lt;= self.config.sql_log_length else f&#34;{sql[0:self.config.sql_log_length]}...&#34;

        logger.log(self.config.log_level, self._message(sql_log))

        if self.config.parameter_log:
            logger.log(self.config.log_level, self._message(f&#34;Parameters: {params}&#34;))

    cursor.execute(sql, params)

    return cursor</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.ContainerView"><code class="flex name class">
<span>class <span class="ident">ContainerView</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContainerView:
    pass</code></pre>
</details>
</dd>
<dt id="pyracmon.Expression"><code class="flex name class">
<span>class <span class="ident">Expression</span></span>
<span>(</span><span>expression: str, params: List[Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Abstraction of expression is any query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Expression:
    &#34;&#34;&#34;
    Abstraction of expression is any query.
    &#34;&#34;&#34;
    def __init__(self, expression: str, params: List[Any]):
        #: Expression string.
        self.expression = expression
        #: Parameters corresponding to placeholders in the expression.
        self.params = params</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.Expression.expression"><code class="name">var <span class="ident">expression</span></code></dt>
<dd>
<div class="desc"><p>Expression string.</p></div>
</dd>
<dt id="pyracmon.Expression.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"><p>Parameters corresponding to placeholders in the expression.</p></div>
</dd>
</dl>
</dd>
<dt id="pyracmon.Graph"><code class="flex name class">
<span>class <span class="ident">Graph</span></span>
<span>(</span><span>template: <a title="pyracmon.graph.template.GraphTemplate" href="graph/template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a graph composed of tree-structured node containers.</p>
<p>The structure is determined by <code>GraphTemplate</code>. Use <code><a title="pyracmon.new_graph" href="#pyracmon.new_graph">new_graph()</a></code> Instead of constructor to create new graph instance.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; template = GraphSpac().new_template(
&gt;&gt;&gt;     a = (int, lambda x:x),
&gt;&gt;&gt;     b = (str, lambda x:x),
&gt;&gt;&gt;     c = (str, lambda x:x),
&gt;&gt;&gt; )
&gt;&gt;&gt; template.a &lt;&lt; template.b &lt;&lt; template.c
&gt;&gt;&gt; graph = new_graph(template)
</code></pre>
<p><code>append</code> ( <code>replace</code> ) is a method to store entities in the graph with tying them each other according to the structure.
Entites are encapsulated by <code><a title="pyracmon.Node" href="#pyracmon.Node">Node</a></code> which can have an edge to parent node.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.append(a=1, b=&quot;a&quot;, c=&quot;x&quot;).append(a=2, b=&quot;b&quot;, c=&quot;y&quot;)
</code></pre>
<p>In <code>append</code>, entities are first sorted in descending order, and then:</p>
<ul>
<li>Search a node whose entity is <em>identical</em> to the first entity from the corresponding node container.<ul>
<li>If found, new node is not created and the <em>identical</em> node is set to next parent.</li>
<li>Otherwise, new node is appended and it is set to next parent.</li>
</ul>
</li>
<li>Repeat above to following entities. A difference is that <em>identical</em> node is searched from the parent set in previous operation.</li>
</ul>
<p>In example here, the identification is done by entity value itself. Next code is the example where <em>identical</em> nodes are found.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; graph.append(a=1, b=&quot;a&quot;, c=&quot;z&quot;).append(a=2, b=&quot;c&quot;, c=&quot;y&quot;)
</code></pre>
<p>In the first <code>append</code>, <code>a</code> and <code>b</code> has its <em>identical</em> node and <code>a</code> is <em>identical</em> in the second.
<code>c</code> in the second one is not <em>identical</em> to any node because parent node <code>b="c"</code> is added as new node.</p>
<p>Due to the identification mechanism, repeatin <code>append</code> is sufficient to reconstruct entity relationships in the graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Graph:
    &#34;&#34;&#34;
    This class represents a graph composed of tree-structured node containers.

    The structure is determined by `GraphTemplate`. Use `new_graph` Instead of constructor to create new graph instance.

    &gt;&gt;&gt; template = GraphSpac().new_template(
    &gt;&gt;&gt;     a = (int, lambda x:x),
    &gt;&gt;&gt;     b = (str, lambda x:x),
    &gt;&gt;&gt;     c = (str, lambda x:x),
    &gt;&gt;&gt; )
    &gt;&gt;&gt; template.a &lt;&lt; template.b &lt;&lt; template.c
    &gt;&gt;&gt; graph = new_graph(template)

    `append` ( `replace` ) is a method to store entities in the graph with tying them each other according to the structure.
    Entites are encapsulated by `Node` which can have an edge to parent node.

    &gt;&gt;&gt; graph.append(a=1, b=&#34;a&#34;, c=&#34;x&#34;).append(a=2, b=&#34;b&#34;, c=&#34;y&#34;)

    In `append`, entities are first sorted in descending order, and then:

    - Search a node whose entity is *identical* to the first entity from the corresponding node container.
        - If found, new node is not created and the *identical* node is set to next parent.
        - Otherwise, new node is appended and it is set to next parent.
    - Repeat above to following entities. A difference is that *identical* node is searched from the parent set in previous operation.

    In example here, the identification is done by entity value itself. Next code is the example where *identical* nodes are found.

    &gt;&gt;&gt; graph.append(a=1, b=&#34;a&#34;, c=&#34;z&#34;).append(a=2, b=&#34;c&#34;, c=&#34;y&#34;)

    In the first `append`, `a` and `b` has its *identical* node and `a` is *identical* in the second.
    `c` in the second one is not *identical* to any node because parent node `b=&#34;c&#34;` is added as new node.

    Due to the identification mechanism, repeatin `append` is sufficient to reconstruct entity relationships in the graph.
    &#34;&#34;&#34;
    def __init__(self, template: GraphTemplate):
        #: Graph template.
        self.template = template
        #: A `dict` containing node containers by their names.
        self.containers = {p.name:self._to_container(p) for p in template._properties}
        self._view = None

    def _to_container(self, prop):
        if isinstance(prop.kind, GraphTemplate):
            return _GraphNodeContainer(prop)
        else:
            return NodeContainer(prop)

    def _container_of(self, prop):
        cands = [c for c in self.containers.values() if c.prop.is_compatible(prop)]
        if len(cands) &gt; 1:
            raise ValueError(f&#34;Container can&#39;t be determined from property &#39;{prop.name}&#39;.&#34;)
        return cands[0] if cands else None

    def __add__(self, another: Union[&#39;Graph&#39;, GraphView]) -&gt; &#39;Graph&#39;:
        &#34;&#34;&#34;
        Create new graph by adding this graph and another graph.

        New graph has the same template as this graph&#39;S.
        On the other hand, because this method depends on `__iadd__()`, another graph must not have the same template.

        Args:
            another: Graph or its view.
        Returns:
            Created graph.
        &#34;&#34;&#34;
        graph = Graph(self.template)

        graph += self
        graph += another

        return graph

    def __iadd__(self, another: Union[&#39;Graph&#39;, GraphView]) -&gt; &#39;Graph&#39;:
        &#34;&#34;&#34;
        Append nodes from another graph.

        Templates of this graph and another graph must not be the same.
        Nodes of another graph are traversed from its root and appended to compatible containers each other.

        Args:
            another: Graph or its view.
        Returns:
            This graph.
        &#34;&#34;&#34;
        another = another if isinstance(another, Graph) else another()

        roots_ = filter(lambda c: c.prop.parent is None, another.containers.values())

        def add(n, anc):
            c = self._container_of(n.prop)
            if c:
                c.append(n.entity, anc)
            for ch_ in n.children.values():
                for m in ch_.nodes:
                    add(m, anc.copy())

        for c_ in roots_:
            for n_ in c_.nodes:
                add(n_, {})

        return self

    @property
    def view(self) -&gt; GraphView:
        &#34;&#34;&#34;
        Returns an unmodifiable view of this graph.

        The view object works as the accessor to graph components.

        - Returns a graph instance when invoked as callable object.
        - The attribute of a container name returns the container view.
        - In iteration context, it iterates views of root containers.
            - Root container is the container which has no parent.

        &gt;&gt;&gt; template = GraphSpac().new_template(a=int, b=str, c=str)
        &gt;&gt;&gt; template.a &lt;&lt; template.b
        &gt;&gt;&gt; graph = new_graph(template)
        &gt;&gt;&gt; view = graph.view
        &gt;&gt;&gt; assert view() is graph                        # invocation
        &gt;&gt;&gt; assert view.a is graph.containers[&#34;a&#34;].view   # attribute
        &gt;&gt;&gt; assert [c().name for c in view] == [&#34;a&#34;, &#34;c&#34;] # iteration
        &#34;&#34;&#34;
        if self._view is None:
            graph = self
            class _GraphView:
                def __call__(self):
                    &#34;&#34;&#34;Returns the greph of this view.&#34;&#34;&#34;
                    return graph
                def __iter__(self):
                    &#34;&#34;&#34;Iterates views of root containers.&#34;&#34;&#34;
                    return map(lambda c: (c.name, c.view), filter(lambda c: c.prop.parent is None, graph.containers.values()))
                def __getattr__(self, name):
                    &#34;&#34;&#34;Returns a view of a container of the name.&#34;&#34;&#34;
                    return graph.containers[name].view
            self._view = _GraphView()
        return self._view

    def _append(self, to_replace, entities):
        props = [p for p in self.template if p.name in entities]

        filtered = set()
        for p in props:
            if (p.parent is None) or (p.parent.name not in entities) or (p.parent.name in filtered):
                if p.entity_filter is None or p.entity_filter(entities[p.name]):
                    filtered.add(p.name)

        ancestors = {}
        for k in [p.name for p in props if p.name in filtered]:
            self.containers[k].append(entities[k], ancestors, to_replace)

        return self

    def append(self, **entities: Any) -&gt; &#39;Graph&#39;:
        &#34;&#34;&#34;
        Append entities with associated property names.

        Args:
            entities: Entities keyed with associated property names.
        Returns:
            This graph.
        &#34;&#34;&#34;
        return self._append(False, entities)

    def replace(self, **entities: Any) -&gt; &#39;Graph&#39;:
        &#34;&#34;&#34;
        Works similarly to `append`, but entities of identical nodes are replaced with given entities.

        Args:
            entities: Entities keyed with associated property names.
        Returns:
            This graph.
        &#34;&#34;&#34;
        return self._append(True, entities)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.Graph.containers"><code class="name">var <span class="ident">containers</span></code></dt>
<dd>
<div class="desc"><p>A <code>dict</code> containing node containers by their names.</p></div>
</dd>
<dt id="pyracmon.Graph.template"><code class="name">var <span class="ident">template</span></code></dt>
<dd>
<div class="desc"><p>Graph template.</p></div>
</dd>
<dt id="pyracmon.Graph.view"><code class="name">var <span class="ident">view</span> : <a title="pyracmon.graph.graph.GraphView" href="graph/graph.html#pyracmon.graph.graph.GraphView">GraphView</a></code></dt>
<dd>
<div class="desc"><p>Returns an unmodifiable view of this graph.</p>
<p>The view object works as the accessor to graph components.</p>
<ul>
<li>Returns a graph instance when invoked as callable object.</li>
<li>The attribute of a container name returns the container view.</li>
<li>In iteration context, it iterates views of root containers.<ul>
<li>Root container is the container which has no parent.</li>
</ul>
</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; template = GraphSpac().new_template(a=int, b=str, c=str)
&gt;&gt;&gt; template.a &lt;&lt; template.b
&gt;&gt;&gt; graph = new_graph(template)
&gt;&gt;&gt; view = graph.view
&gt;&gt;&gt; assert view() is graph                        # invocation
&gt;&gt;&gt; assert view.a is graph.containers[&quot;a&quot;].view   # attribute
&gt;&gt;&gt; assert [c().name for c in view] == [&quot;a&quot;, &quot;c&quot;] # iteration
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def view(self) -&gt; GraphView:
    &#34;&#34;&#34;
    Returns an unmodifiable view of this graph.

    The view object works as the accessor to graph components.

    - Returns a graph instance when invoked as callable object.
    - The attribute of a container name returns the container view.
    - In iteration context, it iterates views of root containers.
        - Root container is the container which has no parent.

    &gt;&gt;&gt; template = GraphSpac().new_template(a=int, b=str, c=str)
    &gt;&gt;&gt; template.a &lt;&lt; template.b
    &gt;&gt;&gt; graph = new_graph(template)
    &gt;&gt;&gt; view = graph.view
    &gt;&gt;&gt; assert view() is graph                        # invocation
    &gt;&gt;&gt; assert view.a is graph.containers[&#34;a&#34;].view   # attribute
    &gt;&gt;&gt; assert [c().name for c in view] == [&#34;a&#34;, &#34;c&#34;] # iteration
    &#34;&#34;&#34;
    if self._view is None:
        graph = self
        class _GraphView:
            def __call__(self):
                &#34;&#34;&#34;Returns the greph of this view.&#34;&#34;&#34;
                return graph
            def __iter__(self):
                &#34;&#34;&#34;Iterates views of root containers.&#34;&#34;&#34;
                return map(lambda c: (c.name, c.view), filter(lambda c: c.prop.parent is None, graph.containers.values()))
            def __getattr__(self, name):
                &#34;&#34;&#34;Returns a view of a container of the name.&#34;&#34;&#34;
                return graph.containers[name].view
        self._view = _GraphView()
    return self._view</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.Graph.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, **entities: Any) ‑> <a title="pyracmon.graph.graph.Graph" href="graph/graph.html#pyracmon.graph.graph.Graph">Graph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Append entities with associated property names.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entities</code></strong></dt>
<dd>Entities keyed with associated property names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, **entities: Any) -&gt; &#39;Graph&#39;:
    &#34;&#34;&#34;
    Append entities with associated property names.

    Args:
        entities: Entities keyed with associated property names.
    Returns:
        This graph.
    &#34;&#34;&#34;
    return self._append(False, entities)</code></pre>
</details>
</dd>
<dt id="pyracmon.Graph.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, **entities: Any) ‑> <a title="pyracmon.graph.graph.Graph" href="graph/graph.html#pyracmon.graph.graph.Graph">Graph</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works similarly to <code>append</code>, but entities of identical nodes are replaced with given entities.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entities</code></strong></dt>
<dd>Entities keyed with associated property names.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def replace(self, **entities: Any) -&gt; &#39;Graph&#39;:
    &#34;&#34;&#34;
    Works similarly to `append`, but entities of identical nodes are replaced with given entities.

    Args:
        entities: Entities keyed with associated property names.
    Returns:
        This graph.
    &#34;&#34;&#34;
    return self._append(True, entities)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.GraphSchema"><code class="flex name class">
<span>class <span class="ident">GraphSchema</span></span>
<span>(</span><span>spec: GraphSpec, template: <a title="pyracmon.graph.template.GraphTemplate" href="graph/template.html#pyracmon.graph.template.GraphTemplate">GraphTemplate</a>, **serializers: NodeSerializer)</span>
</code></dt>
<dd>
<div class="desc"><p>This class exposes a property to get the schema of serialization result of a graph.</p>
<p>Schema generation also depends on <code>GraphSpec</code> , on which <code>serialize</code> serializes a graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphSchema:
    &#34;&#34;&#34;
    This class exposes a property to get the schema of serialization result of a graph.

    Schema generation also depends on `GraphSpec` , on which `serialize` serializes a graph.
    &#34;&#34;&#34;
    def __init__(self, spec: &#39;GraphSpec&#39;, template: GraphTemplate, **serializers: &#39;NodeSerializer&#39;):
        #: Specification of graph operations.
        self.spec = spec
        #: Graph template to serialize.
        self.template = template
        #: `NodeSerializer`s used for the serialization.
        self.serializers = serializers

    def _return_from(self, prop):
        ns = self.serializers[prop.name]

        arg = prop.kind

        # Generate a type holding GraphTemplate.
        # This type is ignored because serializer added by sub() resolve the type by iteself.
        arg = _templateType(prop.kind) if isinstance(prop.kind, GraphTemplate) else arg

        # Return type of serializers set to NodeSerializer.
        rt = signature(ns.serializer).return_annotation

        # Return type of base serializer obtained from GraphSpec.
        base = chain_serializers(self.spec.find_serializers(arg))

        bt = signature(base).return_annotation if base else Signature.empty
        bt = arg if bt == Signature.empty else bt

        if rt == Signature.empty:
            rt = bt
            bt = arg

        if issubgeneric(bt, Typeable):
            bt = bt if Typeable.is_resolved(bt) else bt[arg]

        if issubgeneric(rt, Typeable):
            if not Typeable.is_resolved(rt):
                rt = rt[bt]
            rt = Typeable.resolve(rt, arg, self.spec)

        return rt

    def schema_of(self, prop: GraphTemplate.Property) -&gt; Type[Annotated]:
        &#34;&#34;&#34;
        Generates structured and documented schema for a template property.

        Args:
            prop: A template property.
        Returns:
            Schema with documentation.
        &#34;&#34;&#34;
        rt = self._return_from(prop)

        doc = self.serializers[prop.name]._doc or &#34;&#34;

        if issubclass(rt, dict):
            annotations = {}

            for c in filter(lambda c: c.name in self.serializers, prop.children):
                ns = self.serializers[c.name]
                cs = self.schema_of(c)

                t, d = _decompose_document(cs)

                if ns.be_merged:
                    if not issubclass(t, dict):
                        raise ValueError(f&#34;Property &#39;{c.name}&#39; is not configured to be serialized into dict.&#34;)
                    annotations.update(**{ns.namer(k):t for k, t in get_annotated_hints(t).items()})
                else:
                    annotations[ns.namer(c.name)] = cs if ns.be_singular else document_type(List[t], d)

            return document_type(generate_schema(annotations, rt), doc)
        else:
            return document_type(rt, doc)

    @property
    def schema(self) -&gt; TypedDict:
        &#34;&#34;&#34;
        Generates `TypedDict` which represents the schema of serialized graph.
        &#34;&#34;&#34;
        annotations = {}

        def put_root_schema(p):
            nonlocal annotations

            ns = self.serializers[p.name]
            dt = self.schema_of(p)

            if ns.be_merged:
                t, d = _decompose_document(dt)
                annotations.update(**{ns.namer(k):t_ for k, t_ in get_annotated_hints(t).items()})
            elif ns.be_singular:
                rt = signature(ns.aggregator).return_annotation
                if rt == Signature.empty or isinstance(rt, TypeVar):
                    rt = dt
                annotations[ns.namer(p.name)] = rt
            else:
                t, d = _decompose_document(dt)
                annotations[ns.namer(p.name)] = document_type(List[t], d)

        roots = filter(lambda p: p.parent is None and p.name in self.serializers, self.template._properties)

        for p in roots:
            put_root_schema(p)

        return generate_schema(annotations)

    def serialize(self, graph: &#39;GraphView&#39;, **node_params: Dict[str, Dict[str, Any]]) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;
        Serialize graph into a dictionary.

        Args:
            graph: A view of a graph.
            node_params: Parameters passed to `SerializationContext` and used by *serializer* s.
        Returns:
            Serialization result.
        &#34;&#34;&#34;
        return self.spec.to_dict(graph, node_params, **self.serializers)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.GraphSchema.schema"><code class="name">var <span class="ident">schema</span> : typing_extensions.TypedDict</code></dt>
<dd>
<div class="desc"><p>Generates <code><a title="pyracmon.TypedDict" href="#pyracmon.TypedDict">TypedDict</a></code> which represents the schema of serialized graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def schema(self) -&gt; TypedDict:
    &#34;&#34;&#34;
    Generates `TypedDict` which represents the schema of serialized graph.
    &#34;&#34;&#34;
    annotations = {}

    def put_root_schema(p):
        nonlocal annotations

        ns = self.serializers[p.name]
        dt = self.schema_of(p)

        if ns.be_merged:
            t, d = _decompose_document(dt)
            annotations.update(**{ns.namer(k):t_ for k, t_ in get_annotated_hints(t).items()})
        elif ns.be_singular:
            rt = signature(ns.aggregator).return_annotation
            if rt == Signature.empty or isinstance(rt, TypeVar):
                rt = dt
            annotations[ns.namer(p.name)] = rt
        else:
            t, d = _decompose_document(dt)
            annotations[ns.namer(p.name)] = document_type(List[t], d)

    roots = filter(lambda p: p.parent is None and p.name in self.serializers, self.template._properties)

    for p in roots:
        put_root_schema(p)

    return generate_schema(annotations)</code></pre>
</details>
</dd>
<dt id="pyracmon.GraphSchema.serializers"><code class="name">var <span class="ident">serializers</span></code></dt>
<dd>
<div class="desc"><p><code>NodeSerializer</code>s used for the serialization.</p></div>
</dd>
<dt id="pyracmon.GraphSchema.spec"><code class="name">var <span class="ident">spec</span></code></dt>
<dd>
<div class="desc"><p>Specification of graph operations.</p></div>
</dd>
<dt id="pyracmon.GraphSchema.template"><code class="name">var <span class="ident">template</span></code></dt>
<dd>
<div class="desc"><p>Graph template to serialize.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.GraphSchema.schema_of"><code class="name flex">
<span>def <span class="ident">schema_of</span></span>(<span>self, prop: <a title="pyracmon.graph.template.GraphTemplate.Property" href="graph/template.html#pyracmon.graph.template.GraphTemplate.Property">GraphTemplate.Property</a>) ‑> Type[typing_extensions.Annotated]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates structured and documented schema for a template property.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>prop</code></strong></dt>
<dd>A template property.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Schema with documentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def schema_of(self, prop: GraphTemplate.Property) -&gt; Type[Annotated]:
    &#34;&#34;&#34;
    Generates structured and documented schema for a template property.

    Args:
        prop: A template property.
    Returns:
        Schema with documentation.
    &#34;&#34;&#34;
    rt = self._return_from(prop)

    doc = self.serializers[prop.name]._doc or &#34;&#34;

    if issubclass(rt, dict):
        annotations = {}

        for c in filter(lambda c: c.name in self.serializers, prop.children):
            ns = self.serializers[c.name]
            cs = self.schema_of(c)

            t, d = _decompose_document(cs)

            if ns.be_merged:
                if not issubclass(t, dict):
                    raise ValueError(f&#34;Property &#39;{c.name}&#39; is not configured to be serialized into dict.&#34;)
                annotations.update(**{ns.namer(k):t for k, t in get_annotated_hints(t).items()})
            else:
                annotations[ns.namer(c.name)] = cs if ns.be_singular else document_type(List[t], d)

        return document_type(generate_schema(annotations, rt), doc)
    else:
        return document_type(rt, doc)</code></pre>
</details>
</dd>
<dt id="pyracmon.GraphSchema.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self, graph: <a title="pyracmon.GraphView" href="#pyracmon.GraphView">GraphView</a>, **node_params: Dict[str, Dict[str, Any]]) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize graph into a dictionary.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>graph</code></strong></dt>
<dd>A view of a graph.</dd>
<dt><strong><code>node_params</code></strong></dt>
<dd>Parameters passed to <code>SerializationContext</code> and used by <em>serializer</em> s.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Serialization result.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self, graph: &#39;GraphView&#39;, **node_params: Dict[str, Dict[str, Any]]) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;
    Serialize graph into a dictionary.

    Args:
        graph: A view of a graph.
        node_params: Parameters passed to `SerializationContext` and used by *serializer* s.
    Returns:
        Serialization result.
    &#34;&#34;&#34;
    return self.spec.to_dict(graph, node_params, **self.serializers)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.GraphView"><code class="flex name class">
<span>class <span class="ident">GraphView</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphView:
    pass</code></pre>
</details>
</dd>
<dt id="pyracmon.Model"><code class="flex name class">
<span>class <span class="ident">Model</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base type of model types.</p>
<p>This class only works as a marker of model types and gives no functionalities to them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Model:
    &#34;&#34;&#34;
    Base type of model types.

    This class only works as a marker of model types and gives no functionalities to them.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="pyracmon.Node"><code class="flex name class">
<span>class <span class="ident">Node</span></span>
<span>(</span><span>prop: <a title="pyracmon.graph.template.GraphTemplate.Property" href="graph/template.html#pyracmon.graph.template.GraphTemplate.Property">GraphTemplate.Property</a>, entity: Any, key: Optional[Any], index: int)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a node which contains an entity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Node:
    &#34;&#34;&#34;
    This class represents a node which contains an entity.
    &#34;&#34;&#34;
    class Children:
        &#34;&#34;&#34;
        This class represents a child nodes of a node.
        &#34;&#34;&#34;
        def __init__(self, prop: GraphTemplate.Property):
            self.nodes = []
            self.keys = set()
            #: Template property.
            self.prop = prop
            self._view = None

        @property
        def view(self) -&gt; NodeChildrenView:
            if self._view is None:
                base = self
                class _ChildrenView(NodeChildrenView):
                    def __bool__(self):
                        &#34;&#34;&#34;Returns whether this container is not empty.&#34;&#34;&#34;
                        return len(base.nodes) != 0
                    def __call__(self):
                        &#34;&#34;&#34;Returns children container.&#34;&#34;&#34;
                        return base
                    def __iter__(self):
                        &#34;&#34;&#34;Iterates views of child nodes.&#34;&#34;&#34;
                        return map(lambda n: n.view, base.nodes)
                    def __len__(self):
                        &#34;&#34;&#34;Returns the number of child nodes.&#34;&#34;&#34;
                        return len(base.nodes)
                    def __getitem__(self, index):
                        &#34;&#34;&#34;Returns a view of child node at the index.&#34;&#34;&#34;
                        if isinstance(index, slice):
                            return [n.view for n in base.nodes[index]]
                        else:
                            return base.nodes[index].view
                    def __getattr__(self, key):
                        &#34;&#34;&#34;Returns a view of the first node or empty container view if it does not exist.&#34;&#34;&#34;
                        child = next(filter(lambda c: c.name == key, base.prop.children), None)
                        if child:
                            return base.nodes[0].children[key].view if len(base.nodes) &gt; 0 else _EmptyContainerView(child)
                        else:
                            raise KeyError(f&#34;Graph property &#39;{base.prop.name}&#39; does not have a child property &#39;{key}&#39;.&#34;)
                self._view = _ChildrenView()
            return self._view

        def has(self, node):
            return node in self.keys

        def append(self, node):
            if node not in self.keys:
                self.keys.add(node)
                self.nodes.append(node)

    def __init__(self, prop: GraphTemplate.Property, entity: Any, key: Optional[Any], index: int):
        #: Template property.
        self.prop = prop
        #: An entity value.
        self.entity = entity
        self.key = key
        self.parents = set()
        self.children = {c.name: Node.Children(c) for c in prop.children}
        self._index = index
        self._view = None

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the container name, which is same as the name of template property.
        &#34;&#34;&#34;
        return self.prop.name

    @property
    def view(self) -&gt; NodeView:
        &#34;&#34;&#34;
        Returns an unmodifiable view of this node.

        The view object works as the accessor to container components.

        - Returns a node instance when invoked as callable object.
        - The attribute of a child name returns the child container view.
        - In iteration context, it iterates pairs of child conainter name and its view.
        &#34;&#34;&#34;
        if self._view is None:
            node = self
            class _NodeView(NodeView):
                def __call__(self, alt=None):
                    &#34;&#34;&#34;Returns an entity of this node.&#34;&#34;&#34;
                    return node.entity
                def __getattr__(self, name):
                    &#34;&#34;&#34;Returns a view of child nodes by its name.&#34;&#34;&#34;
                    return node.children[name].view
                def __iter__(self):
                    &#34;&#34;&#34;Iterate key-value pairs of child nodes.&#34;&#34;&#34;
                    return map(lambda nc: (nc[0], nc[1].view), node.children.items())
            self._view = _NodeView()
        return self._view

    def add_child(self, child: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        &#34;&#34;&#34;
        Adds a child node.

        Args:
            child: Child node.
        Returns:
            This instance.
        &#34;&#34;&#34;
        if child.prop.template != self.prop.template:
            raise ValueError(f&#34;Nodes from different graph template can&#39;t be associated.&#34;)
        self.children[child.prop.name].append(child)
        child.parents.add(self)
        return self

    def has_child(self, child: &#39;Node&#39;) -&gt; bool:
        &#34;&#34;&#34;
        Checks this node contains the node identical to given node.

        Args:
            child: Node to search.
        Returns:
            `True` if exists.
        &#34;&#34;&#34;
        if child.prop.template != self.prop.template:
            return False
        elif child.prop.name in self.children:
            return child in self.children[child.prop.name].keys
        else:
            return False</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyracmon.graph.graph._GraphNode</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pyracmon.Node.Children"><code class="name">var <span class="ident">Children</span></code></dt>
<dd>
<div class="desc"><p>This class represents a child nodes of a node.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.Node.entity"><code class="name">var <span class="ident">entity</span></code></dt>
<dd>
<div class="desc"><p>An entity value.</p></div>
</dd>
<dt id="pyracmon.Node.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the container name, which is same as the name of template property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the container name, which is same as the name of template property.
    &#34;&#34;&#34;
    return self.prop.name</code></pre>
</details>
</dd>
<dt id="pyracmon.Node.prop"><code class="name">var <span class="ident">prop</span></code></dt>
<dd>
<div class="desc"><p>Template property.</p></div>
</dd>
<dt id="pyracmon.Node.view"><code class="name">var <span class="ident">view</span> : <a title="pyracmon.graph.graph.NodeView" href="graph/graph.html#pyracmon.graph.graph.NodeView">NodeView</a></code></dt>
<dd>
<div class="desc"><p>Returns an unmodifiable view of this node.</p>
<p>The view object works as the accessor to container components.</p>
<ul>
<li>Returns a node instance when invoked as callable object.</li>
<li>The attribute of a child name returns the child container view.</li>
<li>In iteration context, it iterates pairs of child conainter name and its view.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def view(self) -&gt; NodeView:
    &#34;&#34;&#34;
    Returns an unmodifiable view of this node.

    The view object works as the accessor to container components.

    - Returns a node instance when invoked as callable object.
    - The attribute of a child name returns the child container view.
    - In iteration context, it iterates pairs of child conainter name and its view.
    &#34;&#34;&#34;
    if self._view is None:
        node = self
        class _NodeView(NodeView):
            def __call__(self, alt=None):
                &#34;&#34;&#34;Returns an entity of this node.&#34;&#34;&#34;
                return node.entity
            def __getattr__(self, name):
                &#34;&#34;&#34;Returns a view of child nodes by its name.&#34;&#34;&#34;
                return node.children[name].view
            def __iter__(self):
                &#34;&#34;&#34;Iterate key-value pairs of child nodes.&#34;&#34;&#34;
                return map(lambda nc: (nc[0], nc[1].view), node.children.items())
        self._view = _NodeView()
    return self._view</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.Node.add_child"><code class="name flex">
<span>def <span class="ident">add_child</span></span>(<span>self, child: <a title="pyracmon.Node" href="#pyracmon.Node">Node</a>) ‑> <a title="pyracmon.graph.graph.Node" href="graph/graph.html#pyracmon.graph.graph.Node">Node</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds a child node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>child</code></strong></dt>
<dd>Child node.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_child(self, child: &#39;Node&#39;) -&gt; &#39;Node&#39;:
    &#34;&#34;&#34;
    Adds a child node.

    Args:
        child: Child node.
    Returns:
        This instance.
    &#34;&#34;&#34;
    if child.prop.template != self.prop.template:
        raise ValueError(f&#34;Nodes from different graph template can&#39;t be associated.&#34;)
    self.children[child.prop.name].append(child)
    child.parents.add(self)
    return self</code></pre>
</details>
</dd>
<dt id="pyracmon.Node.has_child"><code class="name flex">
<span>def <span class="ident">has_child</span></span>(<span>self, child: <a title="pyracmon.Node" href="#pyracmon.Node">Node</a>) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks this node contains the node identical to given node.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>child</code></strong></dt>
<dd>Node to search.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>True</code> if exists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_child(self, child: &#39;Node&#39;) -&gt; bool:
    &#34;&#34;&#34;
    Checks this node contains the node identical to given node.

    Args:
        child: Node to search.
    Returns:
        `True` if exists.
    &#34;&#34;&#34;
    if child.prop.template != self.prop.template:
        return False
    elif child.prop.name in self.children:
        return child in self.children[child.prop.name].keys
    else:
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.NodeChildrenView"><code class="flex name class">
<span>class <span class="ident">NodeChildrenView</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeChildrenView:
    pass</code></pre>
</details>
</dd>
<dt id="pyracmon.NodeContainer"><code class="flex name class">
<span>class <span class="ident">NodeContainer</span></span>
<span>(</span><span>prop: <a title="pyracmon.graph.template.GraphTemplate.Property" href="graph/template.html#pyracmon.graph.template.GraphTemplate.Property">GraphTemplate.Property</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a node container of a template property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeContainer:
    &#34;&#34;&#34;
    This class represents a node container of a template property.
    &#34;&#34;&#34;
    def __init__(self, prop: GraphTemplate.Property):
        self.nodes = []
        self.keys = {}
        #: Template property.
        self.prop = prop
        self._view = None

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;
        Returns the container name, which is same as the name of template property.
        &#34;&#34;&#34;
        return self.prop.name

    @property
    def view(self) -&gt; ContainerView:
        &#34;&#34;&#34;
        Returns an unmodifiable view of this container.

        The view object works as the accessor to container components.

        - Returns a container instance when invoked as callable object.
        - The attribute of a child name returns the child container view of the first node in this container.
        - Index access returns the view of node at the index.
        - In iteration context, it iterates views of nodes.
        - The number of nodes is returned by being applied to `len` .

        &gt;&gt;&gt; template = GraphSpac().new_template(a=int, b=str, c=str)
        &gt;&gt;&gt; template.a &lt;&lt; template.b
        &gt;&gt;&gt; graph = new_graph(template).append(a=1, b=&#34;a&#34;).append(a=1, b=&#34;b&#34;).append(a=2, b=&#34;c&#34;)
        &gt;&gt;&gt; container = graph.containers[&#34;a&#34;]
        &gt;&gt;&gt; view = graph.view.a
        &gt;&gt;&gt; assert view() is container                             # invocation
        &gt;&gt;&gt; assert view.b is container.nodes[0].children[&#34;b&#34;].view # attribute
        &gt;&gt;&gt; assert view[1] is container.nodes[1].view              # index
        &gt;&gt;&gt; assert [n() for n in view] == [1, 2]                   # iteration
        &gt;&gt;&gt; assert len(view) == 2                                  # length
        &#34;&#34;&#34;
        if self._view is None:
            container = self
            class _ContainerView(ContainerView):
                def __bool__(self):
                    &#34;&#34;&#34;Returns whether this container is not empty.&#34;&#34;&#34;
                    return len(container.nodes) != 0
                def __call__(self):
                    &#34;&#34;&#34;Returns a base container.&#34;&#34;&#34;
                    return container
                def __len__(self):
                    &#34;&#34;&#34;Returns the number of nodes.&#34;&#34;&#34;
                    return len(container.nodes)
                def __iter__(self):
                    &#34;&#34;&#34;Iterates views of nodes.&#34;&#34;&#34;
                    return map(lambda n: n.view, container.nodes)
                def __getitem__(self, index):
                    &#34;&#34;&#34;Returns a view of a node at the index.&#34;&#34;&#34;
                    if isinstance(index, slice):
                        return [n.view for n in container.nodes[index]]
                    else:
                        return container.nodes[index].view
                def __getattr__(self, key):
                    &#34;&#34;&#34;Returns a view of the first node or empty container view if it does not exist.&#34;&#34;&#34;
                    child = next(filter(lambda c: c.name == key, container.prop.children), None)
                    if child:
                        return container.nodes[0].children[key].view if len(container.nodes) &gt; 0 else _EmptyContainerView(child)
                    else:
                        raise KeyError(f&#34;Graph property &#39;{container.prop.name}&#39; does not have a child property &#39;{key}&#39;.&#34;)
            self._view = _ContainerView()
        return self._view

    def append(self, entity: Any, ancestors: Dict[str, List[&#39;Node&#39;]], to_replace: bool = False):
        &#34;&#34;&#34;
        Add an entity to this container.

        Identical node is searched by examining whether this container already contains a node of the identical entity
        and its parent is found in `anscestors` .

        Args:
            entity: An entity to be stored in the node.
            ancestors: Parent nodes mapped by property names.
            to_replace: If `True`, the entity of identical node is replaced. Otherwise, it is not changed.
        &#34;&#34;&#34;
        def get_nodes(k):
            return [self.nodes[i] for i in self.keys.get(k, [])]

        policy = self.prop.policy or neverPolicy()

        key = policy.get_identifier(entity)

        parents, identicals = policy.identify(self.prop, [self.nodes[i] for i in self.keys.get(key, [])], ancestors)

        new_nodes = identicals.copy()

        for p in parents:
            index = len(self.nodes)

            node = Node(self.prop, entity, key, index)
            self.nodes.append(node)
            if key is not None:
                self.keys.setdefault(key, []).append(index)
            new_nodes.append(node)

            if p is not None:
                p.add_child(node)

        if to_replace:
            for n in identicals:
                n.entity = entity

        ancestors[self.prop.name] = new_nodes</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>pyracmon.graph.graph._GraphNodeContainer</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.NodeContainer.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>Returns the container name, which is same as the name of template property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;
    Returns the container name, which is same as the name of template property.
    &#34;&#34;&#34;
    return self.prop.name</code></pre>
</details>
</dd>
<dt id="pyracmon.NodeContainer.prop"><code class="name">var <span class="ident">prop</span></code></dt>
<dd>
<div class="desc"><p>Template property.</p></div>
</dd>
<dt id="pyracmon.NodeContainer.view"><code class="name">var <span class="ident">view</span> : <a title="pyracmon.graph.graph.ContainerView" href="graph/graph.html#pyracmon.graph.graph.ContainerView">ContainerView</a></code></dt>
<dd>
<div class="desc"><p>Returns an unmodifiable view of this container.</p>
<p>The view object works as the accessor to container components.</p>
<ul>
<li>Returns a container instance when invoked as callable object.</li>
<li>The attribute of a child name returns the child container view of the first node in this container.</li>
<li>Index access returns the view of node at the index.</li>
<li>In iteration context, it iterates views of nodes.</li>
<li>The number of nodes is returned by being applied to <code>len</code> .</li>
</ul>
<pre><code class="language-python-repl">&gt;&gt;&gt; template = GraphSpac().new_template(a=int, b=str, c=str)
&gt;&gt;&gt; template.a &lt;&lt; template.b
&gt;&gt;&gt; graph = new_graph(template).append(a=1, b=&quot;a&quot;).append(a=1, b=&quot;b&quot;).append(a=2, b=&quot;c&quot;)
&gt;&gt;&gt; container = graph.containers[&quot;a&quot;]
&gt;&gt;&gt; view = graph.view.a
&gt;&gt;&gt; assert view() is container                             # invocation
&gt;&gt;&gt; assert view.b is container.nodes[0].children[&quot;b&quot;].view # attribute
&gt;&gt;&gt; assert view[1] is container.nodes[1].view              # index
&gt;&gt;&gt; assert [n() for n in view] == [1, 2]                   # iteration
&gt;&gt;&gt; assert len(view) == 2                                  # length
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def view(self) -&gt; ContainerView:
    &#34;&#34;&#34;
    Returns an unmodifiable view of this container.

    The view object works as the accessor to container components.

    - Returns a container instance when invoked as callable object.
    - The attribute of a child name returns the child container view of the first node in this container.
    - Index access returns the view of node at the index.
    - In iteration context, it iterates views of nodes.
    - The number of nodes is returned by being applied to `len` .

    &gt;&gt;&gt; template = GraphSpac().new_template(a=int, b=str, c=str)
    &gt;&gt;&gt; template.a &lt;&lt; template.b
    &gt;&gt;&gt; graph = new_graph(template).append(a=1, b=&#34;a&#34;).append(a=1, b=&#34;b&#34;).append(a=2, b=&#34;c&#34;)
    &gt;&gt;&gt; container = graph.containers[&#34;a&#34;]
    &gt;&gt;&gt; view = graph.view.a
    &gt;&gt;&gt; assert view() is container                             # invocation
    &gt;&gt;&gt; assert view.b is container.nodes[0].children[&#34;b&#34;].view # attribute
    &gt;&gt;&gt; assert view[1] is container.nodes[1].view              # index
    &gt;&gt;&gt; assert [n() for n in view] == [1, 2]                   # iteration
    &gt;&gt;&gt; assert len(view) == 2                                  # length
    &#34;&#34;&#34;
    if self._view is None:
        container = self
        class _ContainerView(ContainerView):
            def __bool__(self):
                &#34;&#34;&#34;Returns whether this container is not empty.&#34;&#34;&#34;
                return len(container.nodes) != 0
            def __call__(self):
                &#34;&#34;&#34;Returns a base container.&#34;&#34;&#34;
                return container
            def __len__(self):
                &#34;&#34;&#34;Returns the number of nodes.&#34;&#34;&#34;
                return len(container.nodes)
            def __iter__(self):
                &#34;&#34;&#34;Iterates views of nodes.&#34;&#34;&#34;
                return map(lambda n: n.view, container.nodes)
            def __getitem__(self, index):
                &#34;&#34;&#34;Returns a view of a node at the index.&#34;&#34;&#34;
                if isinstance(index, slice):
                    return [n.view for n in container.nodes[index]]
                else:
                    return container.nodes[index].view
            def __getattr__(self, key):
                &#34;&#34;&#34;Returns a view of the first node or empty container view if it does not exist.&#34;&#34;&#34;
                child = next(filter(lambda c: c.name == key, container.prop.children), None)
                if child:
                    return container.nodes[0].children[key].view if len(container.nodes) &gt; 0 else _EmptyContainerView(child)
                else:
                    raise KeyError(f&#34;Graph property &#39;{container.prop.name}&#39; does not have a child property &#39;{key}&#39;.&#34;)
        self._view = _ContainerView()
    return self._view</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.NodeContainer.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, entity: Any, ancestors: Dict[str, List[ForwardRef('<a title="pyracmon.Node" href="#pyracmon.Node">Node</a>')]], to_replace: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Add an entity to this container.</p>
<p>Identical node is searched by examining whether this container already contains a node of the identical entity
and its parent is found in <code>anscestors</code> .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>entity</code></strong></dt>
<dd>An entity to be stored in the node.</dd>
<dt><strong><code>ancestors</code></strong></dt>
<dd>Parent nodes mapped by property names.</dd>
<dt><strong><code>to_replace</code></strong></dt>
<dd>If <code>True</code>, the entity of identical node is replaced. Otherwise, it is not changed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append(self, entity: Any, ancestors: Dict[str, List[&#39;Node&#39;]], to_replace: bool = False):
    &#34;&#34;&#34;
    Add an entity to this container.

    Identical node is searched by examining whether this container already contains a node of the identical entity
    and its parent is found in `anscestors` .

    Args:
        entity: An entity to be stored in the node.
        ancestors: Parent nodes mapped by property names.
        to_replace: If `True`, the entity of identical node is replaced. Otherwise, it is not changed.
    &#34;&#34;&#34;
    def get_nodes(k):
        return [self.nodes[i] for i in self.keys.get(k, [])]

    policy = self.prop.policy or neverPolicy()

    key = policy.get_identifier(entity)

    parents, identicals = policy.identify(self.prop, [self.nodes[i] for i in self.keys.get(key, [])], ancestors)

    new_nodes = identicals.copy()

    for p in parents:
        index = len(self.nodes)

        node = Node(self.prop, entity, key, index)
        self.nodes.append(node)
        if key is not None:
            self.keys.setdefault(key, []).append(index)
        new_nodes.append(node)

        if p is not None:
            p.add_child(node)

    if to_replace:
        for n in identicals:
            n.entity = entity

    ancestors[self.prop.name] = new_nodes</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.NodeView"><code class="flex name class">
<span>class <span class="ident">NodeView</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NodeView:
    pass</code></pre>
</details>
</dd>
<dt id="pyracmon.Q"><code class="flex name class">
<span>class <span class="ident">Q</span></span>
<span>(</span><span>**kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>This class provides utility class methods creating conditions.</p>
<p>Using <code>of()</code> is the most simple way to create a condition clause with parameters.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Q.of(&quot;a = $_&quot;, 1)
Condition: 'a = $_' -- [1]
</code></pre>
<p>Other utility methods correspond to basic operators defined in SQL.
They takes keyword arguments and create conditions by applying operator to each item respectively.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Q.eq(a=1)
Condition: 'a = %s' -- [1]
&gt;&gt;&gt; Q.in_(a=[1, 2, 3])
Condition: 'a IN (%s, %s, %s)' -- [1, 2, 3]
&gt;&gt;&gt; Q.like(a=&quot;abc&quot;)
Condition: 'a LIKE %s' -- [&quot;%abc%&quot;]
</code></pre>
<p>Multiple arguments generates a condition which concatenates conditions with logical operator, by default <code>AND</code> .</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Q.eq(a=1, b=2)
Condition: 'a = %s AND b = %s' -- [1, 2]
</code></pre>
<p>Those methods also accept table alias which is prepended to columns.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; Q.eq(&quot;t&quot;, a=1, b=2)
Condition: 't.a = %s AND t.b = %s'
</code></pre>
<p>Additionally, the instance of this class has its own functionality to generate condition.</p>
<p>Each parameter passed to the constructor becomes an instance method of the instance,
which takes a condition clause including placeholders which will take parameters in query execution phase.
<code>Statement.execute</code> allows unified marker <code>$_</code> in spite of DB driver.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; q = Q(a=1)
&gt;&gt;&gt; q.a(&quot;a = $_&quot;)
Condition: 'a = $_' -- [1]
</code></pre>
<p>Method whose name is not passed to the constructor renders empty condition which has no effect on the query.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; q.b(&quot;b = $_&quot;)
Condition: '' -- []
</code></pre>
<p>By default, <code>None</code> is equivalent to not being passed. Giving <code>True</code> at the first argument in constructor changes the behavior.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; q = Q(a=1, b=None)
&gt;&gt;&gt; q.b(&quot;b = $_&quot;)
Condition: '' -- []
&gt;&gt;&gt; q = Q(True, a=1, b=None)
&gt;&gt;&gt; q.b(&quot;b = $_&quot;)
Condition: 'b = $_' -- [None]
</code></pre>
<p>This feature simplifies a query construction in cases some parameters are absent.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def search(db, q):
&gt;&gt;&gt;     w, params = where(q.a(&quot;a = $_&quot;) &amp; q.b(&quot;b = $_&quot;))
&gt;&gt;&gt;     db.stmt().execute(f&quot;SELECT * FROM table {w}&quot;, *params)
&gt;&gt;&gt; 
&gt;&gt;&gt; search(db, Q(a=1))      # SELECT * FROM table WHERE a = 1
&gt;&gt;&gt; search(db, Q(a=1, b=2)) # SELECT * FROM table WHERE a = 1 AND b = 2
&gt;&gt;&gt; search(db, Q())         # SELECT * FROM table
</code></pre>
<p>Initializes an instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_include_none_</code></strong></dt>
<dd>Whether include attributes whose value is <code>None</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Denotes pairs of attribute name and parameter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Q:
    &#34;&#34;&#34;
    This class provides utility class methods creating conditions.

    Using `of()` is the most simple way to create a condition clause with parameters.

    &gt;&gt;&gt; Q.of(&#34;a = $_&#34;, 1)
    Condition: &#39;a = $_&#39; -- [1]

    Other utility methods correspond to basic operators defined in SQL.
    They takes keyword arguments and create conditions by applying operator to each item respectively.

    &gt;&gt;&gt; Q.eq(a=1)
    Condition: &#39;a = %s&#39; -- [1]
    &gt;&gt;&gt; Q.in_(a=[1, 2, 3])
    Condition: &#39;a IN (%s, %s, %s)&#39; -- [1, 2, 3]
    &gt;&gt;&gt; Q.like(a=&#34;abc&#34;)
    Condition: &#39;a LIKE %s&#39; -- [&#34;%abc%&#34;]

    Multiple arguments generates a condition which concatenates conditions with logical operator, by default `AND` .

    &gt;&gt;&gt; Q.eq(a=1, b=2)
    Condition: &#39;a = %s AND b = %s&#39; -- [1, 2]

    Those methods also accept table alias which is prepended to columns.

    &gt;&gt;&gt; Q.eq(&#34;t&#34;, a=1, b=2)
    Condition: &#39;t.a = %s AND t.b = %s&#39;

    Additionally, the instance of this class has its own functionality to generate condition.

    Each parameter passed to the constructor becomes an instance method of the instance,
    which takes a condition clause including placeholders which will take parameters in query execution phase.
    `Statement.execute` allows unified marker `$_` in spite of DB driver.

    &gt;&gt;&gt; q = Q(a=1)
    &gt;&gt;&gt; q.a(&#34;a = $_&#34;)
    Condition: &#39;a = $_&#39; -- [1]

    Method whose name is not passed to the constructor renders empty condition which has no effect on the query.

    &gt;&gt;&gt; q.b(&#34;b = $_&#34;)
    Condition: &#39;&#39; -- []

    By default, `None` is equivalent to not being passed. Giving `True` at the first argument in constructor changes the behavior.

    &gt;&gt;&gt; q = Q(a=1, b=None)
    &gt;&gt;&gt; q.b(&#34;b = $_&#34;)
    Condition: &#39;&#39; -- []
    &gt;&gt;&gt; q = Q(True, a=1, b=None)
    &gt;&gt;&gt; q.b(&#34;b = $_&#34;)
    Condition: &#39;b = $_&#39; -- [None]

    This feature simplifies a query construction in cases some parameters are absent.

    &gt;&gt;&gt; def search(db, q):
    &gt;&gt;&gt;     w, params = where(q.a(&#34;a = $_&#34;) &amp; q.b(&#34;b = $_&#34;))
    &gt;&gt;&gt;     db.stmt().execute(f&#34;SELECT * FROM table {w}&#34;, *params)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; search(db, Q(a=1))      # SELECT * FROM table WHERE a = 1
    &gt;&gt;&gt; search(db, Q(a=1, b=2)) # SELECT * FROM table WHERE a = 1 AND b = 2
    &gt;&gt;&gt; search(db, Q())         # SELECT * FROM table
    &#34;&#34;&#34;
    class Attribute:
        def __init__(self, value):
            self.value = value

        def __call__(self, expression: Union[str, Callable[[Any], str]], convert: Callable[[Any], Any] = None) -&gt; &#39;Conditional&#39;:
            &#34;&#34;&#34;
            Craetes conditional object composed of given clause and the attribute value as parameters.

            Args:
                clause: A clause or a function generating a clause by taking the attribute value.
                convert: A function converting the attribute value to parameters.
                    If this function returns a value which is not a list, a list having only the value is used.
            Returns:
                Condition.
            &#34;&#34;&#34;
            expression = expression if isinstance(expression, str) else expression(self.value)

            if callable(convert):
                params = convert(self.value)
            elif convert is not None:
                params = convert
            else:
                params = [self.value]

            return Conditional(expression, params if isinstance(params, list) else [params])

        @property
        def all(self) -&gt; &#39;Q.Attribute&#39;:
            &#34;&#34;&#34;
            Returns composite attribute which applies conditions to every values iterated from attribute value and join them with `AND`.
            &#34;&#34;&#34;
            return Q.CompositeAttribute(self.value, True)

        @property
        def any(self) -&gt; &#39;Q.Attribute&#39;:
            &#34;&#34;&#34;
            Returns composite attribute which applies conditions to every values iterated from attribute value and join them with `OR`.
            &#34;&#34;&#34;
            return Q.CompositeAttribute(self.value, False)

        def __bool__(self):
            return True

        def __and__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return other if bool(self.value) else Conditional()

        def __or__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return other if not bool(self.value) else Conditional()

        def __getattr__(self, key):
            method = getattr(Q, key)
            def invoke(col, convert=None, *args, **kwargs):
                if callable(convert):
                    value = convert(self.value)
                else:
                    value = convert if convert is not None else self.value
                kwargs.update({col: value})
                return method(*args, **kwargs)
            return invoke

    class CompositeAttribute(Attribute):
        def __init__(self, value, and_):
            super().__init__(value)
            self._and = and_

        def __call__(self, expression, convert=None):
            conds = [Q.Attribute(v)(expression, convert) for v in self.value]
            return Conditional.all(conds) if self._and else Conditional.any(conds)

        def __getattr__(self, key):
            method = getattr(Q, key)
            def invoke(col, convert=None, *args, **kwargs):
                def conv(v):
                    if callable(convert):
                        return convert(v)
                    else:
                        # REVIEW Replacing every parameter in the list with the same value is meaningless?
                        return convert if convert is not None else v
                conds = [method(*args, **dict(chain(kwargs.items(), [(col, conv(v))]))) for v in self.value]
                return Conditional.all(conds) if self._and else Conditional.any(conds)
            return invoke

    class NoAttribute(Attribute):
        def __init__(self):
            super().__init__(None)

        def __call__(self, expression, holder=lambda x:x):
            return Conditional()

        @property
        def all(self):
            return self

        @property
        def any(self):
            return self

        def __bool__(self):
            return False

        def __and__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return Conditional()

        def __or__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return Conditional()

        def __getattr__(self, key):
            method = getattr(Q, key)
            def invoke(col, convert=None, *args):
                return Conditional()
            return invoke

    def __init__(self, _include_none_: bool = False, **kwargs: Any):
        &#34;&#34;&#34;
        Initializes an instance.

        Args:
            _include_none_: Whether include attributes whose value is `None`.
            kwargs: Denotes pairs of attribute name and parameter.
        &#34;&#34;&#34;
        self.attributes = dict([(k, v) for k, v in kwargs.items() if _include_none_ or v is not None])

    def __getattr__(self, key):
        if key in self.attributes:
            return Q.Attribute(self.attributes[key])
        else:
            return Q.NoAttribute()

    @classmethod
    def of(cls, expression: str = &#34;&#34;, *params: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Creates a condition directly from an expression and parameters.

        Args:
            expression: Condition expression.
            params: Parameters used in the condition.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return Conditional(expression, list(params))

    @classmethod
    def eq(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any):
        &#34;&#34;&#34;
        Creates a condition applying `=` operator to columns.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def is_null(col, val):
            if val is None:
                return f&#34;{col} IS NULL&#34;, []
            elif val is True:
                return f&#34;{col}&#34;, []
            elif val is False:
                return f&#34;NOT {col}&#34;, []
            return None
        return _conditional(&#34;=&#34;, _and_, kwargs, is_null, _alias_)

    @classmethod
    def neq(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any):
        &#34;&#34;&#34;
        Works like `eq`, but applies `!=`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def is_null(col, val):
            if val is None:
                return f&#34;{col} IS NOT NULL&#34;, []
            elif val is True:
                return f&#34;NOT {col}&#34;, []
            elif val is False:
                return f&#34;{col}&#34;, []
            return None
        return _conditional(&#34;!=&#34;, _and_, kwargs, is_null, _alias_)

    @classmethod
    def in_(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: List[Any]):
        &#34;&#34;&#34;
        Works like `eq`, but applies `IN`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def in_list(col, val):
            if len(val) == 0:
                return &#34;1 = 0&#34;, []
            else:
                holder = &#39;, &#39;.join([&#39;$_&#39;] * len(val))
                return f&#34;{col} IN ({holder})&#34;, val
        return _conditional(&#34;IN&#34;, _and_, kwargs, in_list, _alias_)

    @classmethod
    def not_in(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: List[Any]):
        &#34;&#34;&#34;
        Works like `eq`, but applies `NOT IN`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def in_list(col, val):
            if len(val) == 0:
                return &#34;&#34;, []
            else:
                holder = &#39;, &#39;.join([&#39;$_&#39;] * len(val))
                return f&#34;{col} NOT IN ({holder})&#34;, val
        return _conditional(&#34;NOT IN&#34;, _and_, kwargs, in_list, _alias_)

    @classmethod
    def match(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str):
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be passed to query without being modified.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def like(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str):
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be escaped and enclosed with wildcards (%) to execute partial match.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;%{escape_like(v)}%&#34; for k, v in kwargs.items()}, None, _alias_)

    @classmethod
    def startswith(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str):
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be escaped and appended with wildcards (%) to execute prefix match.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;{escape_like(v)}%&#34; for k, v in kwargs.items()}, None, _alias_)

    @classmethod
    def endswith(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str):
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be escaped and prepended with wildcards (%) to execute backward match.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;%{escape_like(v)}&#34; for k, v in kwargs.items()}, None, _alias_)

    @classmethod
    def lt(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any):
        &#34;&#34;&#34;
        Works like `eq`, but applies `&lt;`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&lt;&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def le(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any):
        &#34;&#34;&#34;
        Works like `eq`, but applies `&lt;=`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&lt;=&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def gt(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any):
        &#34;&#34;&#34;
        Works like `eq`, but applies `&gt;`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&gt;&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def ge(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any):
        &#34;&#34;&#34;
        Works like `eq`, but applies `&gt;=`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&gt;=&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyracmon.Q.Attribute"><code class="name">var <span class="ident">Attribute</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyracmon.Q.CompositeAttribute"><code class="name">var <span class="ident">CompositeAttribute</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pyracmon.Q.NoAttribute"><code class="name">var <span class="ident">NoAttribute</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.Q.endswith"><code class="name flex">
<span>def <span class="ident">endswith</span></span>(<span>**kwargs: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>LIKE</code>. Given parameters will be escaped and prepended with wildcards (%) to execute backward match.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def endswith(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str):
    &#34;&#34;&#34;
    Works like `eq`, but applies `LIKE`. Given parameters will be escaped and prepended with wildcards (%) to execute backward match.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;%{escape_like(v)}&#34; for k, v in kwargs.items()}, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.eq"><code class="name flex">
<span>def <span class="ident">eq</span></span>(<span>**kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a condition applying <code>=</code> operator to columns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def eq(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any):
    &#34;&#34;&#34;
    Creates a condition applying `=` operator to columns.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    def is_null(col, val):
        if val is None:
            return f&#34;{col} IS NULL&#34;, []
        elif val is True:
            return f&#34;{col}&#34;, []
        elif val is False:
            return f&#34;NOT {col}&#34;, []
        return None
    return _conditional(&#34;=&#34;, _and_, kwargs, is_null, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.ge"><code class="name flex">
<span>def <span class="ident">ge</span></span>(<span>**kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>&gt;=</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def ge(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any):
    &#34;&#34;&#34;
    Works like `eq`, but applies `&gt;=`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;&gt;=&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.gt"><code class="name flex">
<span>def <span class="ident">gt</span></span>(<span>**kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>&gt;</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def gt(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any):
    &#34;&#34;&#34;
    Works like `eq`, but applies `&gt;`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;&gt;&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.in_"><code class="name flex">
<span>def <span class="ident">in_</span></span>(<span>**kwargs: List[Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>IN</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def in_(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: List[Any]):
    &#34;&#34;&#34;
    Works like `eq`, but applies `IN`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    def in_list(col, val):
        if len(val) == 0:
            return &#34;1 = 0&#34;, []
        else:
            holder = &#39;, &#39;.join([&#39;$_&#39;] * len(val))
            return f&#34;{col} IN ({holder})&#34;, val
    return _conditional(&#34;IN&#34;, _and_, kwargs, in_list, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.le"><code class="name flex">
<span>def <span class="ident">le</span></span>(<span>**kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>&lt;=</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def le(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any):
    &#34;&#34;&#34;
    Works like `eq`, but applies `&lt;=`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;&lt;=&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.like"><code class="name flex">
<span>def <span class="ident">like</span></span>(<span>**kwargs: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>LIKE</code>. Given parameters will be escaped and enclosed with wildcards (%) to execute partial match.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def like(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str):
    &#34;&#34;&#34;
    Works like `eq`, but applies `LIKE`. Given parameters will be escaped and enclosed with wildcards (%) to execute partial match.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;%{escape_like(v)}%&#34; for k, v in kwargs.items()}, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.lt"><code class="name flex">
<span>def <span class="ident">lt</span></span>(<span>**kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>&lt;</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def lt(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any):
    &#34;&#34;&#34;
    Works like `eq`, but applies `&lt;`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;&lt;&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>**kwargs: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>LIKE</code>. Given parameters will be passed to query without being modified.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def match(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str):
    &#34;&#34;&#34;
    Works like `eq`, but applies `LIKE`. Given parameters will be passed to query without being modified.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;LIKE&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.neq"><code class="name flex">
<span>def <span class="ident">neq</span></span>(<span>**kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>!=</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def neq(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any):
    &#34;&#34;&#34;
    Works like `eq`, but applies `!=`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    def is_null(col, val):
        if val is None:
            return f&#34;{col} IS NOT NULL&#34;, []
        elif val is True:
            return f&#34;NOT {col}&#34;, []
        elif val is False:
            return f&#34;{col}&#34;, []
        return None
    return _conditional(&#34;!=&#34;, _and_, kwargs, is_null, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.not_in"><code class="name flex">
<span>def <span class="ident">not_in</span></span>(<span>**kwargs: List[Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>NOT IN</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def not_in(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: List[Any]):
    &#34;&#34;&#34;
    Works like `eq`, but applies `NOT IN`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    def in_list(col, val):
        if len(val) == 0:
            return &#34;&#34;, []
        else:
            holder = &#39;, &#39;.join([&#39;$_&#39;] * len(val))
            return f&#34;{col} NOT IN ({holder})&#34;, val
    return _conditional(&#34;NOT IN&#34;, _and_, kwargs, in_list, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>expression: str = '', *params: Any) ‑> <a title="pyracmon.query.Conditional" href="query.html#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a condition directly from an expression and parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>expression</code></strong></dt>
<dd>Condition expression.</dd>
<dt><strong><code>params</code></strong></dt>
<dd>Parameters used in the condition.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def of(cls, expression: str = &#34;&#34;, *params: Any) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Creates a condition directly from an expression and parameters.

    Args:
        expression: Condition expression.
        params: Parameters used in the condition.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return Conditional(expression, list(params))</code></pre>
</details>
</dd>
<dt id="pyracmon.Q.startswith"><code class="name flex">
<span>def <span class="ident">startswith</span></span>(<span>**kwargs: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>LIKE</code>. Given parameters will be escaped and appended with wildcards (%) to execute prefix match.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def startswith(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str):
    &#34;&#34;&#34;
    Works like `eq`, but applies `LIKE`. Given parameters will be escaped and appended with wildcards (%) to execute prefix match.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;{escape_like(v)}%&#34; for k, v in kwargs.items()}, None, _alias_)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.S"><code class="flex name class">
<span>class <span class="ident">S</span></span>
</code></dt>
<dd>
<div class="desc"><p>An utility class to build <code>NodeSerializer</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class S:
    &#34;&#34;&#34;
    An utility class to build `NodeSerializer`.
    &#34;&#34;&#34;
    @classmethod
    def of(
        cls,
        namer: Optional[Union[str, Callable[[str], str]]] = None,
        aggregator: Optional[Union[Callable[[Node], Node], Callable[[Node], List[Node]], int]] = None,
        *serializers: Serializer,
    ) -&gt; &#39;NodeSerializer&#39;:
        &#34;&#34;&#34;
        Create an instance of `NodeSerializer`.

        :param namer: A string or naming function.
        :param aggregator: An aggregation function or an index of node to select in node container.
        :param serializer: A list of *serializer* s.
        :returns: Created `NodeSerializer` .
        &#34;&#34;&#34;
        return NodeSerializer(namer, aggregator, *serializers)

    @classmethod
    def builder(cls, builder: Callable[[Any], Any]):
        &#34;&#34;&#34;
        This method is used as decorator to put decorating target to `S` builder methods.

        &gt;&gt;&gt; @S.builder
        &gt;&gt;&gt; def some_func():
        &gt;&gt;&gt;     ...
        &gt;&gt;&gt; S.some_func()

        :param builder: Decorating target.
        :returns: Decorated builder.
        &#34;&#34;&#34;
        def f(*args, **kwargs):
            return builder(S.of(), *args, **kwargs)
        setattr(S, builder.__name__, f)
        return builder</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.S.builder"><code class="name flex">
<span>def <span class="ident">builder</span></span>(<span>builder: Callable[[Any], Any])</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used as decorator to put decorating target to <code><a title="pyracmon.S" href="#pyracmon.S">S</a></code> builder methods.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; @S.builder
&gt;&gt;&gt; def some_func():
&gt;&gt;&gt;     ...
&gt;&gt;&gt; S.some_func()
</code></pre>
<p>:param builder: Decorating target.
:returns: Decorated builder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def builder(cls, builder: Callable[[Any], Any]):
    &#34;&#34;&#34;
    This method is used as decorator to put decorating target to `S` builder methods.

    &gt;&gt;&gt; @S.builder
    &gt;&gt;&gt; def some_func():
    &gt;&gt;&gt;     ...
    &gt;&gt;&gt; S.some_func()

    :param builder: Decorating target.
    :returns: Decorated builder.
    &#34;&#34;&#34;
    def f(*args, **kwargs):
        return builder(S.of(), *args, **kwargs)
    setattr(S, builder.__name__, f)
    return builder</code></pre>
</details>
</dd>
<dt id="pyracmon.S.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>namer: Union[str, Callable[[str], str], None] = None, aggregator: Union[Callable[[<a title="pyracmon.graph.graph.Node" href="graph/graph.html#pyracmon.graph.graph.Node">Node</a>], <a title="pyracmon.graph.graph.Node" href="graph/graph.html#pyracmon.graph.graph.Node">Node</a>], Callable[[<a title="pyracmon.graph.graph.Node" href="graph/graph.html#pyracmon.graph.graph.Node">Node</a>], List[<a title="pyracmon.graph.graph.Node" href="graph/graph.html#pyracmon.graph.graph.Node">Node</a>]], int, None] = None, *serializers: Callable[[ForwardRef('NodeContext')], Any]) ‑> <a title="pyracmon.graph.serialize.NodeSerializer" href="graph/serialize.html#pyracmon.graph.serialize.NodeSerializer">NodeSerializer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create an instance of <code>NodeSerializer</code>.</p>
<p>:param namer: A string or naming function.
:param aggregator: An aggregation function or an index of node to select in node container.
:param serializer: A list of <em>serializer</em> s.
:returns: Created <code>NodeSerializer</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def of(
    cls,
    namer: Optional[Union[str, Callable[[str], str]]] = None,
    aggregator: Optional[Union[Callable[[Node], Node], Callable[[Node], List[Node]], int]] = None,
    *serializers: Serializer,
) -&gt; &#39;NodeSerializer&#39;:
    &#34;&#34;&#34;
    Create an instance of `NodeSerializer`.

    :param namer: A string or naming function.
    :param aggregator: An aggregation function or an index of node to select in node container.
    :param serializer: A list of *serializer* s.
    :returns: Created `NodeSerializer` .
    &#34;&#34;&#34;
    return NodeSerializer(namer, aggregator, *serializers)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.S.alter"><code class="name flex">
<span>def <span class="ident">alter</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.at"><code class="name flex">
<span>def <span class="ident">at</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.doc"><code class="name flex">
<span>def <span class="ident">doc</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.each"><code class="name flex">
<span>def <span class="ident">each</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.fold"><code class="name flex">
<span>def <span class="ident">fold</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.head"><code class="name flex">
<span>def <span class="ident">head</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.last"><code class="name flex">
<span>def <span class="ident">last</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.merge"><code class="name flex">
<span>def <span class="ident">merge</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.name"><code class="name flex">
<span>def <span class="ident">name</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
<dt id="pyracmon.S.sub"><code class="name flex">
<span>def <span class="ident">sub</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f(*args, **kwargs):
    return builder(S.of(), *args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.Table"><code class="flex name class">
<span>class <span class="ident">Table</span></span>
<span>(</span><span>name: str, columns: List[<a title="pyracmon.model.Column" href="model.html#pyracmon.model.Column">Column</a>], comment: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents a schema of a table.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Table:
    &#34;&#34;&#34;
    This class represents a schema of a table.
    &#34;&#34;&#34;
    def __init__(self, name: str, columns: List[Column], comment: str = &#34;&#34;):
        #: Table name.
        self.name = name
        #: Columns in the table.
        self.columns = columns
        #: Comment of the table.
        self.comment = comment

    def find(self, name: str) -&gt; Optional[Column]:
        &#34;&#34;&#34;
        Find a column by name.

        Args:
            name: Column name.
        Returns:
            The column if exists, otherwise `None`.
        &#34;&#34;&#34;
        return next(filter(lambda c: c.name == name, self.columns), None)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.Table.columns"><code class="name">var <span class="ident">columns</span></code></dt>
<dd>
<div class="desc"><p>Columns in the table.</p></div>
</dd>
<dt id="pyracmon.Table.comment"><code class="name">var <span class="ident">comment</span></code></dt>
<dd>
<div class="desc"><p>Comment of the table.</p></div>
</dd>
<dt id="pyracmon.Table.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Table name.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pyracmon.Table.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, name: str) ‑> Optional[<a title="pyracmon.model.Column" href="model.html#pyracmon.model.Column">Column</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Find a column by name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Column name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The column if exists, otherwise <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, name: str) -&gt; Optional[Column]:
    &#34;&#34;&#34;
    Find a column by name.

    Args:
        name: Column name.
    Returns:
        The column if exists, otherwise `None`.
    &#34;&#34;&#34;
    return next(filter(lambda c: c.name == name, self.columns), None)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.Typeable"><code class="flex name class">
<span>class <span class="ident">Typeable</span></span>
<span>(</span><span>*args, **kwds)</span>
</code></dt>
<dd>
<div class="desc"><p>An interface for generic type which is resolved into a concrete type by a type parameter.</p>
<p>Inherit this class and declare static method whose signature is <code>resolve(me, bound, arg, spec) -&gt; type</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; class A(Typeable[T]):
&gt;&gt;&gt;     @staticmethod
&gt;&gt;&gt;     def resolve(me, bound, arg, spec):
&gt;&gt;&gt;         ...
&gt;&gt;&gt;         return some_type
&gt;&gt;&gt;
&gt;&gt;&gt; Typeable.resolve(A[T], int, spec)
</code></pre>
<p>Type resolution starts from <code><a title="pyracmon.Typeable.resolve" href="#pyracmon.Typeable.resolve">Typeable.resolve()</a></code> which invokes the static method with following arguments.</p>
<ul>
<li>Type to resolve itself, in this case, <code>A[T]</code>.</li>
<li>A resolved type which replace <code>T</code>.<ul>
<li><code>arg</code> is the first candidate.</li>
<li>When <code>arg</code> is also <code><a title="pyracmon.Typeable" href="#pyracmon.Typeable">Typeable</a></code> , this resolution flow is applied to it recursively until concrete type if determined.</li>
</ul>
</li>
<li><code>arg</code> is passed through as it is.</li>
<li><code>spec</code> is passed through as it is.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Typeable(Generic[T]):
    &#34;&#34;&#34;
    An interface for generic type which is resolved into a concrete type by a type parameter.

    Inherit this class and declare static method whose signature is `resolve(me, bound, arg, spec) -&gt; type`.

    &gt;&gt;&gt; class A(Typeable[T]):
    &gt;&gt;&gt;     @staticmethod
    &gt;&gt;&gt;     def resolve(me, bound, arg, spec):
    &gt;&gt;&gt;         ...
    &gt;&gt;&gt;         return some_type
    &gt;&gt;&gt;
    &gt;&gt;&gt; Typeable.resolve(A[T], int, spec)

    Type resolution starts from `Typeable.resolve` which invokes the static method with following arguments.

    - Type to resolve itself, in this case, `A[T]`.
    - A resolved type which replace `T`.
        - `arg` is the first candidate.
        - When `arg` is also `Typeable` , this resolution flow is applied to it recursively until concrete type if determined.
    - `arg` is passed through as it is.
    - `spec` is passed through as it is.
    &#34;&#34;&#34;
    @staticmethod
    def resolve(typeable, arg: type, spec: &#39;GraphSpec&#39;) -&gt; type:
        &#34;&#34;&#34;
        Resolve a `Typeable` type into a concrete type by a type for its type parameter.

        Args:
            typeable: `Typeable` type having a generic type parameter.
            arg: Type to replace a type parameter.
            spec: `GraphSpec` used for schema generation.
        Returns:
            Resolved type.
        &#34;&#34;&#34;
        if get_origin(typeable) is Typeable:
            raise ValueError(f&#34;Typeable should not be used directly. Use inheriting class instead.&#34;)

        bound = get_args(typeable)[0]

        if isinstance(bound, TypeVar):
            return Typeable.resolve(typeable[arg], arg, spec)
        elif issubgeneric(bound, Typeable):
            bound = Typeable.resolve(bound, arg, spec)
            return typeable.resolve(typeable, bound, arg, spec)
        else:
            return typeable.resolve(typeable, bound, arg, spec)

    @staticmethod
    def is_resolved(typeable: Type[&#39;Typeable&#39;]) -&gt; bool:
        &#34;&#34;&#34;
        Checks a type parameter of given `Typeable` is alredy resolved.

        Args:
            typeable: `Typeable` type having a generic type parameter.
        Returns:
            Whether the type parameter is already resolved or not.
        &#34;&#34;&#34;
        bound = get_args(typeable)[0]
        if isinstance(bound, TypeVar):
            return False
        elif issubgeneric(bound, Typeable):
            return Typeable.is_resolved(bound)
        else:
            return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.graph.schema.DynamicType" href="graph/schema.html#pyracmon.graph.schema.DynamicType">DynamicType</a></li>
<li><a title="pyracmon.graph.schema.Extend" href="graph/schema.html#pyracmon.graph.schema.Extend">Extend</a></li>
<li><a title="pyracmon.graph.schema.Shrink" href="graph/schema.html#pyracmon.graph.schema.Shrink">Shrink</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.Typeable.is_resolved"><code class="name flex">
<span>def <span class="ident">is_resolved</span></span>(<span>typeable: Type[ForwardRef('<a title="pyracmon.Typeable" href="#pyracmon.Typeable">Typeable</a>')]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks a type parameter of given <code><a title="pyracmon.Typeable" href="#pyracmon.Typeable">Typeable</a></code> is alredy resolved.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>typeable</code></strong></dt>
<dd><code><a title="pyracmon.Typeable" href="#pyracmon.Typeable">Typeable</a></code> type having a generic type parameter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Whether the type parameter is already resolved or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def is_resolved(typeable: Type[&#39;Typeable&#39;]) -&gt; bool:
    &#34;&#34;&#34;
    Checks a type parameter of given `Typeable` is alredy resolved.

    Args:
        typeable: `Typeable` type having a generic type parameter.
    Returns:
        Whether the type parameter is already resolved or not.
    &#34;&#34;&#34;
    bound = get_args(typeable)[0]
    if isinstance(bound, TypeVar):
        return False
    elif issubgeneric(bound, Typeable):
        return Typeable.is_resolved(bound)
    else:
        return True</code></pre>
</details>
</dd>
<dt id="pyracmon.Typeable.resolve"><code class="name flex">
<span>def <span class="ident">resolve</span></span>(<span>typeable, arg: type, spec: GraphSpec) ‑> type</span>
</code></dt>
<dd>
<div class="desc"><p>Resolve a <code><a title="pyracmon.Typeable" href="#pyracmon.Typeable">Typeable</a></code> type into a concrete type by a type for its type parameter.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>typeable</code></strong></dt>
<dd><code><a title="pyracmon.Typeable" href="#pyracmon.Typeable">Typeable</a></code> type having a generic type parameter.</dd>
<dt><strong><code>arg</code></strong></dt>
<dd>Type to replace a type parameter.</dd>
<dt><strong><code>spec</code></strong></dt>
<dd><code>GraphSpec</code> used for schema generation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Resolved type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def resolve(typeable, arg: type, spec: &#39;GraphSpec&#39;) -&gt; type:
    &#34;&#34;&#34;
    Resolve a `Typeable` type into a concrete type by a type for its type parameter.

    Args:
        typeable: `Typeable` type having a generic type parameter.
        arg: Type to replace a type parameter.
        spec: `GraphSpec` used for schema generation.
    Returns:
        Resolved type.
    &#34;&#34;&#34;
    if get_origin(typeable) is Typeable:
        raise ValueError(f&#34;Typeable should not be used directly. Use inheriting class instead.&#34;)

    bound = get_args(typeable)[0]

    if isinstance(bound, TypeVar):
        return Typeable.resolve(typeable[arg], arg, spec)
    elif issubgeneric(bound, Typeable):
        bound = Typeable.resolve(bound, arg, spec)
        return typeable.resolve(typeable, bound, arg, spec)
    else:
        return typeable.resolve(typeable, bound, arg, spec)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.TypedDict"><code class="flex name class">
<span>class <span class="ident">TypedDict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A simple typed name space. At runtime it is equivalent to a plain dict.</p>
<p>TypedDict creates a dictionary type that expects all of its
instances to have a certain set of keys, with each key
associated with a value of a consistent type. This expectation
is not checked at runtime but is only enforced by type checkers.
Usage::</p>
<pre><code>class Point2D(TypedDict):
    x: int
    y: int
    label: str

a: Point2D = {'x': 1, 'y': 2, 'label': 'good'}  # OK
b: Point2D = {'z': 3, 'label': 'bad'}           # Fails type check

assert Point2D(x=1, y=2, label='first') == dict(x=1, y=2, label='first')
</code></pre>
<p>The type info can be accessed via the Point2D.<strong>annotations</strong> dict, and
the Point2D.<strong>required_keys</strong> and Point2D.<strong>optional_keys</strong> frozensets.
TypedDict supports two additional equivalent forms::</p>
<pre><code>Point2D = TypedDict('Point2D', x=int, y=int, label=str)
Point2D = TypedDict('Point2D', {'x': int, 'y': int, 'label': str})
</code></pre>
<p>The class syntax is only supported in Python 3.6+, while two other
syntax forms work for Python 2.7 and 3.2+</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="pyracmon.config" href="config.html">pyracmon.config</a></code></li>
<li><code><a title="pyracmon.connection" href="connection.html">pyracmon.connection</a></code></li>
<li><code><a title="pyracmon.context" href="context.html">pyracmon.context</a></code></li>
<li><code><a title="pyracmon.dialect" href="dialect/index.html">pyracmon.dialect</a></code></li>
<li><code><a title="pyracmon.graph" href="graph/index.html">pyracmon.graph</a></code></li>
<li><code><a title="pyracmon.marker" href="marker.html">pyracmon.marker</a></code></li>
<li><code><a title="pyracmon.mixin" href="mixin.html">pyracmon.mixin</a></code></li>
<li><code><a title="pyracmon.model" href="model.html">pyracmon.model</a></code></li>
<li><code><a title="pyracmon.model_graph" href="model_graph.html">pyracmon.model_graph</a></code></li>
<li><code><a title="pyracmon.query" href="query.html">pyracmon.query</a></code></li>
<li><code><a title="pyracmon.select" href="select.html">pyracmon.select</a></code></li>
<li><code><a title="pyracmon.sql" href="sql.html">pyracmon.sql</a></code></li>
<li><code><a title="pyracmon.testing" href="testing/index.html">pyracmon.testing</a></code></li>
<li><code><a title="pyracmon.util" href="util.html">pyracmon.util</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="pyracmon.connect" href="#pyracmon.connect">connect</a></code></li>
<li><code><a title="pyracmon.declare_models" href="#pyracmon.declare_models">declare_models</a></code></li>
<li><code><a title="pyracmon.define_model" href="#pyracmon.define_model">define_model</a></code></li>
<li><code><a title="pyracmon.document_type" href="#pyracmon.document_type">document_type</a></code></li>
<li><code><a title="pyracmon.escape_like" href="#pyracmon.escape_like">escape_like</a></code></li>
<li><code><a title="pyracmon.graph_dict" href="#pyracmon.graph_dict">graph_dict</a></code></li>
<li><code><a title="pyracmon.graph_schema" href="#pyracmon.graph_schema">graph_schema</a></code></li>
<li><code><a title="pyracmon.graph_template" href="#pyracmon.graph_template">graph_template</a></code></li>
<li><code><a title="pyracmon.new_graph" href="#pyracmon.new_graph">new_graph</a></code></li>
<li><code><a title="pyracmon.order_by" href="#pyracmon.order_by">order_by</a></code></li>
<li><code><a title="pyracmon.pyracmon" href="#pyracmon.pyracmon">pyracmon</a></code></li>
<li><code><a title="pyracmon.ranged_by" href="#pyracmon.ranged_by">ranged_by</a></code></li>
<li><code><a title="pyracmon.read_row" href="#pyracmon.read_row">read_row</a></code></li>
<li><code><a title="pyracmon.walk_schema" href="#pyracmon.walk_schema">walk_schema</a></code></li>
<li><code><a title="pyracmon.where" href="#pyracmon.where">where</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyracmon.CRUDMixin" href="#pyracmon.CRUDMixin">CRUDMixin</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.CRUDMixin.count" href="#pyracmon.CRUDMixin.count">count</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.delete" href="#pyracmon.CRUDMixin.delete">delete</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.delete_where" href="#pyracmon.CRUDMixin.delete_where">delete_where</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.fetch" href="#pyracmon.CRUDMixin.fetch">fetch</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.fetch_one" href="#pyracmon.CRUDMixin.fetch_one">fetch_one</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.fetch_where" href="#pyracmon.CRUDMixin.fetch_where">fetch_where</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.insert" href="#pyracmon.CRUDMixin.insert">insert</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.last_sequences" href="#pyracmon.CRUDMixin.last_sequences">last_sequences</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.update" href="#pyracmon.CRUDMixin.update">update</a></code></li>
<li><code><a title="pyracmon.CRUDMixin.update_where" href="#pyracmon.CRUDMixin.update_where">update_where</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.Column" href="#pyracmon.Column">Column</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.Column.comment" href="#pyracmon.Column.comment">comment</a></code></li>
<li><code><a title="pyracmon.Column.fk" href="#pyracmon.Column.fk">fk</a></code></li>
<li><code><a title="pyracmon.Column.incremental" href="#pyracmon.Column.incremental">incremental</a></code></li>
<li><code><a title="pyracmon.Column.name" href="#pyracmon.Column.name">name</a></code></li>
<li><code><a title="pyracmon.Column.nullable" href="#pyracmon.Column.nullable">nullable</a></code></li>
<li><code><a title="pyracmon.Column.pk" href="#pyracmon.Column.pk">pk</a></code></li>
<li><code><a title="pyracmon.Column.ptype" href="#pyracmon.Column.ptype">ptype</a></code></li>
<li><code><a title="pyracmon.Column.type_info" href="#pyracmon.Column.type_info">type_info</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.Conditional" href="#pyracmon.Conditional">Conditional</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.Conditional.all" href="#pyracmon.Conditional.all">all</a></code></li>
<li><code><a title="pyracmon.Conditional.any" href="#pyracmon.Conditional.any">any</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.Connection" href="#pyracmon.Connection">Connection</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.Connection.context" href="#pyracmon.Connection.context">context</a></code></li>
<li><code><a title="pyracmon.Connection.helper" href="#pyracmon.Connection.helper">helper</a></code></li>
<li><code><a title="pyracmon.Connection.identifier" href="#pyracmon.Connection.identifier">identifier</a></code></li>
<li><code><a title="pyracmon.Connection.stmt" href="#pyracmon.Connection.stmt">stmt</a></code></li>
<li><code><a title="pyracmon.Connection.use" href="#pyracmon.Connection.use">use</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.ConnectionContext" href="#pyracmon.ConnectionContext">ConnectionContext</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.ConnectionContext.configure" href="#pyracmon.ConnectionContext.configure">configure</a></code></li>
<li><code><a title="pyracmon.ConnectionContext.execute" href="#pyracmon.ConnectionContext.execute">execute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.ContainerView" href="#pyracmon.ContainerView">ContainerView</a></code></h4>
</li>
<li>
<h4><code><a title="pyracmon.Expression" href="#pyracmon.Expression">Expression</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.Expression.expression" href="#pyracmon.Expression.expression">expression</a></code></li>
<li><code><a title="pyracmon.Expression.params" href="#pyracmon.Expression.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.Graph" href="#pyracmon.Graph">Graph</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.Graph.append" href="#pyracmon.Graph.append">append</a></code></li>
<li><code><a title="pyracmon.Graph.containers" href="#pyracmon.Graph.containers">containers</a></code></li>
<li><code><a title="pyracmon.Graph.replace" href="#pyracmon.Graph.replace">replace</a></code></li>
<li><code><a title="pyracmon.Graph.template" href="#pyracmon.Graph.template">template</a></code></li>
<li><code><a title="pyracmon.Graph.view" href="#pyracmon.Graph.view">view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.GraphSchema" href="#pyracmon.GraphSchema">GraphSchema</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.GraphSchema.schema" href="#pyracmon.GraphSchema.schema">schema</a></code></li>
<li><code><a title="pyracmon.GraphSchema.schema_of" href="#pyracmon.GraphSchema.schema_of">schema_of</a></code></li>
<li><code><a title="pyracmon.GraphSchema.serialize" href="#pyracmon.GraphSchema.serialize">serialize</a></code></li>
<li><code><a title="pyracmon.GraphSchema.serializers" href="#pyracmon.GraphSchema.serializers">serializers</a></code></li>
<li><code><a title="pyracmon.GraphSchema.spec" href="#pyracmon.GraphSchema.spec">spec</a></code></li>
<li><code><a title="pyracmon.GraphSchema.template" href="#pyracmon.GraphSchema.template">template</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.GraphView" href="#pyracmon.GraphView">GraphView</a></code></h4>
</li>
<li>
<h4><code><a title="pyracmon.Model" href="#pyracmon.Model">Model</a></code></h4>
</li>
<li>
<h4><code><a title="pyracmon.Node" href="#pyracmon.Node">Node</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.Node.Children" href="#pyracmon.Node.Children">Children</a></code></li>
<li><code><a title="pyracmon.Node.add_child" href="#pyracmon.Node.add_child">add_child</a></code></li>
<li><code><a title="pyracmon.Node.entity" href="#pyracmon.Node.entity">entity</a></code></li>
<li><code><a title="pyracmon.Node.has_child" href="#pyracmon.Node.has_child">has_child</a></code></li>
<li><code><a title="pyracmon.Node.name" href="#pyracmon.Node.name">name</a></code></li>
<li><code><a title="pyracmon.Node.prop" href="#pyracmon.Node.prop">prop</a></code></li>
<li><code><a title="pyracmon.Node.view" href="#pyracmon.Node.view">view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.NodeChildrenView" href="#pyracmon.NodeChildrenView">NodeChildrenView</a></code></h4>
</li>
<li>
<h4><code><a title="pyracmon.NodeContainer" href="#pyracmon.NodeContainer">NodeContainer</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.NodeContainer.append" href="#pyracmon.NodeContainer.append">append</a></code></li>
<li><code><a title="pyracmon.NodeContainer.name" href="#pyracmon.NodeContainer.name">name</a></code></li>
<li><code><a title="pyracmon.NodeContainer.prop" href="#pyracmon.NodeContainer.prop">prop</a></code></li>
<li><code><a title="pyracmon.NodeContainer.view" href="#pyracmon.NodeContainer.view">view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.NodeView" href="#pyracmon.NodeView">NodeView</a></code></h4>
</li>
<li>
<h4><code><a title="pyracmon.Q" href="#pyracmon.Q">Q</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.Q.Attribute" href="#pyracmon.Q.Attribute">Attribute</a></code></li>
<li><code><a title="pyracmon.Q.CompositeAttribute" href="#pyracmon.Q.CompositeAttribute">CompositeAttribute</a></code></li>
<li><code><a title="pyracmon.Q.NoAttribute" href="#pyracmon.Q.NoAttribute">NoAttribute</a></code></li>
<li><code><a title="pyracmon.Q.endswith" href="#pyracmon.Q.endswith">endswith</a></code></li>
<li><code><a title="pyracmon.Q.eq" href="#pyracmon.Q.eq">eq</a></code></li>
<li><code><a title="pyracmon.Q.ge" href="#pyracmon.Q.ge">ge</a></code></li>
<li><code><a title="pyracmon.Q.gt" href="#pyracmon.Q.gt">gt</a></code></li>
<li><code><a title="pyracmon.Q.in_" href="#pyracmon.Q.in_">in_</a></code></li>
<li><code><a title="pyracmon.Q.le" href="#pyracmon.Q.le">le</a></code></li>
<li><code><a title="pyracmon.Q.like" href="#pyracmon.Q.like">like</a></code></li>
<li><code><a title="pyracmon.Q.lt" href="#pyracmon.Q.lt">lt</a></code></li>
<li><code><a title="pyracmon.Q.match" href="#pyracmon.Q.match">match</a></code></li>
<li><code><a title="pyracmon.Q.neq" href="#pyracmon.Q.neq">neq</a></code></li>
<li><code><a title="pyracmon.Q.not_in" href="#pyracmon.Q.not_in">not_in</a></code></li>
<li><code><a title="pyracmon.Q.of" href="#pyracmon.Q.of">of</a></code></li>
<li><code><a title="pyracmon.Q.startswith" href="#pyracmon.Q.startswith">startswith</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.S" href="#pyracmon.S">S</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.S.alter" href="#pyracmon.S.alter">alter</a></code></li>
<li><code><a title="pyracmon.S.at" href="#pyracmon.S.at">at</a></code></li>
<li><code><a title="pyracmon.S.builder" href="#pyracmon.S.builder">builder</a></code></li>
<li><code><a title="pyracmon.S.doc" href="#pyracmon.S.doc">doc</a></code></li>
<li><code><a title="pyracmon.S.each" href="#pyracmon.S.each">each</a></code></li>
<li><code><a title="pyracmon.S.fold" href="#pyracmon.S.fold">fold</a></code></li>
<li><code><a title="pyracmon.S.head" href="#pyracmon.S.head">head</a></code></li>
<li><code><a title="pyracmon.S.last" href="#pyracmon.S.last">last</a></code></li>
<li><code><a title="pyracmon.S.merge" href="#pyracmon.S.merge">merge</a></code></li>
<li><code><a title="pyracmon.S.name" href="#pyracmon.S.name">name</a></code></li>
<li><code><a title="pyracmon.S.of" href="#pyracmon.S.of">of</a></code></li>
<li><code><a title="pyracmon.S.select" href="#pyracmon.S.select">select</a></code></li>
<li><code><a title="pyracmon.S.sub" href="#pyracmon.S.sub">sub</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.Table" href="#pyracmon.Table">Table</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.Table.columns" href="#pyracmon.Table.columns">columns</a></code></li>
<li><code><a title="pyracmon.Table.comment" href="#pyracmon.Table.comment">comment</a></code></li>
<li><code><a title="pyracmon.Table.find" href="#pyracmon.Table.find">find</a></code></li>
<li><code><a title="pyracmon.Table.name" href="#pyracmon.Table.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.Typeable" href="#pyracmon.Typeable">Typeable</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.Typeable.is_resolved" href="#pyracmon.Typeable.is_resolved">is_resolved</a></code></li>
<li><code><a title="pyracmon.Typeable.resolve" href="#pyracmon.Typeable.resolve">resolve</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.TypedDict" href="#pyracmon.TypedDict">TypedDict</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>