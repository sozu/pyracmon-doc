<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyracmon.query API documentation</title>
<meta name="description" content="This module exports types and functions for query construction â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyracmon.query</code></h1>
</header>
<section id="section-intro">
<p>This module exports types and functions for query construction.</p>
<p><code><a title="pyracmon.query.Q" href="#pyracmon.query.Q">Q</a></code> is the factory class constructing query condition, that is, <code>WHERE</code> clause.
Class methods on <code><a title="pyracmon.query.Q" href="#pyracmon.query.Q">Q</a></code> are designed to concatenate conditions in conjunction with query before <code>WHERE</code> .</p>
<p>Constructed condition results in <code><a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></code> object and <code><a title="pyracmon.query.where" href="#pyracmon.query.where">where()</a></code> extracts <code>WHERE</code> clause and parameters from it.
Due to that, query operation code can be divided into condition construction phase and query formatting phase clearly.</p>
<pre><code class="language-python">cond = Q.eq(&quot;t&quot;, c1=1) &amp; Q.lt(&quot;t&quot;, c2=2)
w, params = where(cond)
db.stmt().execute(&quot;SELECT * FROM table AS t {w} LIMIT $_ OFFSET $_&quot;, *params, 10, 5)
# SQL: SELECT * FROM table AS t WHERE t.c1 = 1 AND t.c2 &lt; 2 LIMIT 10 OFFSET 5
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module exports types and functions for query construction.

`Q` is the factory class constructing query condition, that is, `WHERE` clause.
Class methods on `Q` are designed to concatenate conditions in conjunction with query before `WHERE` .

Constructed condition results in `Conditional` object and `where` extracts `WHERE` clause and parameters from it.
Due to that, query operation code can be divided into condition construction phase and query formatting phase clearly.

```python
cond = Q.eq(&#34;t&#34;, c1=1) &amp; Q.lt(&#34;t&#34;, c2=2)
w, params = where(cond)
db.stmt().execute(&#34;SELECT * FROM table AS t {w} LIMIT $_ OFFSET $_&#34;, *params, 10, 5)
# SQL: SELECT * FROM table AS t WHERE t.c1 = 1 AND t.c2 &lt; 2 LIMIT 10 OFFSET 5
```
&#34;&#34;&#34;
from collections.abc import Sequence, Mapping
from functools import reduce
from itertools import chain
from typing import Any, Callable, Union, Generic, Optional, Protocol, TYPE_CHECKING
from typing_extensions import Self, TypeVarTuple, Unpack, NotRequired


QA = TypeVarTuple(&#39;QA&#39;)
if TYPE_CHECKING:
    # TODO: There are no correct hinting expression for optional arguments in python &lt;= 3.10.
    class Queryable(Protocol, Generic[Unpack[QA]]):
        def eq(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
        def neq(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
        def in_(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
        def not_in(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
        def match(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
        def like(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
        def startswith(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
        def endswith(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
        def lt(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
        def le(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
        def gt(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
        def ge(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
else:
    class Queryable(Protocol, Generic[Unpack[QA]]):
        pass


class Q:
    &#34;&#34;&#34;
    This class provides utility class methods creating conditions.

    Using `of()` is the most simple way to create a condition clause with parameters.

    ```python
    &gt;&gt;&gt; Q.of(&#34;a = $_&#34;, 1)
    Condition: &#39;a = $_&#39; -- [1]
    ```

    Other utility methods correspond to basic operators defined in SQL.
    They takes keyword arguments and create conditions by applying operator to each item respectively.

    ```python
    &gt;&gt;&gt; Q.eq(a=1)
    Condition: &#39;a = %s&#39; -- [1]
    &gt;&gt;&gt; Q.in_(a=[1, 2, 3])
    Condition: &#39;a IN (%s, %s, %s)&#39; -- [1, 2, 3]
    &gt;&gt;&gt; Q.like(a=&#34;abc&#34;)
    Condition: &#39;a LIKE %s&#39; -- [&#34;%abc%&#34;]
    ```

    Multiple arguments generates a condition which concatenates conditions with logical operator, by default `AND` .

    ```python
    &gt;&gt;&gt; Q.eq(a=1, b=2)
    Condition: &#39;a = %s AND b = %s&#39; -- [1, 2]
    ```

    Those methods also accept table alias which is prepended to columns.

    ```python
    &gt;&gt;&gt; Q.eq(&#34;t&#34;, a=1, b=2)
    Condition: &#39;t.a = %s AND t.b = %s&#39;
    ```

    Additionally, the instance of this class has its own functionality to generate condition.

    Each parameter passed to the constructor becomes an instance method of the instance,
    which takes a condition clause including placeholders which will take parameters in query execution phase.
    `pyracmon.connection.Statement.execute` allows unified marker `$_` in spite of DB driver.

    ```python
    &gt;&gt;&gt; q = Q(a=1)
    &gt;&gt;&gt; q.a(&#34;a = $_&#34;)
    Condition: &#39;a = $_&#39; -- [1]
    ```

    Method whose name is not passed to the constructor renders empty condition which has no effect on the query.

    ```python
    &gt;&gt;&gt; q.b(&#34;b = $_&#34;)
    Condition: &#39;&#39; -- []
    ```

    By default, `None` is equivalent to not being passed. Giving `True` at the first argument in constructor changes the behavior.

    ```python
    &gt;&gt;&gt; q = Q(a=1, b=None)
    &gt;&gt;&gt; q.b(&#34;b = $_&#34;)
    Condition: &#39;&#39; -- []
    &gt;&gt;&gt; q = Q(True, a=1, b=None)
    &gt;&gt;&gt; q.b(&#34;b = $_&#34;)
    Condition: &#39;b = $_&#39; -- [None]
    ```

    This feature simplifies a query construction in cases some parameters are absent.

    ```python
    &gt;&gt;&gt; def search(db, q):
    &gt;&gt;&gt;     w, params = where(q.a(&#34;a = $_&#34;) &amp; q.b(&#34;b = $_&#34;))
    &gt;&gt;&gt;     db.stmt().execute(f&#34;SELECT * FROM table {w}&#34;, *params)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; search(db, Q(a=1))      # SELECT * FROM table WHERE a = 1
    &gt;&gt;&gt; search(db, Q(a=1, b=2)) # SELECT * FROM table WHERE a = 1 AND b = 2
    &gt;&gt;&gt; search(db, Q())         # SELECT * FROM table
    ```
    &#34;&#34;&#34;
    class Attribute(Queryable[str]): # type: ignore
        def __init__(self, value):
            self.value = value

        def __call__(
            self,
            expression: Union[str, Callable[[Any], str]],
            convert: Optional[Union[Callable[[Any], Any], Any]] = None,
        ) -&gt; &#39;Conditional&#39;:
            &#34;&#34;&#34;
            Creates conditional object composed of given expression and the attribute value as parameters.

            Args:
                expression: A clause or a function generating a clause by taking the attribute value.
                convert: A function converting the attribute value to parameters.
                    If this function returns a value which is not a list, a list having only the value is used.
            Returns:
                Condition.
            &#34;&#34;&#34;
            expression = expression if isinstance(expression, str) else expression(self.value)

            if callable(convert):
                params = convert(self.value)
            elif convert is not None:
                params = convert
            else:
                params = [self.value]

            return Conditional(expression, params if isinstance(params, list) else [params])

        @property
        def all(self) -&gt; &#39;Q.Attribute&#39;:
            &#34;&#34;&#34;
            Returns composite attribute which applies conditions to every values iterated from attribute value and join them with `AND`.

            Returns:
                Composite attribute.
            &#34;&#34;&#34;
            return Q.CompositeAttribute(self.value, True)

        @property
        def any(self) -&gt; &#39;Q.Attribute&#39;:
            &#34;&#34;&#34;
            Returns composite attribute which applies conditions to every values iterated from attribute value and join them with `OR`.

            Returns:
                Composite attribute.
            &#34;&#34;&#34;
            return Q.CompositeAttribute(self.value, False)

        def __bool__(self):
            return True

        def __and__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return other if bool(self.value) else Conditional()

        def __or__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return other if not bool(self.value) else Conditional()

        def __getattr__(self, key):
            &#34;&#34;&#34;
            Exposes a method which works similarly to &#39;Q&#39; &#39;s utility method of the same name.

            ```python
            &gt;&gt;&gt; q = Q(a = 1)
            &gt;&gt;&gt; q.a.eq(&#34;col&#34;)
            Condition: &#39;col = $_&#39; -- [1]
            &gt;&gt;&gt;
            &gt;&gt;&gt; q.a.eq(&#34;col&#34;, None, &#34;t&#34;)
            Condition: &#39;t.col = $_&#39; -- [1]
            &gt;&gt;&gt;
            &gt;&gt;&gt; q.a.eq(&#34;col&#34;, lambda x: x*2, &#34;t&#34;)
            Condition: &#39;t.col = $_&#39; -- [2]
            ```
            &#34;&#34;&#34;
            method = getattr(Q, key)
            def invoke(col, convert=None, *args, **kwargs):
                if callable(convert):
                    value = convert(self.value)
                else:
                    value = convert if convert is not None else self.value
                kwargs.update({col: value})
                return method(*args, **kwargs)
            return invoke

    class CompositeAttribute(Attribute):
        def __init__(self, value, and_):
            super().__init__(value)
            self._and = and_

        def __call__(self, expression, convert=None):
            conds = [Q.Attribute(v)(expression, convert) for v in self.value]
            return Conditional.all(conds) if self._and else Conditional.any(conds)

        def __getattr__(self, key):
            method = getattr(Q, key)
            def invoke(col, convert=None, *args, **kwargs):
                def conv(v):
                    if callable(convert):
                        return convert(v)
                    else:
                        # REVIEW Replacing every parameter in the list with the same value is meaningless?
                        return convert if convert is not None else v
                conds = [method(*args, **dict(chain(kwargs.items(), [(col, conv(v))]))) for v in self.value]
                return Conditional.all(conds) if self._and else Conditional.any(conds)
            return invoke

    class NoAttribute(Attribute):
        def __init__(self):
            super().__init__(None)

        def __call__(self, expression, holder=lambda x:x):
            return Conditional()

        @property
        def all(self):
            return self

        @property
        def any(self):
            return self

        def __bool__(self):
            return False

        def __and__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return Conditional()

        def __or__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return Conditional()

        def __getattr__(self, key):
            method = getattr(Q, key)
            def invoke(col, convert=None, *args):
                return Conditional()
            return invoke

    def __init__(self, _include_none_: bool = False, **kwargs: Any):
        &#34;&#34;&#34;
        Initializes an instance.

        Args:
            _include_none_: Whether include attributes whose value is `None`.
            kwargs: Denotes pairs of attribute name and parameter.
        &#34;&#34;&#34;
        self.attributes = dict([(k, v) for k, v in kwargs.items() if _include_none_ or v is not None])

    def __getattr__(self, key) -&gt; Attribute:
        if key in self.attributes:
            return Q.Attribute(self.attributes[key])
        else:
            return Q.NoAttribute()

    @classmethod
    def of(cls, expression: str = &#34;&#34;, *params: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Creates a condition directly from an expression and parameters.

        Args:
            expression: Condition expression.
            params: Parameters used in the condition.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return Conditional(expression, list(params))

    @classmethod
    def eq(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Creates a condition applying `=` operator to columns.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def is_null(col, val):
            if val is None:
                return f&#34;{col} IS NULL&#34;, []
            elif val is True:
                return f&#34;{col}&#34;, []
            elif val is False:
                return f&#34;NOT {col}&#34;, []
            return None
        return _conditional(&#34;=&#34;, _and_, kwargs, is_null, _alias_)

    @classmethod
    def neq(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `!=`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def is_null(col, val):
            if val is None:
                return f&#34;{col} IS NOT NULL&#34;, []
            elif val is True:
                return f&#34;NOT {col}&#34;, []
            elif val is False:
                return f&#34;{col}&#34;, []
            return None
        return _conditional(&#34;!=&#34;, _and_, kwargs, is_null, _alias_)

    @classmethod
    def in_(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Sequence[Any]) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `IN`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def in_list(col, val):
            if len(val) == 0:
                return &#34;1 = 0&#34;, []
            else:
                holder = &#39;, &#39;.join([&#39;$_&#39;] * len(val))
                return f&#34;{col} IN ({holder})&#34;, val
        return _conditional(&#34;IN&#34;, _and_, kwargs, in_list, _alias_)

    @classmethod
    def not_in(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Sequence[Any]) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `NOT IN`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def in_list(col, val):
            if len(val) == 0:
                return &#34;&#34;, []
            else:
                holder = &#39;, &#39;.join([&#39;$_&#39;] * len(val))
                return f&#34;{col} NOT IN ({holder})&#34;, val
        return _conditional(&#34;NOT IN&#34;, _and_, kwargs, in_list, _alias_)

    @classmethod
    def match(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be passed to query without being escaped or enclosed.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def like(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be escaped and enclosed with wildcards (%) to execute partial match.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;%{escape_like(v)}%&#34; for k, v in kwargs.items()}, None, _alias_)

    @classmethod
    def startswith(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be escaped and appended with wildcards (%) to execute prefix match.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;{escape_like(v)}%&#34; for k, v in kwargs.items()}, None, _alias_)

    @classmethod
    def endswith(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be escaped and prepended with wildcards (%) to execute backward match.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;%{escape_like(v)}&#34; for k, v in kwargs.items()}, None, _alias_)

    @classmethod
    def lt(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `&lt;`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&lt;&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def le(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `&lt;=`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&lt;=&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def gt(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `&gt;`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&gt;&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def ge(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `&gt;=`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&gt;=&#34;, _and_, kwargs, None, _alias_)


def _conditional(op, and_, column_values, gen=None, alias=None) -&gt; &#39;Conditional&#39;:
    cond = Conditional()

    def concat(c):
        nonlocal cond
        if and_:
            cond &amp;= c
        else:
            cond |= c

    for col, val in column_values.items():
        col = f&#34;{alias}.{col}&#34; if alias else col

        if gen:
            r = gen(col, val)
            if r is not None:
                concat(Conditional(r[0], r[1]))
                continue

        concat(Conditional(f&#34;{col} {op} $_&#34;, [val]))

    return cond


class Expression:
    &#34;&#34;&#34;
    Abstraction of expression in any query.
    &#34;&#34;&#34;
    def __init__(self, expression: str, params: list[Any]):
        #: Expression string.
        self.expression = expression
        #: Parameters corresponding to placeholders in the expression.
        self.params = params


class Conditional(Expression):
    &#34;&#34;&#34;
    Represents a query condition composed of an expression and parameters.

    Parameters must be a list where the index of each parameter matches the index of placeholder for it.
    The expression accepts only the unified marker `$_`.

    Applying logical operators such as `&amp;`, `|` and `~` generates new condition.

    ```python
    &gt;&gt;&gt; c1 = Q.of(&#34;a = $_&#34;, 0)
    &gt;&gt;&gt; c2 = Q.of(&#34;b &lt; $_&#34;, 1)
    &gt;&gt;&gt; c3 = Q.of(&#34;c &gt; $_&#34;, 2)
    &gt;&gt;&gt; c = ~(c1 &amp; c2 | c3)
    &gt;&gt;&gt; c
    Condition: NOT (((a = $_) AND (b &lt; $_)) OR (c &gt; $_)) -- [0, 1, 2]
    ```
    &#34;&#34;&#34;
    @classmethod
    def all(cls, conditionals: Sequence[&#39;Conditional&#39;]) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Concatenates condition objects with `AND`.

        Args:
            conditionals: Condition objects.
        Returns:
            Concatenated condition object.
        &#34;&#34;&#34;
        return reduce(lambda acc, c: acc &amp; c, conditionals, Conditional())

    @classmethod
    def any(cls, conditionals: Sequence[&#39;Conditional&#39;]) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Concatenates condition objects with `OR`.

        Args:
            conditionals: Condition objects.
        Returns:
            Concatenated condition object.
        &#34;&#34;&#34;
        if len(conditionals) == 0:
            return Conditional(&#34;1 = 0&#34;)
        return reduce(lambda acc, c: acc | c, conditionals, Conditional())

    def __init__(self, expression=&#34;&#34;, params=None):
        super().__init__(expression, params or [])

    def __repr__(self):
        return f&#34;Condition: &#39;{self.expression}&#39; -- {self.params}&#34;

    def __and__(self, other) -&gt; &#39;Conditional&#39;:
        expression = &#34;&#34;
        if self.expression and other.expression:
            expression = f&#34;({self.expression}) AND ({other.expression})&#34;
        elif self.expression:
            expression = self.expression
        elif other.expression:
            expression = other.expression

        return Conditional(expression, self.params + other.params)

    def __or__(self, other) -&gt; &#39;Conditional&#39;:
        expression = &#34;&#34;
        if self.expression and other.expression:
            expression = f&#34;({self.expression}) OR ({other.expression})&#34;
        elif self.expression:
            expression = self.expression
        elif other.expression:
            expression = other.expression

        return Conditional(expression, self.params + other.params)

    def __invert__(self) -&gt; &#39;Conditional&#39;:
        if self.expression:
            return Conditional(f&#34;NOT ({self.expression})&#34;, self.params)
        else:
            return Conditional(f&#34;1 = 0&#34;, [])


def escape_like(v: str) -&gt; str:
    &#34;&#34;&#34;
    Escape a string for the use in `LIKE` condition.

    Args:
        v: A string.
    Returns:
        Escaped string.
    &#34;&#34;&#34;
    def esc(c):
        if c == &#34;\\&#34;:
            return r&#34;\\\\&#34;
        elif c == &#34;%&#34;:
            return r&#34;\%&#34;
        elif c == &#34;_&#34;:
            return r&#34;\_&#34;
        else:
            return c
    return &#39;&#39;.join(map(esc, v))


def where(condition: &#39;Conditional&#39;) -&gt; tuple[str, list[Any]]:
    &#34;&#34;&#34;
    Generates a `WHERE` clause and parameters representing given condition.

    If the condition is empty, returned clause is an empty string which does not contain `WHERE` keyword.

    Args:
        condition: Condition object.
    Returns:
        Tuple of `WHERE` clause and parameters.
    &#34;&#34;&#34;
    return (&#39;&#39;, []) if condition.expression == &#39;&#39; else (f&#39;WHERE {condition.expression}&#39;, condition.params)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyracmon.query.escape_like"><code class="name flex">
<span>def <span class="ident">escape_like</span></span>(<span>v:Â str) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Escape a string for the use in <code>LIKE</code> condition.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>v</code></strong></dt>
<dd>A string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Escaped string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def escape_like(v: str) -&gt; str:
    &#34;&#34;&#34;
    Escape a string for the use in `LIKE` condition.

    Args:
        v: A string.
    Returns:
        Escaped string.
    &#34;&#34;&#34;
    def esc(c):
        if c == &#34;\\&#34;:
            return r&#34;\\\\&#34;
        elif c == &#34;%&#34;:
            return r&#34;\%&#34;
        elif c == &#34;_&#34;:
            return r&#34;\_&#34;
        else:
            return c
    return &#39;&#39;.join(map(esc, v))</code></pre>
</details>
</dd>
<dt id="pyracmon.query.where"><code class="name flex">
<span>def <span class="ident">where</span></span>(<span>condition:Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a>) â€‘>Â tuple[str,Â list[typing.Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a <code>WHERE</code> clause and parameters representing given condition.</p>
<p>If the condition is empty, returned clause is an empty string which does not contain <code>WHERE</code> keyword.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>condition</code></strong></dt>
<dd>Condition object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple of <code>WHERE</code> clause and parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def where(condition: &#39;Conditional&#39;) -&gt; tuple[str, list[Any]]:
    &#34;&#34;&#34;
    Generates a `WHERE` clause and parameters representing given condition.

    If the condition is empty, returned clause is an empty string which does not contain `WHERE` keyword.

    Args:
        condition: Condition object.
    Returns:
        Tuple of `WHERE` clause and parameters.
    &#34;&#34;&#34;
    return (&#39;&#39;, []) if condition.expression == &#39;&#39; else (f&#39;WHERE {condition.expression}&#39;, condition.params)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pyracmon.query.Conditional"><code class="flex name class">
<span>class <span class="ident">Conditional</span></span>
<span>(</span><span>expression='', params=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a query condition composed of an expression and parameters.</p>
<p>Parameters must be a list where the index of each parameter matches the index of placeholder for it.
The expression accepts only the unified marker <code>$_</code>.</p>
<p>Applying logical operators such as <code>&amp;</code>, <code>|</code> and <code>~</code> generates new condition.</p>
<pre><code class="language-python">&gt;&gt;&gt; c1 = Q.of(&quot;a = $_&quot;, 0)
&gt;&gt;&gt; c2 = Q.of(&quot;b &lt; $_&quot;, 1)
&gt;&gt;&gt; c3 = Q.of(&quot;c &gt; $_&quot;, 2)
&gt;&gt;&gt; c = ~(c1 &amp; c2 | c3)
&gt;&gt;&gt; c
Condition: NOT (((a = $_) AND (b &lt; $_)) OR (c &gt; $_)) -- [0, 1, 2]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Conditional(Expression):
    &#34;&#34;&#34;
    Represents a query condition composed of an expression and parameters.

    Parameters must be a list where the index of each parameter matches the index of placeholder for it.
    The expression accepts only the unified marker `$_`.

    Applying logical operators such as `&amp;`, `|` and `~` generates new condition.

    ```python
    &gt;&gt;&gt; c1 = Q.of(&#34;a = $_&#34;, 0)
    &gt;&gt;&gt; c2 = Q.of(&#34;b &lt; $_&#34;, 1)
    &gt;&gt;&gt; c3 = Q.of(&#34;c &gt; $_&#34;, 2)
    &gt;&gt;&gt; c = ~(c1 &amp; c2 | c3)
    &gt;&gt;&gt; c
    Condition: NOT (((a = $_) AND (b &lt; $_)) OR (c &gt; $_)) -- [0, 1, 2]
    ```
    &#34;&#34;&#34;
    @classmethod
    def all(cls, conditionals: Sequence[&#39;Conditional&#39;]) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Concatenates condition objects with `AND`.

        Args:
            conditionals: Condition objects.
        Returns:
            Concatenated condition object.
        &#34;&#34;&#34;
        return reduce(lambda acc, c: acc &amp; c, conditionals, Conditional())

    @classmethod
    def any(cls, conditionals: Sequence[&#39;Conditional&#39;]) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Concatenates condition objects with `OR`.

        Args:
            conditionals: Condition objects.
        Returns:
            Concatenated condition object.
        &#34;&#34;&#34;
        if len(conditionals) == 0:
            return Conditional(&#34;1 = 0&#34;)
        return reduce(lambda acc, c: acc | c, conditionals, Conditional())

    def __init__(self, expression=&#34;&#34;, params=None):
        super().__init__(expression, params or [])

    def __repr__(self):
        return f&#34;Condition: &#39;{self.expression}&#39; -- {self.params}&#34;

    def __and__(self, other) -&gt; &#39;Conditional&#39;:
        expression = &#34;&#34;
        if self.expression and other.expression:
            expression = f&#34;({self.expression}) AND ({other.expression})&#34;
        elif self.expression:
            expression = self.expression
        elif other.expression:
            expression = other.expression

        return Conditional(expression, self.params + other.params)

    def __or__(self, other) -&gt; &#39;Conditional&#39;:
        expression = &#34;&#34;
        if self.expression and other.expression:
            expression = f&#34;({self.expression}) OR ({other.expression})&#34;
        elif self.expression:
            expression = self.expression
        elif other.expression:
            expression = other.expression

        return Conditional(expression, self.params + other.params)

    def __invert__(self) -&gt; &#39;Conditional&#39;:
        if self.expression:
            return Conditional(f&#34;NOT ({self.expression})&#34;, self.params)
        else:
            return Conditional(f&#34;1 = 0&#34;, [])</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="pyracmon.query.Expression" href="#pyracmon.query.Expression">Expression</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.query.Conditional.all"><code class="name flex">
<span>def <span class="ident">all</span></span>(<span>conditionals:Â collections.abc.Sequence['<a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a>']) â€‘>Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates condition objects with <code>AND</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>conditionals</code></strong></dt>
<dd>Condition objects.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Concatenated condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def all(cls, conditionals: Sequence[&#39;Conditional&#39;]) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Concatenates condition objects with `AND`.

    Args:
        conditionals: Condition objects.
    Returns:
        Concatenated condition object.
    &#34;&#34;&#34;
    return reduce(lambda acc, c: acc &amp; c, conditionals, Conditional())</code></pre>
</details>
</dd>
<dt id="pyracmon.query.Conditional.any"><code class="name flex">
<span>def <span class="ident">any</span></span>(<span>conditionals:Â collections.abc.Sequence['<a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a>']) â€‘>Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates condition objects with <code>OR</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>conditionals</code></strong></dt>
<dd>Condition objects.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Concatenated condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def any(cls, conditionals: Sequence[&#39;Conditional&#39;]) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Concatenates condition objects with `OR`.

    Args:
        conditionals: Condition objects.
    Returns:
        Concatenated condition object.
    &#34;&#34;&#34;
    if len(conditionals) == 0:
        return Conditional(&#34;1 = 0&#34;)
    return reduce(lambda acc, c: acc | c, conditionals, Conditional())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="pyracmon.query.Expression" href="#pyracmon.query.Expression">Expression</a></b></code>:
<ul class="hlist">
<li><code><a title="pyracmon.query.Expression.expression" href="#pyracmon.query.Expression.expression">expression</a></code></li>
<li><code><a title="pyracmon.query.Expression.params" href="#pyracmon.query.Expression.params">params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="pyracmon.query.Expression"><code class="flex name class">
<span>class <span class="ident">Expression</span></span>
<span>(</span><span>expression:Â str, params:Â list[typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>Abstraction of expression in any query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Expression:
    &#34;&#34;&#34;
    Abstraction of expression in any query.
    &#34;&#34;&#34;
    def __init__(self, expression: str, params: list[Any]):
        #: Expression string.
        self.expression = expression
        #: Parameters corresponding to placeholders in the expression.
        self.params = params</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pyracmon.query.Expression.expression"><code class="name">var <span class="ident">expression</span></code></dt>
<dd>
<div class="desc"><p>Expression string.</p></div>
</dd>
<dt id="pyracmon.query.Expression.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"><p>Parameters corresponding to placeholders in the expression.</p></div>
</dd>
</dl>
</dd>
<dt id="pyracmon.query.Q"><code class="flex name class">
<span>class <span class="ident">Q</span></span>
<span>(</span><span>**kwargs:Â Any)</span>
</code></dt>
<dd>
<div class="desc"><p>This class provides utility class methods creating conditions.</p>
<p>Using <code>of()</code> is the most simple way to create a condition clause with parameters.</p>
<pre><code class="language-python">&gt;&gt;&gt; Q.of(&quot;a = $_&quot;, 1)
Condition: 'a = $_' -- [1]
</code></pre>
<p>Other utility methods correspond to basic operators defined in SQL.
They takes keyword arguments and create conditions by applying operator to each item respectively.</p>
<pre><code class="language-python">&gt;&gt;&gt; Q.eq(a=1)
Condition: 'a = %s' -- [1]
&gt;&gt;&gt; Q.in_(a=[1, 2, 3])
Condition: 'a IN (%s, %s, %s)' -- [1, 2, 3]
&gt;&gt;&gt; Q.like(a=&quot;abc&quot;)
Condition: 'a LIKE %s' -- [&quot;%abc%&quot;]
</code></pre>
<p>Multiple arguments generates a condition which concatenates conditions with logical operator, by default <code>AND</code> .</p>
<pre><code class="language-python">&gt;&gt;&gt; Q.eq(a=1, b=2)
Condition: 'a = %s AND b = %s' -- [1, 2]
</code></pre>
<p>Those methods also accept table alias which is prepended to columns.</p>
<pre><code class="language-python">&gt;&gt;&gt; Q.eq(&quot;t&quot;, a=1, b=2)
Condition: 't.a = %s AND t.b = %s'
</code></pre>
<p>Additionally, the instance of this class has its own functionality to generate condition.</p>
<p>Each parameter passed to the constructor becomes an instance method of the instance,
which takes a condition clause including placeholders which will take parameters in query execution phase.
<code><a title="pyracmon.connection.Statement.execute" href="connection.html#pyracmon.connection.Statement.execute">Statement.execute()</a></code> allows unified marker <code>$_</code> in spite of DB driver.</p>
<pre><code class="language-python">&gt;&gt;&gt; q = Q(a=1)
&gt;&gt;&gt; q.a(&quot;a = $_&quot;)
Condition: 'a = $_' -- [1]
</code></pre>
<p>Method whose name is not passed to the constructor renders empty condition which has no effect on the query.</p>
<pre><code class="language-python">&gt;&gt;&gt; q.b(&quot;b = $_&quot;)
Condition: '' -- []
</code></pre>
<p>By default, <code>None</code> is equivalent to not being passed. Giving <code>True</code> at the first argument in constructor changes the behavior.</p>
<pre><code class="language-python">&gt;&gt;&gt; q = Q(a=1, b=None)
&gt;&gt;&gt; q.b(&quot;b = $_&quot;)
Condition: '' -- []
&gt;&gt;&gt; q = Q(True, a=1, b=None)
&gt;&gt;&gt; q.b(&quot;b = $_&quot;)
Condition: 'b = $_' -- [None]
</code></pre>
<p>This feature simplifies a query construction in cases some parameters are absent.</p>
<pre><code class="language-python">&gt;&gt;&gt; def search(db, q):
&gt;&gt;&gt;     w, params = where(q.a(&quot;a = $_&quot;) &amp; q.b(&quot;b = $_&quot;))
&gt;&gt;&gt;     db.stmt().execute(f&quot;SELECT * FROM table {w}&quot;, *params)
&gt;&gt;&gt; 
&gt;&gt;&gt; search(db, Q(a=1))      # SELECT * FROM table WHERE a = 1
&gt;&gt;&gt; search(db, Q(a=1, b=2)) # SELECT * FROM table WHERE a = 1 AND b = 2
&gt;&gt;&gt; search(db, Q())         # SELECT * FROM table
</code></pre>
<p>Initializes an instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_include_none_</code></strong></dt>
<dd>Whether include attributes whose value is <code>None</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Denotes pairs of attribute name and parameter.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Q:
    &#34;&#34;&#34;
    This class provides utility class methods creating conditions.

    Using `of()` is the most simple way to create a condition clause with parameters.

    ```python
    &gt;&gt;&gt; Q.of(&#34;a = $_&#34;, 1)
    Condition: &#39;a = $_&#39; -- [1]
    ```

    Other utility methods correspond to basic operators defined in SQL.
    They takes keyword arguments and create conditions by applying operator to each item respectively.

    ```python
    &gt;&gt;&gt; Q.eq(a=1)
    Condition: &#39;a = %s&#39; -- [1]
    &gt;&gt;&gt; Q.in_(a=[1, 2, 3])
    Condition: &#39;a IN (%s, %s, %s)&#39; -- [1, 2, 3]
    &gt;&gt;&gt; Q.like(a=&#34;abc&#34;)
    Condition: &#39;a LIKE %s&#39; -- [&#34;%abc%&#34;]
    ```

    Multiple arguments generates a condition which concatenates conditions with logical operator, by default `AND` .

    ```python
    &gt;&gt;&gt; Q.eq(a=1, b=2)
    Condition: &#39;a = %s AND b = %s&#39; -- [1, 2]
    ```

    Those methods also accept table alias which is prepended to columns.

    ```python
    &gt;&gt;&gt; Q.eq(&#34;t&#34;, a=1, b=2)
    Condition: &#39;t.a = %s AND t.b = %s&#39;
    ```

    Additionally, the instance of this class has its own functionality to generate condition.

    Each parameter passed to the constructor becomes an instance method of the instance,
    which takes a condition clause including placeholders which will take parameters in query execution phase.
    `pyracmon.connection.Statement.execute` allows unified marker `$_` in spite of DB driver.

    ```python
    &gt;&gt;&gt; q = Q(a=1)
    &gt;&gt;&gt; q.a(&#34;a = $_&#34;)
    Condition: &#39;a = $_&#39; -- [1]
    ```

    Method whose name is not passed to the constructor renders empty condition which has no effect on the query.

    ```python
    &gt;&gt;&gt; q.b(&#34;b = $_&#34;)
    Condition: &#39;&#39; -- []
    ```

    By default, `None` is equivalent to not being passed. Giving `True` at the first argument in constructor changes the behavior.

    ```python
    &gt;&gt;&gt; q = Q(a=1, b=None)
    &gt;&gt;&gt; q.b(&#34;b = $_&#34;)
    Condition: &#39;&#39; -- []
    &gt;&gt;&gt; q = Q(True, a=1, b=None)
    &gt;&gt;&gt; q.b(&#34;b = $_&#34;)
    Condition: &#39;b = $_&#39; -- [None]
    ```

    This feature simplifies a query construction in cases some parameters are absent.

    ```python
    &gt;&gt;&gt; def search(db, q):
    &gt;&gt;&gt;     w, params = where(q.a(&#34;a = $_&#34;) &amp; q.b(&#34;b = $_&#34;))
    &gt;&gt;&gt;     db.stmt().execute(f&#34;SELECT * FROM table {w}&#34;, *params)
    &gt;&gt;&gt; 
    &gt;&gt;&gt; search(db, Q(a=1))      # SELECT * FROM table WHERE a = 1
    &gt;&gt;&gt; search(db, Q(a=1, b=2)) # SELECT * FROM table WHERE a = 1 AND b = 2
    &gt;&gt;&gt; search(db, Q())         # SELECT * FROM table
    ```
    &#34;&#34;&#34;
    class Attribute(Queryable[str]): # type: ignore
        def __init__(self, value):
            self.value = value

        def __call__(
            self,
            expression: Union[str, Callable[[Any], str]],
            convert: Optional[Union[Callable[[Any], Any], Any]] = None,
        ) -&gt; &#39;Conditional&#39;:
            &#34;&#34;&#34;
            Creates conditional object composed of given expression and the attribute value as parameters.

            Args:
                expression: A clause or a function generating a clause by taking the attribute value.
                convert: A function converting the attribute value to parameters.
                    If this function returns a value which is not a list, a list having only the value is used.
            Returns:
                Condition.
            &#34;&#34;&#34;
            expression = expression if isinstance(expression, str) else expression(self.value)

            if callable(convert):
                params = convert(self.value)
            elif convert is not None:
                params = convert
            else:
                params = [self.value]

            return Conditional(expression, params if isinstance(params, list) else [params])

        @property
        def all(self) -&gt; &#39;Q.Attribute&#39;:
            &#34;&#34;&#34;
            Returns composite attribute which applies conditions to every values iterated from attribute value and join them with `AND`.

            Returns:
                Composite attribute.
            &#34;&#34;&#34;
            return Q.CompositeAttribute(self.value, True)

        @property
        def any(self) -&gt; &#39;Q.Attribute&#39;:
            &#34;&#34;&#34;
            Returns composite attribute which applies conditions to every values iterated from attribute value and join them with `OR`.

            Returns:
                Composite attribute.
            &#34;&#34;&#34;
            return Q.CompositeAttribute(self.value, False)

        def __bool__(self):
            return True

        def __and__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return other if bool(self.value) else Conditional()

        def __or__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return other if not bool(self.value) else Conditional()

        def __getattr__(self, key):
            &#34;&#34;&#34;
            Exposes a method which works similarly to &#39;Q&#39; &#39;s utility method of the same name.

            ```python
            &gt;&gt;&gt; q = Q(a = 1)
            &gt;&gt;&gt; q.a.eq(&#34;col&#34;)
            Condition: &#39;col = $_&#39; -- [1]
            &gt;&gt;&gt;
            &gt;&gt;&gt; q.a.eq(&#34;col&#34;, None, &#34;t&#34;)
            Condition: &#39;t.col = $_&#39; -- [1]
            &gt;&gt;&gt;
            &gt;&gt;&gt; q.a.eq(&#34;col&#34;, lambda x: x*2, &#34;t&#34;)
            Condition: &#39;t.col = $_&#39; -- [2]
            ```
            &#34;&#34;&#34;
            method = getattr(Q, key)
            def invoke(col, convert=None, *args, **kwargs):
                if callable(convert):
                    value = convert(self.value)
                else:
                    value = convert if convert is not None else self.value
                kwargs.update({col: value})
                return method(*args, **kwargs)
            return invoke

    class CompositeAttribute(Attribute):
        def __init__(self, value, and_):
            super().__init__(value)
            self._and = and_

        def __call__(self, expression, convert=None):
            conds = [Q.Attribute(v)(expression, convert) for v in self.value]
            return Conditional.all(conds) if self._and else Conditional.any(conds)

        def __getattr__(self, key):
            method = getattr(Q, key)
            def invoke(col, convert=None, *args, **kwargs):
                def conv(v):
                    if callable(convert):
                        return convert(v)
                    else:
                        # REVIEW Replacing every parameter in the list with the same value is meaningless?
                        return convert if convert is not None else v
                conds = [method(*args, **dict(chain(kwargs.items(), [(col, conv(v))]))) for v in self.value]
                return Conditional.all(conds) if self._and else Conditional.any(conds)
            return invoke

    class NoAttribute(Attribute):
        def __init__(self):
            super().__init__(None)

        def __call__(self, expression, holder=lambda x:x):
            return Conditional()

        @property
        def all(self):
            return self

        @property
        def any(self):
            return self

        def __bool__(self):
            return False

        def __and__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return Conditional()

        def __or__(self, other: &#39;Conditional&#39;) -&gt; &#39;Conditional&#39;:
            return Conditional()

        def __getattr__(self, key):
            method = getattr(Q, key)
            def invoke(col, convert=None, *args):
                return Conditional()
            return invoke

    def __init__(self, _include_none_: bool = False, **kwargs: Any):
        &#34;&#34;&#34;
        Initializes an instance.

        Args:
            _include_none_: Whether include attributes whose value is `None`.
            kwargs: Denotes pairs of attribute name and parameter.
        &#34;&#34;&#34;
        self.attributes = dict([(k, v) for k, v in kwargs.items() if _include_none_ or v is not None])

    def __getattr__(self, key) -&gt; Attribute:
        if key in self.attributes:
            return Q.Attribute(self.attributes[key])
        else:
            return Q.NoAttribute()

    @classmethod
    def of(cls, expression: str = &#34;&#34;, *params: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Creates a condition directly from an expression and parameters.

        Args:
            expression: Condition expression.
            params: Parameters used in the condition.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return Conditional(expression, list(params))

    @classmethod
    def eq(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Creates a condition applying `=` operator to columns.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def is_null(col, val):
            if val is None:
                return f&#34;{col} IS NULL&#34;, []
            elif val is True:
                return f&#34;{col}&#34;, []
            elif val is False:
                return f&#34;NOT {col}&#34;, []
            return None
        return _conditional(&#34;=&#34;, _and_, kwargs, is_null, _alias_)

    @classmethod
    def neq(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `!=`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def is_null(col, val):
            if val is None:
                return f&#34;{col} IS NOT NULL&#34;, []
            elif val is True:
                return f&#34;NOT {col}&#34;, []
            elif val is False:
                return f&#34;{col}&#34;, []
            return None
        return _conditional(&#34;!=&#34;, _and_, kwargs, is_null, _alias_)

    @classmethod
    def in_(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Sequence[Any]) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `IN`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def in_list(col, val):
            if len(val) == 0:
                return &#34;1 = 0&#34;, []
            else:
                holder = &#39;, &#39;.join([&#39;$_&#39;] * len(val))
                return f&#34;{col} IN ({holder})&#34;, val
        return _conditional(&#34;IN&#34;, _and_, kwargs, in_list, _alias_)

    @classmethod
    def not_in(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Sequence[Any]) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `NOT IN`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        def in_list(col, val):
            if len(val) == 0:
                return &#34;&#34;, []
            else:
                holder = &#39;, &#39;.join([&#39;$_&#39;] * len(val))
                return f&#34;{col} NOT IN ({holder})&#34;, val
        return _conditional(&#34;NOT IN&#34;, _and_, kwargs, in_list, _alias_)

    @classmethod
    def match(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be passed to query without being escaped or enclosed.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def like(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be escaped and enclosed with wildcards (%) to execute partial match.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;%{escape_like(v)}%&#34; for k, v in kwargs.items()}, None, _alias_)

    @classmethod
    def startswith(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be escaped and appended with wildcards (%) to execute prefix match.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;{escape_like(v)}%&#34; for k, v in kwargs.items()}, None, _alias_)

    @classmethod
    def endswith(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `LIKE`. Given parameters will be escaped and prepended with wildcards (%) to execute backward match.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;%{escape_like(v)}&#34; for k, v in kwargs.items()}, None, _alias_)

    @classmethod
    def lt(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `&lt;`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&lt;&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def le(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `&lt;=`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&lt;=&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def gt(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `&gt;`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&gt;&#34;, _and_, kwargs, None, _alias_)

    @classmethod
    def ge(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
        &#34;&#34;&#34;
        Works like `eq`, but applies `&gt;=`.

        Args:
            _alias_: Table alias.
            _and_: Specifies concatenating logical operator is `AND` or `OR`.
            kwargs: Column names and parameters.
        Returns:
            Condition object.
        &#34;&#34;&#34;
        return _conditional(&#34;&gt;=&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pyracmon.query.Q.Attribute"><code class="name">var <span class="ident">Attribute</span></code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
</dd>
<dt id="pyracmon.query.Q.CompositeAttribute"><code class="name">var <span class="ident">CompositeAttribute</span></code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
</dd>
<dt id="pyracmon.query.Q.NoAttribute"><code class="name">var <span class="ident">NoAttribute</span></code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pyracmon.query.Q.endswith"><code class="name flex">
<span>def <span class="ident">endswith</span></span>(<span>**kwargs:Â str) â€‘>Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>LIKE</code>. Given parameters will be escaped and prepended with wildcards (%) to execute backward match.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def endswith(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `LIKE`. Given parameters will be escaped and prepended with wildcards (%) to execute backward match.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;%{escape_like(v)}&#34; for k, v in kwargs.items()}, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.query.Q.eq"><code class="name flex">
<span>def <span class="ident">eq</span></span>(<span>**kwargs:Â Any) â€‘>Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a condition applying <code>=</code> operator to columns.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def eq(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Creates a condition applying `=` operator to columns.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    def is_null(col, val):
        if val is None:
            return f&#34;{col} IS NULL&#34;, []
        elif val is True:
            return f&#34;{col}&#34;, []
        elif val is False:
            return f&#34;NOT {col}&#34;, []
        return None
    return _conditional(&#34;=&#34;, _and_, kwargs, is_null, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.query.Q.ge"><code class="name flex">
<span>def <span class="ident">ge</span></span>(<span>**kwargs:Â Any) â€‘>Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>&gt;=</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def ge(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `&gt;=`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;&gt;=&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.query.Q.gt"><code class="name flex">
<span>def <span class="ident">gt</span></span>(<span>**kwargs:Â Any) â€‘>Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>&gt;</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def gt(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `&gt;`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;&gt;&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.query.Q.in_"><code class="name flex">
<span>def <span class="ident">in_</span></span>(<span>**kwargs:Â collections.abc.Sequence[typing.Any]) â€‘>Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>IN</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def in_(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Sequence[Any]) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `IN`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    def in_list(col, val):
        if len(val) == 0:
            return &#34;1 = 0&#34;, []
        else:
            holder = &#39;, &#39;.join([&#39;$_&#39;] * len(val))
            return f&#34;{col} IN ({holder})&#34;, val
    return _conditional(&#34;IN&#34;, _and_, kwargs, in_list, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.query.Q.le"><code class="name flex">
<span>def <span class="ident">le</span></span>(<span>**kwargs:Â Any) â€‘>Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>&lt;=</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def le(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `&lt;=`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;&lt;=&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.query.Q.like"><code class="name flex">
<span>def <span class="ident">like</span></span>(<span>**kwargs:Â str) â€‘>Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>LIKE</code>. Given parameters will be escaped and enclosed with wildcards (%) to execute partial match.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def like(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `LIKE`. Given parameters will be escaped and enclosed with wildcards (%) to execute partial match.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;%{escape_like(v)}%&#34; for k, v in kwargs.items()}, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.query.Q.lt"><code class="name flex">
<span>def <span class="ident">lt</span></span>(<span>**kwargs:Â Any) â€‘>Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>&lt;</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def lt(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `&lt;`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;&lt;&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.query.Q.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>**kwargs:Â str) â€‘>Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>LIKE</code>. Given parameters will be passed to query without being escaped or enclosed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def match(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `LIKE`. Given parameters will be passed to query without being escaped or enclosed.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;LIKE&#34;, _and_, kwargs, None, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.query.Q.neq"><code class="name flex">
<span>def <span class="ident">neq</span></span>(<span>**kwargs:Â Any) â€‘>Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>!=</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def neq(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Any) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `!=`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    def is_null(col, val):
        if val is None:
            return f&#34;{col} IS NOT NULL&#34;, []
        elif val is True:
            return f&#34;NOT {col}&#34;, []
        elif val is False:
            return f&#34;{col}&#34;, []
        return None
    return _conditional(&#34;!=&#34;, _and_, kwargs, is_null, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.query.Q.not_in"><code class="name flex">
<span>def <span class="ident">not_in</span></span>(<span>**kwargs:Â collections.abc.Sequence[typing.Any]) â€‘>Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>NOT IN</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def not_in(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: Sequence[Any]) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `NOT IN`.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    def in_list(col, val):
        if len(val) == 0:
            return &#34;&#34;, []
        else:
            holder = &#39;, &#39;.join([&#39;$_&#39;] * len(val))
            return f&#34;{col} NOT IN ({holder})&#34;, val
    return _conditional(&#34;NOT IN&#34;, _and_, kwargs, in_list, _alias_)</code></pre>
</details>
</dd>
<dt id="pyracmon.query.Q.of"><code class="name flex">
<span>def <span class="ident">of</span></span>(<span>expression:Â strÂ =Â '', *params:Â Any) â€‘>Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a condition directly from an expression and parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>expression</code></strong></dt>
<dd>Condition expression.</dd>
<dt><strong><code>params</code></strong></dt>
<dd>Parameters used in the condition.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def of(cls, expression: str = &#34;&#34;, *params: Any) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Creates a condition directly from an expression and parameters.

    Args:
        expression: Condition expression.
        params: Parameters used in the condition.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return Conditional(expression, list(params))</code></pre>
</details>
</dd>
<dt id="pyracmon.query.Q.startswith"><code class="name flex">
<span>def <span class="ident">startswith</span></span>(<span>**kwargs:Â str) â€‘>Â <a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></span>
</code></dt>
<dd>
<div class="desc"><p>Works like <code>eq</code>, but applies <code>LIKE</code>. Given parameters will be escaped and appended with wildcards (%) to execute prefix match.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>_alias_</code></strong></dt>
<dd>Table alias.</dd>
<dt><strong><code>_and_</code></strong></dt>
<dd>Specifies concatenating logical operator is <code>AND</code> or <code>OR</code>.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Column names and parameters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Condition object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def startswith(cls, _alias_: Optional[str] = None, _and_: bool = True, **kwargs: str) -&gt; &#39;Conditional&#39;:
    &#34;&#34;&#34;
    Works like `eq`, but applies `LIKE`. Given parameters will be escaped and appended with wildcards (%) to execute prefix match.

    Args:
        _alias_: Table alias.
        _and_: Specifies concatenating logical operator is `AND` or `OR`.
        kwargs: Column names and parameters.
    Returns:
        Condition object.
    &#34;&#34;&#34;
    return _conditional(&#34;LIKE&#34;, _and_, {k: f&#34;{escape_like(v)}%&#34; for k, v in kwargs.items()}, None, _alias_)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pyracmon.query.Queryable"><code class="flex name class">
<span>class <span class="ident">Queryable</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes.</p>
<p>Protocol classes are defined as::</p>
<pre><code>class Proto(Protocol):
    def meth(self) -&gt; int:
        ...
</code></pre>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<pre><code>class C:
    def meth(self) -&gt; int:
        return 0

def func(x: Proto) -&gt; int:
    return x.meth()

func(C())  # Passes static type check
</code></pre>
<p>See PEP 544 for details. Protocol classes decorated with
@typing.runtime_checkable act as simple-minded runtime protocols that check
only the presence of given attributes, ignoring their type signatures.
Protocol classes can be generic, they are defined as::</p>
<pre><code>class GenProto(Protocol[T]):
    def meth(self) -&gt; T:
        ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Queryable(Protocol, Generic[Unpack[QA]]):
    def eq(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
    def neq(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
    def in_(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
    def not_in(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
    def match(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
    def like(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
    def startswith(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
    def endswith(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
    def lt(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
    def le(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
    def gt(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...
    def ge(self, *args: Union[Unpack[QA], Unpack[tuple[Unpack[QA], Any]]]) -&gt; &#39;Conditional&#39;: ...</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="pyracmon.query.Q.Attribute" href="#pyracmon.query.Q.Attribute">Q.Attribute</a></li>
<li><a title="pyracmon.select.AliasedColumn" href="select.html#pyracmon.select.AliasedColumn">AliasedColumn</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyracmon" href="index.html">pyracmon</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyracmon.query.escape_like" href="#pyracmon.query.escape_like">escape_like</a></code></li>
<li><code><a title="pyracmon.query.where" href="#pyracmon.query.where">where</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pyracmon.query.Conditional" href="#pyracmon.query.Conditional">Conditional</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.query.Conditional.all" href="#pyracmon.query.Conditional.all">all</a></code></li>
<li><code><a title="pyracmon.query.Conditional.any" href="#pyracmon.query.Conditional.any">any</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.query.Expression" href="#pyracmon.query.Expression">Expression</a></code></h4>
<ul class="">
<li><code><a title="pyracmon.query.Expression.expression" href="#pyracmon.query.Expression.expression">expression</a></code></li>
<li><code><a title="pyracmon.query.Expression.params" href="#pyracmon.query.Expression.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.query.Q" href="#pyracmon.query.Q">Q</a></code></h4>
<ul class="two-column">
<li><code><a title="pyracmon.query.Q.Attribute" href="#pyracmon.query.Q.Attribute">Attribute</a></code></li>
<li><code><a title="pyracmon.query.Q.CompositeAttribute" href="#pyracmon.query.Q.CompositeAttribute">CompositeAttribute</a></code></li>
<li><code><a title="pyracmon.query.Q.NoAttribute" href="#pyracmon.query.Q.NoAttribute">NoAttribute</a></code></li>
<li><code><a title="pyracmon.query.Q.endswith" href="#pyracmon.query.Q.endswith">endswith</a></code></li>
<li><code><a title="pyracmon.query.Q.eq" href="#pyracmon.query.Q.eq">eq</a></code></li>
<li><code><a title="pyracmon.query.Q.ge" href="#pyracmon.query.Q.ge">ge</a></code></li>
<li><code><a title="pyracmon.query.Q.gt" href="#pyracmon.query.Q.gt">gt</a></code></li>
<li><code><a title="pyracmon.query.Q.in_" href="#pyracmon.query.Q.in_">in_</a></code></li>
<li><code><a title="pyracmon.query.Q.le" href="#pyracmon.query.Q.le">le</a></code></li>
<li><code><a title="pyracmon.query.Q.like" href="#pyracmon.query.Q.like">like</a></code></li>
<li><code><a title="pyracmon.query.Q.lt" href="#pyracmon.query.Q.lt">lt</a></code></li>
<li><code><a title="pyracmon.query.Q.match" href="#pyracmon.query.Q.match">match</a></code></li>
<li><code><a title="pyracmon.query.Q.neq" href="#pyracmon.query.Q.neq">neq</a></code></li>
<li><code><a title="pyracmon.query.Q.not_in" href="#pyracmon.query.Q.not_in">not_in</a></code></li>
<li><code><a title="pyracmon.query.Q.of" href="#pyracmon.query.Q.of">of</a></code></li>
<li><code><a title="pyracmon.query.Q.startswith" href="#pyracmon.query.Q.startswith">startswith</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pyracmon.query.Queryable" href="#pyracmon.query.Queryable">Queryable</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>